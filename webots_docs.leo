<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20210414173045.1"><vh>@settings</vh>
<v t="leo.20210414173045.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20210414173045.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20210414180353.1"><vh>About Webots</vh>
<v t="leo.20210414181506.1"><vh>Technical questions</vh></v>
<v t="leo.20210414181645.1"><vh>Web streaming</vh></v>
</v>
<v t="leo.20210414212857.1"><vh>研究 showdown js</vh></v>
<v t="leo.20210414172957.1"><vh>add robot component</vh></v>
<v t="leo.20210414164039.2"><vh>@edit index.html</vh></v>
<v t="leo.20210414180847.1"><vh>@path old\wwi\R2018a</vh>
<v t="leo.20210414180856.1"><vh>@clean webots.js</vh>
<v t="leo.20210414180912.1"><vh>webots.View = function</vh>
<v t="leo.20210414180912.2"><vh>this.onerror = function</vh></v>
<v t="leo.20210414180912.3"><vh>this.onstdout = function</vh></v>
<v t="leo.20210414180912.4"><vh>this.onstderr = function</vh></v>
<v t="leo.20210414180912.5"><vh>this.onrobotmessage = function</vh></v>
<v t="leo.20210414180912.6"><vh>this.onrobotwindowsdestroy = function</vh></v>
<v t="leo.20210414180912.7"><vh>this.onquit = function</vh></v>
<v t="leo.20210414180912.8"><vh>this.onresize = function</vh></v>
<v t="leo.20210414180912.9"><vh>this.ondialogwindow = function</vh></v>
<v t="leo.20210414180912.10"><vh>$(document).bind("keydown keypress", function</vh></v>
<v t="leo.20210414180912.11"><vh>$("#contextMenu").on("menuselect", function</vh></v>
</v>
<v t="leo.20210414180912.12"><vh>webots.View.prototype.setTimeout = function</vh></v>
<v t="leo.20210414180912.13"><vh>webots.View.prototype.open = function</vh>
<v t="leo.20210414180912.14"><vh>function requestQuit</vh></v>
<v t="leo.20210414180912.15"><vh>function quit</vh></v>
<v t="leo.20210414180912.16"><vh>function revert</vh></v>
<v t="leo.20210414180912.17"><vh>function pause</vh></v>
<v t="leo.20210414180912.18"><vh>function realTime</vh></v>
<v t="leo.20210414180912.19"><vh>function step</vh></v>
<v t="leo.20210414180912.20"><vh>function requestFullscreen</vh></v>
<v t="leo.20210414180912.21"><vh>function exitFullscreen</vh></v>
<v t="leo.20210414180912.22"><vh>function fullscreenchange</vh></v>
<v t="leo.20210414180912.23"><vh>function toolBarButton</vh></v>
<v t="leo.20210414180912.24"><vh>function toggleInfo</vh></v>
<v t="leo.20210414180912.25"><vh>function toggleConsole</vh></v>
<v t="leo.20210414180912.26"><vh>function toggleHelp</vh></v>
<v t="leo.20210414180912.27"><vh>function enableToolBarButtons</vh></v>
<v t="leo.20210414180912.28"><vh>function initWorld</vh>
<v t="leo.20210414180912.29"><vh>x3dom.Texture.prototype.update = function</vh></v>
<v t="leo.20210414180912.30"><vh>x3dom.debug.doLog = function</vh></v>
</v>
<v t="leo.20210414180912.31"><vh>function initX3Dom</vh>
<v t="leo.20210414180912.32"><vh>script.onerror = function</vh></v>
</v>
<v t="leo.20210414180912.33"><vh>function initX3dFile</vh>
<v t="leo.20210414180912.34"><vh>xmlhttp.onreadystatechange = function</vh></v>
</v>
<v t="leo.20210414180912.35"><vh>function x3domFinalize</vh>
<v t="leo.20210414180912.36"><vh>function loadRobotWindow</vh>
<v t="leo.20210414180912.37"><vh>function closeInfoWindow</vh></v>
<v t="leo.20210414180912.38"><vh>$.get("window/" + windowName + "/" + windowName + ".html", function</vh>
<v t="leo.20210414180912.39"><vh>$.get("window/" + windowName + "/" + windowName + ".js", function</vh></v>
</v>
</v>
</v>
<v t="leo.20210414180912.40"><vh>function loadFinalize</vh></v>
<v t="leo.20210414180912.41"><vh>function addX3domMouseNavigation</vh>
<v t="leo.20210414180912.42"><vh>that.x3dNode.addEventListener('wheel', function</vh></v>
<v t="leo.20210414180912.43"><vh>that.x3dNode.addEventListener('mousemove', function</vh></v>
<v t="leo.20210414180912.44"><vh>that.x3dNode.addEventListener('mousedown', function</vh></v>
<v t="leo.20210414180912.45"><vh>that.x3dNode.addEventListener('mouseup', function</vh></v>
<v t="leo.20210414180912.46"><vh>that.x3dNode.addEventListener('mouseover', function</vh></v>
<v t="leo.20210414180912.47"><vh>that.x3dNode.addEventListener('mouseleave', function</vh></v>
<v t="leo.20210414180912.48"><vh>that.x3dScene.addEventListener('mouseup', function</vh>
<v t="leo.20210414180912.49"><vh>$ function</vh></v>
</v>
</v>
<v t="leo.20210414180912.50"><vh>function wheelTimeoutCallback</vh></v>
<v t="leo.20210414180912.51"><vh>function getTopX3dElement</vh></v>
<v t="leo.20210414180912.52"><vh>function unselect</vh></v>
<v t="leo.20210414180912.53"><vh>function select</vh></v>
<v t="leo.20210414180912.54"><vh>function videoFinalize</vh></v>
<v t="leo.20210414180912.55"><vh>function sendVideoMouseEvent</vh></v>
<v t="leo.20210414180912.56"><vh>function onVideoMouseDown</vh></v>
<v t="leo.20210414180912.57"><vh>function onVideoMouseMove</vh></v>
<v t="leo.20210414180912.58"><vh>function onVideoMouseUp</vh></v>
<v t="leo.20210414180912.59"><vh>function onVideoWheel</vh></v>
<v t="leo.20210414180912.60"><vh>function onVideoContextMenu</vh></v>
<v t="leo.20210414180912.61"><vh>function addVideoMouseNavigation</vh></v>
</v>
<v t="leo.20210414180912.62"><vh>webots.View.prototype.follow = function</vh></v>
<v t="leo.20210414180912.63"><vh>webots.View.prototype.setViewpointMass = function</vh></v>
<v t="leo.20210414180912.64"><vh>webots.View.prototype.updateViewpointPosition = function</vh></v>
<v t="leo.20210414180912.65"><vh>webots.View.prototype.close = function</vh></v>
<v t="leo.20210414180912.66"><vh>webots.View.prototype.sendRobotMessage = function</vh></v>
<v t="leo.20210414180912.67"><vh>webots.View.prototype.resize = function</vh></v>
<v t="leo.20210414180912.68"><vh>webots.View.prototype.getControllerUrl = function</vh></v>
<v t="leo.20210414180912.69"><vh>webots.View.prototype.setAnimation = function</vh></v>
<v t="leo.20210414180912.70"><vh>webots.View.prototype.applyPose = function</vh></v>
<v t="leo.20210414180912.71"><vh>webots.Animation = function</vh></v>
<v t="leo.20210414180912.72"><vh>webots.Animation.prototype.init = function</vh>
<v t="leo.20210414180912.73"><vh>xmlhttp.onreadystatechange = function</vh></v>
<v t="leo.20210414180912.74"><vh>function setup</vh></v>
<v t="leo.20210414180912.75"><vh>function elapsedTime</vh></v>
<v t="leo.20210414180912.76"><vh>function triggerPlayPauseButton</vh></v>
<v t="leo.20210414180912.77"><vh>function connectSliderEvents</vh></v>
<v t="leo.20210414180912.78"><vh>function disconnectSliderEvents</vh></v>
<v t="leo.20210414180912.79"><vh>function updateSlider</vh></v>
<v t="leo.20210414180912.80"><vh>function updateAnimationState</vh></v>
<v t="leo.20210414180912.81"><vh>function updateAnimation</vh></v>
</v>
<v t="leo.20210414180912.82"><vh>webots.Server = function</vh>
<v t="leo.20210414180912.83"><vh>xhr.onreadystatechange = function</vh>
<v t="leo.20210414180912.84"><vh>that.socket.onopen = function</vh></v>
<v t="leo.20210414180912.85"><vh>that.socket.onclose = function</vh></v>
<v t="leo.20210414180912.86"><vh>that.socket.onmessage = function</vh></v>
<v t="leo.20210414180912.87"><vh>that.socket.onerror = function</vh></v>
</v>
</v>
<v t="leo.20210414180912.88"><vh>webots.Server.prototype.resetController = function</vh></v>
<v t="leo.20210414180912.89"><vh>webots.Stream = function</vh>
<v t="leo.20210414180912.90"><vh>this.socket.onopen = function</vh></v>
<v t="leo.20210414180912.91"><vh>this.socket.onclose = function</vh></v>
<v t="leo.20210414180912.92"><vh>this.socket.onmessage = function</vh></v>
<v t="leo.20210414180912.93"><vh>this.socket.onerror = function</vh></v>
<v t="leo.20210414180912.94"><vh>function destroyWorld</vh></v>
</v>
<v t="leo.20210414180912.95"><vh>webots.Stream.prototype.close = function</vh></v>
<v t="leo.20210414180912.96"><vh>function webotsClampDialogSize</vh></v>
<v t="leo.20210414180912.97"><vh>function webotsOpenDialog</vh>
<v t="leo.20210414180912.98"><vh>$(this).parent().hover function</vh></v>
</v>
<v t="leo.20210414180912.99"><vh>function webotsDisablePointerEvents</vh></v>
<v t="leo.20210414180912.100"><vh>function webotsEnablePointerEvents</vh></v>
<v t="leo.20210414180912.101"><vh>webots.Editor = function</vh>
<v t="leo.20210414180912.102"><vh>function webotsEditorResize</vh></v>
<v t="leo.20210414180912.103"><vh>function hideMenu</vh></v>
<v t="leo.20210414180912.104"><vh>function openResetConfirmDialog</vh></v>
<v t="leo.20210414180912.105"><vh>$('#webotsEditorSaveAction').click function</vh></v>
<v t="leo.20210414180912.106"><vh>$('#webotsEditorSaveAllAction').click function</vh></v>
<v t="leo.20210414180912.107"><vh>$('#webotsEditorResetAction').click function</vh></v>
<v t="leo.20210414180912.108"><vh>$('#webotsEditorResetAllAction').click function</vh></v>
<v t="leo.20210414180912.109"><vh>$('#webotsEditorMenuImage').click function</vh></v>
<v t="leo.20210414180912.110"><vh>$("#webotsEditorMenu").focusout function</vh>
<v t="leo.20210414180912.111"><vh>window.setTimeout function</vh></v>
</v>
</v>
<v t="leo.20210414180912.112"><vh>webots.Editor.prototype.hasUnsavedChanges = function</vh></v>
<v t="leo.20210414180912.113"><vh>webots.Editor.prototype.storeUserFile = function</vh></v>
<v t="leo.20210414180912.114"><vh>webots.Editor.prototype.upload = function</vh></v>
<v t="leo.20210414180912.115"><vh>webots.Editor.prototype.save = function</vh></v>
<v t="leo.20210414180912.116"><vh>webots.Editor.prototype.hideReloadMessage = function</vh></v>
<v t="leo.20210414180912.117"><vh>webots.Editor.prototype.textChange = function</vh></v>
<v t="leo.20210414180912.118"><vh>webots.Editor.prototype.aceMode = function</vh></v>
<v t="leo.20210414180912.119"><vh>webots.Editor.prototype.addFile = function</vh></v>
<v t="leo.20210414180912.120"><vh>webots.Editor.prototype.closeAllTabs = function</vh></v>
<v t="leo.20210414180912.121"><vh>webots.Console = function</vh>
<v t="leo.20210414180912.122"><vh>function closeConsole</vh></v>
</v>
<v t="leo.20210414180912.123"><vh>webots.Console.prototype.scrollDown = function</vh></v>
<v t="leo.20210414180912.124"><vh>webots.Console.prototype.clear = function</vh></v>
<v t="leo.20210414180912.125"><vh>webots.Console.prototype.log = function</vh>
<v t="leo.20210414180912.126"><vh>function hourString</vh></v>
</v>
<v t="leo.20210414180912.127"><vh>webots.Console.prototype.stdout = function</vh></v>
<v t="leo.20210414180912.128"><vh>webots.Console.prototype.stderr = function</vh></v>
<v t="leo.20210414180912.129"><vh>webots.Console.prototype.info = function</vh></v>
<v t="leo.20210414180912.130"><vh>webots.Console.prototype.error = function</vh></v>
<v t="leo.20210414180912.131"><vh>webots.HelpWindow = function</vh>
<v t="leo.20210414180912.132"><vh>function closeConsole</vh></v>
<v t="leo.20210414180912.133"><vh>function finalize</vh></v>
</v>
<v t="leo.20210414180912.134"><vh>webots.RobotWindow = function</vh></v>
<v t="leo.20210414180912.135"><vh>webots.RobotWindow.prototype.setProperties = function</vh></v>
<v t="leo.20210414180912.136"><vh>webots.RobotWindow.prototype.geometry = function</vh></v>
<v t="leo.20210414180912.137"><vh>webots.RobotWindow.prototype.restoreGeometry = function</vh></v>
<v t="leo.20210414180912.138"><vh>webots.RobotWindow.prototype.destroy = function</vh></v>
<v t="leo.20210414180912.139"><vh>webots.RobotWindow.prototype.setContent = function</vh></v>
<v t="leo.20210414180912.140"><vh>webots.RobotWindow.prototype.open = function</vh></v>
<v t="leo.20210414180912.141"><vh>webots.RobotWindow.prototype.isOpen = function</vh></v>
<v t="leo.20210414180912.142"><vh>webots.RobotWindow.prototype.close = function</vh></v>
<v t="leo.20210414180912.143"><vh>webots.RobotWindow.prototype.send = function</vh></v>
<v t="leo.20210414180912.144"><vh>webots.RobotWindow.prototype.receive = function</vh></v>
<v t="leo.20210414180912.145"><vh>webots.window = function</vh></v>
<v t="leo.20210414180912.146"><vh>webots.alert = function</vh></v>
<v t="leo.20210414180912.147"><vh>webots.confirm = function</vh></v>
<v t="leo.20210414180912.148"><vh>webots.userCredentials = function</vh>
<v t="leo.20210414180912.149"><vh>function getCookie</vh></v>
</v>
<v t="leo.20210414180912.150"><vh>webots.parseMillisecondsIntoReadableTime = function</vh></v>
<v t="leo.20210414180912.151"><vh>webots.currentScriptPath = function</vh></v>
<v t="leo.20210414180912.152"><vh>String.prototype.startsWith = function</vh></v>
<v t="leo.20210414180912.153"><vh>String.prototype.endsWith = function</vh></v>
</v>
</v>
<v t="leo.20210414181008.1"><vh>@path old\wwi\R2018b</vh>
<v t="leo.20210414181014.1"><vh>@clean webots.js</vh>
<v t="leo.20210414181027.1"><vh>webots.View = function</vh>
<v t="leo.20210414181027.2"><vh>this.onerror = function</vh></v>
<v t="leo.20210414181027.3"><vh>this.onstdout = function</vh></v>
<v t="leo.20210414181027.4"><vh>this.onstderr = function</vh></v>
<v t="leo.20210414181027.5"><vh>this.onrobotmessage = function</vh></v>
<v t="leo.20210414181027.6"><vh>this.onrobotwindowsdestroy = function</vh></v>
<v t="leo.20210414181027.7"><vh>this.onquit = function</vh></v>
<v t="leo.20210414181027.8"><vh>this.onresize = function</vh></v>
<v t="leo.20210414181027.9"><vh>this.ondialogwindow = function</vh></v>
<v t="leo.20210414181027.10"><vh>$(document).bind('keydown keypress', function</vh></v>
<v t="leo.20210414181027.11"><vh>$('#contextMenu').on('menuselect', function</vh></v>
</v>
<v t="leo.20210414181027.12"><vh>webots.View.prototype.setTimeout = function</vh></v>
<v t="leo.20210414181027.13"><vh>webots.View.prototype.setWebotsDocUrl = function</vh></v>
<v t="leo.20210414181027.14"><vh>webots.View.prototype.open = function</vh>
<v t="leo.20210414181027.15"><vh>function requestQuit</vh></v>
<v t="leo.20210414181027.16"><vh>function quit</vh></v>
<v t="leo.20210414181027.17"><vh>function reset</vh></v>
<v t="leo.20210414181027.18"><vh>function pause</vh></v>
<v t="leo.20210414181027.19"><vh>function realTime</vh></v>
<v t="leo.20210414181027.20"><vh>function step</vh></v>
<v t="leo.20210414181027.21"><vh>function requestFullscreen</vh></v>
<v t="leo.20210414181027.22"><vh>function exitFullscreen</vh></v>
<v t="leo.20210414181027.23"><vh>function fullscreenchange</vh></v>
<v t="leo.20210414181027.24"><vh>function toolBarButton</vh></v>
<v t="leo.20210414181027.25"><vh>function toggleConsole</vh></v>
<v t="leo.20210414181027.26"><vh>function toggleHelp</vh></v>
<v t="leo.20210414181027.27"><vh>function enableToolBarButtons</vh></v>
<v t="leo.20210414181027.28"><vh>function initWorld</vh>
<v t="leo.20210414181027.29"><vh>x3dom.Texture.prototype.update = function</vh></v>
<v t="leo.20210414181027.30"><vh>x3dom.debug.doLog = function</vh></v>
</v>
<v t="leo.20210414181027.31"><vh>function toggleInfo</vh></v>
<v t="leo.20210414181027.32"><vh>function initX3Dom</vh>
<v t="leo.20210414181027.33"><vh>script.onerror = function</vh></v>
</v>
<v t="leo.20210414181027.34"><vh>function initX3dFile</vh>
<v t="leo.20210414181027.35"><vh>xmlhttp.onreadystatechange = function</vh></v>
</v>
<v t="leo.20210414181027.36"><vh>function x3domFinalize</vh>
<v t="leo.20210414181027.37"><vh>function loadRobotWindow</vh>
<v t="leo.20210414181027.38"><vh>function closeInfoWindow</vh></v>
<v t="leo.20210414181027.39"><vh>$.get('window/' + windowName + '/' + windowName + '.html', function</vh>
<v t="leo.20210414181027.40"><vh>$.get('window/' + windowName + '/' + windowName + '.js', function</vh></v>
</v>
</v>
</v>
<v t="leo.20210414181027.41"><vh>function loadFinalize</vh></v>
<v t="leo.20210414181027.42"><vh>function rotateViewpoint</vh></v>
<v t="leo.20210414181027.43"><vh>function translateViewpoint</vh></v>
<v t="leo.20210414181027.44"><vh>function zoomAndTiltViewpoint</vh></v>
<v t="leo.20210414181027.45"><vh>function initMouseMove</vh></v>
<v t="leo.20210414181027.46"><vh>function clearMouseMove</vh></v>
<v t="leo.20210414181027.47"><vh>function addX3domMouseNavigation</vh>
<v t="leo.20210414181027.48"><vh>that.x3dNode.addEventListener('touchmove', function</vh></v>
<v t="leo.20210414181027.49"><vh>that.x3dNode.addEventListener('touchstart', function</vh></v>
<v t="leo.20210414181027.50"><vh>that.x3dNode.addEventListener('touchend', function</vh></v>
<v t="leo.20210414181027.51"><vh>that.x3dNode.addEventListener('wheel', function</vh></v>
<v t="leo.20210414181027.52"><vh>that.x3dNode.addEventListener('mousemove', function</vh></v>
<v t="leo.20210414181027.53"><vh>that.x3dNode.addEventListener('mousedown', function</vh></v>
<v t="leo.20210414181027.54"><vh>that.x3dNode.addEventListener('mouseover', function</vh></v>
<v t="leo.20210414181027.55"><vh>that.x3dNode.addEventListener('mouseleave', function</vh></v>
<v t="leo.20210414181027.56"><vh>that.x3dScene.addEventListener('mouseup', function</vh>
<v t="leo.20210414181027.57"><vh>$ function</vh></v>
</v>
</v>
<v t="leo.20210414181027.58"><vh>function wheelTimeoutCallback</vh></v>
<v t="leo.20210414181027.59"><vh>function getTopX3dElement</vh></v>
<v t="leo.20210414181027.60"><vh>function unselect</vh></v>
<v t="leo.20210414181027.61"><vh>function select</vh></v>
<v t="leo.20210414181027.62"><vh>function videoFinalize</vh></v>
<v t="leo.20210414181027.63"><vh>function sendVideoMouseEvent</vh></v>
<v t="leo.20210414181027.64"><vh>function onVideoMouseDown</vh></v>
<v t="leo.20210414181027.65"><vh>function onVideoMouseMove</vh></v>
<v t="leo.20210414181027.66"><vh>function onVideoMouseUp</vh></v>
<v t="leo.20210414181027.67"><vh>function onVideoWheel</vh></v>
<v t="leo.20210414181027.68"><vh>function onVideoContextMenu</vh></v>
<v t="leo.20210414181027.69"><vh>function addVideoMouseNavigation</vh></v>
</v>
<v t="leo.20210414181027.70"><vh>webots.View.prototype.toggleInfo = function</vh></v>
<v t="leo.20210414181027.71"><vh>webots.View.prototype.follow = function</vh></v>
<v t="leo.20210414181027.72"><vh>webots.View.prototype.setViewpointMass = function</vh></v>
<v t="leo.20210414181027.73"><vh>webots.View.prototype.updateViewpointPosition = function</vh></v>
<v t="leo.20210414181027.74"><vh>webots.View.prototype.close = function</vh></v>
<v t="leo.20210414181027.75"><vh>webots.View.prototype.sendRobotMessage = function</vh></v>
<v t="leo.20210414181027.76"><vh>webots.View.prototype.resize = function</vh></v>
<v t="leo.20210414181027.77"><vh>webots.View.prototype.getControllerUrl = function</vh></v>
<v t="leo.20210414181027.78"><vh>webots.View.prototype.setAnimation = function</vh></v>
<v t="leo.20210414181027.79"><vh>webots.View.prototype.applyPose = function</vh></v>
<v t="leo.20210414181027.80"><vh>webots.Animation = function</vh></v>
<v t="leo.20210414181027.81"><vh>webots.Animation.prototype.init = function</vh>
<v t="leo.20210414181027.82"><vh>xmlhttp.onreadystatechange = function</vh></v>
<v t="leo.20210414181027.83"><vh>function setup</vh></v>
<v t="leo.20210414181027.84"><vh>function elapsedTime</vh></v>
<v t="leo.20210414181027.85"><vh>function triggerPlayPauseButton</vh></v>
<v t="leo.20210414181027.86"><vh>function connectSliderEvents</vh></v>
<v t="leo.20210414181027.87"><vh>function disconnectSliderEvents</vh></v>
<v t="leo.20210414181027.88"><vh>function updateSlider</vh></v>
<v t="leo.20210414181027.89"><vh>function updateAnimationState</vh></v>
<v t="leo.20210414181027.90"><vh>function updateAnimation</vh></v>
</v>
<v t="leo.20210414181027.91"><vh>webots.Server = function</vh>
<v t="leo.20210414181027.92"><vh>xhr.onreadystatechange = function</vh>
<v t="leo.20210414181027.93"><vh>that.socket.onopen = function</vh></v>
<v t="leo.20210414181027.94"><vh>that.socket.onclose = function</vh></v>
<v t="leo.20210414181027.95"><vh>that.socket.onmessage = function</vh></v>
<v t="leo.20210414181027.96"><vh>that.socket.onerror = function</vh></v>
</v>
</v>
<v t="leo.20210414181027.97"><vh>webots.Server.prototype.resetController = function</vh></v>
<v t="leo.20210414181027.98"><vh>webots.Stream = function</vh>
<v t="leo.20210414181027.99"><vh>this.socket.onopen = function</vh></v>
<v t="leo.20210414181027.100"><vh>this.socket.onclose = function</vh></v>
<v t="leo.20210414181027.101"><vh>this.socket.onmessage = function</vh></v>
<v t="leo.20210414181027.102"><vh>this.socket.onerror = function</vh></v>
<v t="leo.20210414181027.103"><vh>function destroyWorld</vh></v>
</v>
<v t="leo.20210414181027.104"><vh>webots.Stream.prototype.compareTextureUrl = function</vh></v>
<v t="leo.20210414181027.105"><vh>webots.Stream.prototype.close = function</vh></v>
<v t="leo.20210414181027.106"><vh>function webotsClampDialogSize</vh></v>
<v t="leo.20210414181027.107"><vh>function webotsResizeDialogOnOpen</vh></v>
<v t="leo.20210414181027.108"><vh>function webotsOpenDialog</vh>
<v t="leo.20210414181027.109"><vh>$(this).parent().hover function</vh></v>
</v>
<v t="leo.20210414181027.110"><vh>function webotsMobileCreateDialog</vh></v>
<v t="leo.20210414181027.111"><vh>function webotsAddMobileDialogAttributes</vh></v>
<v t="leo.20210414181027.112"><vh>function webotsDisablePointerEvents</vh></v>
<v t="leo.20210414181027.113"><vh>function webotsEnablePointerEvents</vh></v>
<v t="leo.20210414181027.114"><vh>webots.Editor = function</vh>
<v t="leo.20210414181027.115"><vh>function webotsEditorResize</vh></v>
<v t="leo.20210414181027.116"><vh>function hideMenu</vh></v>
<v t="leo.20210414181027.117"><vh>function openResetConfirmDialog</vh></v>
<v t="leo.20210414181027.118"><vh>$('#webotsEditorSaveAction').click function</vh></v>
<v t="leo.20210414181027.119"><vh>$('#webotsEditorSaveAllAction').click function</vh></v>
<v t="leo.20210414181027.120"><vh>$('#webotsEditorResetAction').click function</vh></v>
<v t="leo.20210414181027.121"><vh>$('#webotsEditorResetAllAction').click function</vh></v>
<v t="leo.20210414181027.122"><vh>$('#webotsEditorMenuImage').click function</vh></v>
<v t="leo.20210414181027.123"><vh>$('#webotsEditorMenu').focusout function</vh>
<v t="leo.20210414181027.124"><vh>window.setTimeout function</vh></v>
</v>
</v>
<v t="leo.20210414181027.125"><vh>webots.Editor.prototype.hasUnsavedChanges = function</vh></v>
<v t="leo.20210414181027.126"><vh>webots.Editor.prototype.storeUserFile = function</vh></v>
<v t="leo.20210414181027.127"><vh>webots.Editor.prototype.upload = function</vh></v>
<v t="leo.20210414181027.128"><vh>webots.Editor.prototype.save = function</vh></v>
<v t="leo.20210414181027.129"><vh>webots.Editor.prototype.hideResetMessage = function</vh></v>
<v t="leo.20210414181027.130"><vh>webots.Editor.prototype.textChange = function</vh></v>
<v t="leo.20210414181027.131"><vh>webots.Editor.prototype.aceMode = function</vh></v>
<v t="leo.20210414181027.132"><vh>webots.Editor.prototype.addFile = function</vh></v>
<v t="leo.20210414181027.133"><vh>webots.Editor.prototype.closeAllTabs = function</vh></v>
<v t="leo.20210414181027.134"><vh>webots.Console = function</vh>
<v t="leo.20210414181027.135"><vh>function closeConsole</vh></v>
</v>
<v t="leo.20210414181027.136"><vh>webots.Console.prototype.scrollDown = function</vh></v>
<v t="leo.20210414181027.137"><vh>webots.Console.prototype.clear = function</vh></v>
<v t="leo.20210414181027.138"><vh>webots.Console.prototype.log = function</vh>
<v t="leo.20210414181027.139"><vh>function hourString</vh></v>
</v>
<v t="leo.20210414181027.140"><vh>webots.Console.prototype.stdout = function</vh></v>
<v t="leo.20210414181027.141"><vh>webots.Console.prototype.stderr = function</vh></v>
<v t="leo.20210414181027.142"><vh>webots.Console.prototype.info = function</vh></v>
<v t="leo.20210414181027.143"><vh>webots.Console.prototype.error = function</vh></v>
<v t="leo.20210414181027.144"><vh>webots.HelpWindow = function</vh>
<v t="leo.20210414181027.145"><vh>function closeConsole</vh></v>
<v t="leo.20210414181027.146"><vh>function finalize</vh></v>
</v>
<v t="leo.20210414181027.147"><vh>webots.RobotWindow = function</vh></v>
<v t="leo.20210414181027.148"><vh>webots.RobotWindow.prototype.setProperties = function</vh></v>
<v t="leo.20210414181027.149"><vh>webots.RobotWindow.prototype.geometry = function</vh></v>
<v t="leo.20210414181027.150"><vh>webots.RobotWindow.prototype.restoreGeometry = function</vh></v>
<v t="leo.20210414181027.151"><vh>webots.RobotWindow.prototype.destroy = function</vh></v>
<v t="leo.20210414181027.152"><vh>webots.RobotWindow.prototype.setContent = function</vh></v>
<v t="leo.20210414181027.153"><vh>webots.RobotWindow.prototype.open = function</vh></v>
<v t="leo.20210414181027.154"><vh>webots.RobotWindow.prototype.isOpen = function</vh></v>
<v t="leo.20210414181027.155"><vh>webots.RobotWindow.prototype.close = function</vh></v>
<v t="leo.20210414181027.156"><vh>webots.RobotWindow.prototype.send = function</vh></v>
<v t="leo.20210414181027.157"><vh>webots.RobotWindow.prototype.receive = function</vh></v>
<v t="leo.20210414181027.158"><vh>webots.window = function</vh></v>
<v t="leo.20210414181027.159"><vh>webots.alert = function</vh></v>
<v t="leo.20210414181027.160"><vh>webots.confirm = function</vh></v>
<v t="leo.20210414181027.161"><vh>webots.parseMillisecondsIntoReadableTime = function</vh></v>
<v t="leo.20210414181027.162"><vh>webots.currentScriptPath = function</vh></v>
<v t="leo.20210414181027.163"><vh>String.prototype.startsWith = function</vh></v>
<v t="leo.20210414181027.164"><vh>String.prototype.endsWith = function</vh></v>
</v>
</v>
<v t="leo.20210414181031.1"><vh>@path old\wwi\R2019a</vh>
<v t="leo.20210414181045.1"><vh>@clean webots.js</vh>
<v t="leo.20210414181059.1"><vh>webots.View = function</vh>
<v t="leo.20210414181059.2"><vh>this.onerror = function</vh></v>
<v t="leo.20210414181059.3"><vh>this.onstdout = function</vh></v>
<v t="leo.20210414181059.4"><vh>this.onstderr = function</vh></v>
<v t="leo.20210414181059.5"><vh>this.onrobotmessage = function</vh></v>
<v t="leo.20210414181059.6"><vh>this.onrobotwindowsdestroy = function</vh></v>
<v t="leo.20210414181059.7"><vh>this.onquit = function</vh></v>
<v t="leo.20210414181059.8"><vh>this.onresize = function</vh></v>
<v t="leo.20210414181059.9"><vh>this.ondialogwindow = function</vh></v>
<v t="leo.20210414181059.10"><vh>$(document).bind('keydown keypress', function</vh></v>
<v t="leo.20210414181059.11"><vh>$('#contextMenu').on('menuselect', function</vh></v>
</v>
<v t="leo.20210414181059.12"><vh>webots.View.prototype.setTimeout = function</vh></v>
<v t="leo.20210414181059.13"><vh>webots.View.prototype.setWebotsDocUrl = function</vh></v>
<v t="leo.20210414181059.14"><vh>webots.View.prototype.open = function</vh>
<v t="leo.20210414181059.15"><vh>function requestQuit</vh></v>
<v t="leo.20210414181059.16"><vh>function quit</vh></v>
<v t="leo.20210414181059.17"><vh>function reset</vh></v>
<v t="leo.20210414181059.18"><vh>function pause</vh></v>
<v t="leo.20210414181059.19"><vh>function realTime</vh></v>
<v t="leo.20210414181059.20"><vh>function step</vh></v>
<v t="leo.20210414181059.21"><vh>function requestFullscreen</vh></v>
<v t="leo.20210414181059.22"><vh>function exitFullscreen</vh></v>
<v t="leo.20210414181059.23"><vh>function fullscreenchange</vh></v>
<v t="leo.20210414181059.24"><vh>function toolBarButton</vh></v>
<v t="leo.20210414181059.25"><vh>function toggleConsole</vh></v>
<v t="leo.20210414181059.26"><vh>function toggleHelp</vh></v>
<v t="leo.20210414181059.27"><vh>function enableToolBarButtons</vh></v>
<v t="leo.20210414181059.28"><vh>function initWorld</vh>
<v t="leo.20210414181059.29"><vh>x3dom.Texture.prototype.update = function</vh></v>
<v t="leo.20210414181059.30"><vh>x3dom.debug.doLog = function</vh></v>
</v>
<v t="leo.20210414181059.31"><vh>function toggleInfo</vh></v>
<v t="leo.20210414181059.32"><vh>function initX3Dom</vh>
<v t="leo.20210414181059.33"><vh>script.onerror = function</vh></v>
</v>
<v t="leo.20210414181059.34"><vh>function initX3dFile</vh>
<v t="leo.20210414181059.35"><vh>xmlhttp.onreadystatechange = function</vh></v>
</v>
<v t="leo.20210414181059.36"><vh>function x3domFinalize</vh>
<v t="leo.20210414181059.37"><vh>function loadRobotWindow</vh>
<v t="leo.20210414181059.38"><vh>function closeInfoWindow</vh></v>
<v t="leo.20210414181059.39"><vh>$.get('window/' + windowName + '/' + windowName + '.html', function</vh>
<v t="leo.20210414181059.40"><vh>$.get('window/' + windowName + '/' + windowName + '.js', function</vh></v>
</v>
</v>
</v>
<v t="leo.20210414181059.41"><vh>function loadFinalize</vh></v>
<v t="leo.20210414181059.42"><vh>function rotateViewpoint</vh></v>
<v t="leo.20210414181059.43"><vh>function translateViewpoint</vh></v>
<v t="leo.20210414181059.44"><vh>function zoomAndTiltViewpoint</vh></v>
<v t="leo.20210414181059.45"><vh>function initMouseMove</vh></v>
<v t="leo.20210414181059.46"><vh>function clearMouseMove</vh></v>
<v t="leo.20210414181059.47"><vh>function addX3domMouseNavigation</vh>
<v t="leo.20210414181059.48"><vh>that.x3dNode.addEventListener('touchmove', function</vh></v>
<v t="leo.20210414181059.49"><vh>that.x3dNode.addEventListener('touchstart', function</vh></v>
<v t="leo.20210414181059.50"><vh>that.x3dNode.addEventListener('touchend', function</vh></v>
<v t="leo.20210414181059.51"><vh>that.x3dNode.addEventListener('wheel', function</vh></v>
<v t="leo.20210414181059.52"><vh>that.x3dNode.addEventListener('mousemove', function</vh></v>
<v t="leo.20210414181059.53"><vh>that.x3dNode.addEventListener('mousedown', function</vh></v>
<v t="leo.20210414181059.54"><vh>that.x3dNode.addEventListener('mouseover', function</vh></v>
<v t="leo.20210414181059.55"><vh>that.x3dNode.addEventListener('mouseleave', function</vh></v>
<v t="leo.20210414181059.56"><vh>that.x3dScene.addEventListener('mouseup', function</vh>
<v t="leo.20210414181059.57"><vh>$ function</vh></v>
</v>
</v>
<v t="leo.20210414181059.58"><vh>function wheelTimeoutCallback</vh></v>
<v t="leo.20210414181059.59"><vh>function getTopX3dElement</vh></v>
<v t="leo.20210414181059.60"><vh>function unselect</vh></v>
<v t="leo.20210414181059.61"><vh>function select</vh></v>
<v t="leo.20210414181059.62"><vh>function videoFinalize</vh></v>
<v t="leo.20210414181059.63"><vh>function sendVideoMouseEvent</vh></v>
<v t="leo.20210414181059.64"><vh>function onVideoMouseDown</vh></v>
<v t="leo.20210414181059.65"><vh>function onVideoMouseMove</vh></v>
<v t="leo.20210414181059.66"><vh>function onVideoMouseUp</vh></v>
<v t="leo.20210414181059.67"><vh>function onVideoWheel</vh></v>
<v t="leo.20210414181059.68"><vh>function onVideoContextMenu</vh></v>
<v t="leo.20210414181059.69"><vh>function addVideoMouseNavigation</vh></v>
</v>
<v t="leo.20210414181059.70"><vh>webots.View.prototype.toggleInfo = function</vh></v>
<v t="leo.20210414181059.71"><vh>webots.View.prototype.follow = function</vh></v>
<v t="leo.20210414181059.72"><vh>webots.View.prototype.setViewpointMass = function</vh></v>
<v t="leo.20210414181059.73"><vh>webots.View.prototype.updateViewpointPosition = function</vh></v>
<v t="leo.20210414181059.74"><vh>webots.View.prototype.close = function</vh></v>
<v t="leo.20210414181059.75"><vh>webots.View.prototype.sendRobotMessage = function</vh></v>
<v t="leo.20210414181059.76"><vh>webots.View.prototype.resize = function</vh></v>
<v t="leo.20210414181059.77"><vh>webots.View.prototype.getControllerUrl = function</vh></v>
<v t="leo.20210414181059.78"><vh>webots.View.prototype.setAnimation = function</vh></v>
<v t="leo.20210414181059.79"><vh>webots.View.prototype.applyPose = function</vh></v>
<v t="leo.20210414181059.80"><vh>webots.Animation = function</vh></v>
<v t="leo.20210414181059.81"><vh>webots.Animation.prototype.init = function</vh>
<v t="leo.20210414181059.82"><vh>xmlhttp.onreadystatechange = function</vh></v>
<v t="leo.20210414181059.83"><vh>function setup</vh></v>
<v t="leo.20210414181059.84"><vh>function elapsedTime</vh></v>
<v t="leo.20210414181059.85"><vh>function triggerPlayPauseButton</vh></v>
<v t="leo.20210414181059.86"><vh>function connectSliderEvents</vh></v>
<v t="leo.20210414181059.87"><vh>function disconnectSliderEvents</vh></v>
<v t="leo.20210414181059.88"><vh>function updateSlider</vh></v>
<v t="leo.20210414181059.89"><vh>function updateAnimationState</vh></v>
<v t="leo.20210414181059.90"><vh>function updateAnimation</vh></v>
</v>
<v t="leo.20210414181059.91"><vh>webots.Server = function</vh>
<v t="leo.20210414181059.92"><vh>xhr.onreadystatechange = function</vh>
<v t="leo.20210414181059.93"><vh>that.socket.onopen = function</vh></v>
<v t="leo.20210414181059.94"><vh>that.socket.onclose = function</vh></v>
<v t="leo.20210414181059.95"><vh>that.socket.onmessage = function</vh></v>
<v t="leo.20210414181059.96"><vh>that.socket.onerror = function</vh></v>
</v>
</v>
<v t="leo.20210414181059.97"><vh>webots.Server.prototype.resetController = function</vh></v>
<v t="leo.20210414181059.98"><vh>webots.Stream = function</vh>
<v t="leo.20210414181059.99"><vh>this.socket.onopen = function</vh></v>
<v t="leo.20210414181059.100"><vh>this.socket.onclose = function</vh></v>
<v t="leo.20210414181059.101"><vh>this.socket.onmessage = function</vh></v>
<v t="leo.20210414181059.102"><vh>this.socket.onerror = function</vh></v>
<v t="leo.20210414181059.103"><vh>function destroyWorld</vh></v>
</v>
<v t="leo.20210414181059.104"><vh>webots.Stream.prototype.compareTextureUrl = function</vh></v>
<v t="leo.20210414181059.105"><vh>webots.Stream.prototype.close = function</vh></v>
<v t="leo.20210414181059.106"><vh>function webotsClampDialogSize</vh></v>
<v t="leo.20210414181059.107"><vh>function webotsResizeDialogOnOpen</vh></v>
<v t="leo.20210414181059.108"><vh>function webotsOpenDialog</vh>
<v t="leo.20210414181059.109"><vh>$(this).parent().hover function</vh></v>
</v>
<v t="leo.20210414181059.110"><vh>function webotsMobileCreateDialog</vh></v>
<v t="leo.20210414181059.111"><vh>function webotsAddMobileDialogAttributes</vh></v>
<v t="leo.20210414181059.112"><vh>function webotsDisablePointerEvents</vh></v>
<v t="leo.20210414181059.113"><vh>function webotsEnablePointerEvents</vh></v>
<v t="leo.20210414181059.114"><vh>webots.Editor = function</vh>
<v t="leo.20210414181059.115"><vh>function webotsEditorResize</vh></v>
<v t="leo.20210414181059.116"><vh>function hideMenu</vh></v>
<v t="leo.20210414181059.117"><vh>function openResetConfirmDialog</vh></v>
<v t="leo.20210414181059.118"><vh>$('#webotsEditorSaveAction').click function</vh></v>
<v t="leo.20210414181059.119"><vh>$('#webotsEditorSaveAllAction').click function</vh></v>
<v t="leo.20210414181059.120"><vh>$('#webotsEditorResetAction').click function</vh></v>
<v t="leo.20210414181059.121"><vh>$('#webotsEditorResetAllAction').click function</vh></v>
<v t="leo.20210414181059.122"><vh>$('#webotsEditorMenuImage').click function</vh></v>
<v t="leo.20210414181059.123"><vh>$('#webotsEditorMenu').focusout function</vh>
<v t="leo.20210414181059.124"><vh>window.setTimeout function</vh></v>
</v>
</v>
<v t="leo.20210414181059.125"><vh>webots.Editor.prototype.hasUnsavedChanges = function</vh></v>
<v t="leo.20210414181059.126"><vh>webots.Editor.prototype.storeUserFile = function</vh></v>
<v t="leo.20210414181059.127"><vh>webots.Editor.prototype.upload = function</vh></v>
<v t="leo.20210414181059.128"><vh>webots.Editor.prototype.save = function</vh></v>
<v t="leo.20210414181059.129"><vh>webots.Editor.prototype.hideResetMessage = function</vh></v>
<v t="leo.20210414181059.130"><vh>webots.Editor.prototype.textChange = function</vh></v>
<v t="leo.20210414181059.131"><vh>webots.Editor.prototype.aceMode = function</vh></v>
<v t="leo.20210414181059.132"><vh>webots.Editor.prototype.addFile = function</vh></v>
<v t="leo.20210414181059.133"><vh>webots.Editor.prototype.closeAllTabs = function</vh></v>
<v t="leo.20210414181059.134"><vh>webots.Console = function</vh>
<v t="leo.20210414181059.135"><vh>function closeConsole</vh></v>
</v>
<v t="leo.20210414181059.136"><vh>webots.Console.prototype.scrollDown = function</vh></v>
<v t="leo.20210414181059.137"><vh>webots.Console.prototype.clear = function</vh></v>
<v t="leo.20210414181059.138"><vh>webots.Console.prototype.log = function</vh>
<v t="leo.20210414181059.139"><vh>function hourString</vh></v>
</v>
<v t="leo.20210414181059.140"><vh>webots.Console.prototype.stdout = function</vh></v>
<v t="leo.20210414181059.141"><vh>webots.Console.prototype.stderr = function</vh></v>
<v t="leo.20210414181059.142"><vh>webots.Console.prototype.info = function</vh></v>
<v t="leo.20210414181059.143"><vh>webots.Console.prototype.error = function</vh></v>
<v t="leo.20210414181059.144"><vh>webots.HelpWindow = function</vh>
<v t="leo.20210414181059.145"><vh>function closeConsole</vh></v>
<v t="leo.20210414181059.146"><vh>function finalize</vh></v>
</v>
<v t="leo.20210414181059.147"><vh>webots.RobotWindow = function</vh></v>
<v t="leo.20210414181059.148"><vh>webots.RobotWindow.prototype.setProperties = function</vh></v>
<v t="leo.20210414181059.149"><vh>webots.RobotWindow.prototype.geometry = function</vh></v>
<v t="leo.20210414181059.150"><vh>webots.RobotWindow.prototype.restoreGeometry = function</vh></v>
<v t="leo.20210414181059.151"><vh>webots.RobotWindow.prototype.destroy = function</vh></v>
<v t="leo.20210414181059.152"><vh>webots.RobotWindow.prototype.setContent = function</vh></v>
<v t="leo.20210414181059.153"><vh>webots.RobotWindow.prototype.open = function</vh></v>
<v t="leo.20210414181059.154"><vh>webots.RobotWindow.prototype.isOpen = function</vh></v>
<v t="leo.20210414181059.155"><vh>webots.RobotWindow.prototype.close = function</vh></v>
<v t="leo.20210414181059.156"><vh>webots.RobotWindow.prototype.send = function</vh></v>
<v t="leo.20210414181059.157"><vh>webots.RobotWindow.prototype.receive = function</vh></v>
<v t="leo.20210414181059.158"><vh>webots.window = function</vh></v>
<v t="leo.20210414181059.159"><vh>webots.alert = function</vh></v>
<v t="leo.20210414181059.160"><vh>webots.confirm = function</vh></v>
<v t="leo.20210414181059.161"><vh>webots.parseMillisecondsIntoReadableTime = function</vh></v>
<v t="leo.20210414181059.162"><vh>webots.currentScriptPath = function</vh></v>
<v t="leo.20210414181059.163"><vh>String.prototype.startsWith = function</vh></v>
<v t="leo.20210414181059.164"><vh>String.prototype.endsWith = function</vh></v>
</v>
</v>
<v t="leo.20210414171731.1"><vh>@path css</vh>
<v t="leo.20210414171717.1"><vh>@edit webots-doc.css</vh></v>
<v t="leo.20210414173830.1"><vh>@edit main.css</vh></v>
</v>
<v t="leo.20210414173734.1"><vh>@path dependencies/wwi/R2021a/</vh>
<v t="leo.20210414173748.1"><vh>@edit wwi.css</vh></v>
</v>
<v t="leo.20210414171833.1"><vh>@path js</vh>
<v t="leo.20210414171912.1"><vh>@clean viewer.js</vh>
<v t="leo.20210414171924.1"><vh>String.prototype.startsWith = function</vh></v>
<v t="leo.20210414171924.2"><vh>String.prototype.endsWith = function</vh></v>
<v t="leo.20210414171924.3"><vh>function isInternetExplorer</vh></v>
<v t="leo.20210414171924.4"><vh>function setupCyberboticsUrl</vh></v>
<v t="leo.20210414171924.5"><vh>function setupDefaultUrl</vh></v>
<v t="leo.20210414171924.6"><vh>function setupUrl</vh></v>
<v t="leo.20210414171924.7"><vh>function computeTargetPath</vh></v>
<v t="leo.20210414171924.8"><vh>function redirectUrls</vh></v>
<v t="leo.20210414171924.9"><vh>function collapseMovies</vh></v>
<v t="leo.20210414171924.10"><vh>function forgeUrl</vh></v>
<v t="leo.20210414171924.11"><vh>function addDynamicAnchorEvent</vh>
<v t="leo.20210414171924.12"><vh>function</vh></v>
</v>
<v t="leo.20210414171924.13"><vh>function addDynamicLoadEvent</vh>
<v t="leo.20210414171924.14"><vh>function</vh></v>
</v>
<v t="leo.20210414171924.15"><vh>function aClick</vh></v>
<v t="leo.20210414171924.16"><vh>function redirectImages</vh></v>
<v t="leo.20210414171924.17"><vh>function setupModalWindow</vh>
<v t="leo.20210414171924.18"><vh>close.onclick = function</vh></v>
<v t="leo.20210414171924.19"><vh>window.onclick = function</vh></v>
</v>
<v t="leo.20210414171924.20"><vh>function updateModalEvents</vh>
<v t="leo.20210414171924.21"><vh>imgs[i].onclick = function</vh>
<v t="leo.20210414171924.22"><vh>image.onload = function</vh></v>
<v t="leo.20210414171924.23"><vh>image.onerror = function</vh>
<v t="leo.20210414171924.24"><vh>image.onerror = function</vh></v>
</v>
</v>
</v>
<v t="leo.20210414171924.25"><vh>function applyAnchor</vh></v>
<v t="leo.20210414171924.26"><vh>function applyToTitleDiv</vh></v>
<v t="leo.20210414171924.27"><vh>function addContributionBanner</vh>
<v t="leo.20210414171924.28"><vh>document.querySelector('#contribution-close').onclick = function</vh></v>
</v>
<v t="leo.20210414171924.29"><vh>function updateContributionBannerUrl</vh></v>
<v t="leo.20210414171924.30"><vh>function addNavigationToBlogIfNeeded</vh></v>
<v t="leo.20210414171924.31"><vh>function setupBlogFunctionalitiesIfNeeded</vh></v>
<v t="leo.20210414171924.32"><vh>function createIndex</vh>
<v t="leo.20210414171924.33"><vh>headings.forEach function</vh></v>
</v>
<v t="leo.20210414171924.34"><vh>function getWebotsVersion</vh></v>
<v t="leo.20210414171924.35"><vh>function applyToPageTitle</vh></v>
<v t="leo.20210414171924.36"><vh>function populateViewDiv</vh></v>
<v t="leo.20210414171924.37"><vh>function updateBrowserUrl</vh></v>
<v t="leo.20210414171924.38"><vh>window.onpopstate = function</vh></v>
<v t="leo.20210414171924.39"><vh>function highlightCode</vh></v>
<v t="leo.20210414171924.40"><vh>function resetRobotComponent</vh></v>
<v t="leo.20210414171924.41"><vh>function updateRobotComponentDimension</vh></v>
<v t="leo.20210414171924.42"><vh>function toggleDeviceComponent</vh></v>
<v t="leo.20210414171924.43"><vh>function toogleRobotComponentFullScreen</vh>
<v t="leo.20210414171924.44"><vh>document.addEventListener('fullscreenchange', function</vh></v>
<v t="leo.20210414171924.45"><vh>document.addEventListener('mozfullscreenchange', function</vh></v>
<v t="leo.20210414171924.46"><vh>document.addEventListener('webkitfullscreenchange', function</vh></v>
<v t="leo.20210414171924.47"><vh>document.addEventListener('msfullscreenchange', function</vh></v>
</v>
<v t="leo.20210414171924.48"><vh>function sliderMotorCallback</vh></v>
<v t="leo.20210414171924.49"><vh>function unhighlightX3DElement</vh></v>
<v t="leo.20210414171924.50"><vh>function highlightX3DElement</vh>
<v t="leo.20210414171924.51"><vh>object.traverse function</vh></v>
</v>
<v t="leo.20210414171924.52"><vh>function setBillboardSize</vh>
<v t="leo.20210414171924.53"><vh>scene.traverse function</vh></v>
</v>
<v t="leo.20210414171924.54"><vh>function getRobotComponentByRobotName</vh></v>
<v t="leo.20210414171924.55"><vh>function createRobotComponent</vh>
<v t="leo.20210414171924.56"><vh>webotsView.onready = function</vh>
<v t="leo.20210414171924.57"><vh>webotsView.x3dScene.preRender = function</vh></v>
</v>
<v t="leo.20210414171924.58"><vh>slider.addEventListener(isInternetExplorer() ? 'change' : 'input', function</vh></v>
</v>
<v t="leo.20210414171924.59"><vh>function openTabFromEvent</vh></v>
<v t="leo.20210414171924.60"><vh>function openTab</vh></v>
<v t="leo.20210414171924.61"><vh>function applyTabs</vh></v>
<v t="leo.20210414171924.62"><vh>function renderGraphs</vh>
<v t="leo.20210414171924.63"><vh>window.mermaidAPI.render(id, window.mermaidGraphs[id], function</vh></v>
</v>
<v t="leo.20210414171924.64"><vh>function applyAnchorIcons</vh></v>
<v t="leo.20210414171924.65"><vh>function receiveMenuContent</vh></v>
<v t="leo.20210414171924.66"><vh>function updateMenuScrollbar</vh></v>
<v t="leo.20210414171924.67"><vh>function updateSelection</vh></v>
<v t="leo.20210414171924.68"><vh>function changeMenuSelection</vh></v>
<v t="leo.20210414171924.69"><vh>function populateNavigation</vh></v>
<v t="leo.20210414171924.70"><vh>function populateMenu</vh>
<v t="leo.20210414171924.71"><vh>function</vh></v>
<v t="leo.20210414171924.72"><vh>$('#accordion &gt; li &gt; a').click function</vh></v>
</v>
<v t="leo.20210414171924.73"><vh>function showAccodionItem</vh></v>
<v t="leo.20210414171924.74"><vh>function getMDFile</vh></v>
<v t="leo.20210414171924.75"><vh>function getMenuFile</vh></v>
<v t="leo.20210414171924.76"><vh>function extractAnchor</vh></v>
<v t="leo.20210414171924.77"><vh>function setHandleWidth</vh></v>
<v t="leo.20210414171924.78"><vh>function initializeHandle</vh>
<v t="leo.20210414171924.79"><vh>handle.handle.on('mousedown touchstart', function</vh></v>
<v t="leo.20210414171924.80"><vh>$(document).on('mousemove touchmove', function</vh></v>
</v>
<v t="leo.20210414171924.81"><vh>window.onscroll = function</vh></v>
<v t="leo.20210414171924.82"><vh>document.addEventListener('DOMContentLoaded', function</vh></v>
</v>
<v t="leo.20210414171942.1"><vh>@clean showdown-extensions.js</vh>
<v t="leo.20210414171955.1"><vh>function wbSlugify</vh></v>
<v t="leo.20210414171955.2"><vh>showdown.extension('wbVariables', function</vh></v>
<v t="leo.20210414171955.3"><vh>showdown.extension('wbFigure', function</vh>
<v t="leo.20210414171955.4"><vh>text = text.replace(/%figure\s+"([^]+?)"([^]+?)%end/gi, function</vh></v>
<v t="leo.20210414171955.5"><vh>text = text.replace(/%figure\s+([^"][^]+?)%end/gi, function</vh></v>
</v>
<v t="leo.20210414171955.6"><vh>showdown.extension('wbAPI', function</vh>
<v t="leo.20210414171955.7"><vh>text = text.replace(/%api\s+"([^]+?)"([^]+?)%end/gi, function</vh></v>
<v t="leo.20210414171955.8"><vh>text = text.replace(/(#{4,5}) `([^`\n]+?)`\n/gi, function</vh></v>
</v>
<v t="leo.20210414171955.9"><vh>showdown.extension('wbAnchors', function</vh></v>
<v t="leo.20210414171955.10"><vh>showdown.extension('wbIllustratedSection', function</vh>
<v t="leo.20210414171955.11"><vh>text = text.replace(/\n(!\[[^\]]*\]\s*\([^)]*\)) +([^]+?)(?=\n\n)/gi, function</vh></v>
</v>
<v t="leo.20210414171955.12"><vh>showdown.extension('wbChart', function</vh>
<v t="leo.20210414171955.13"><vh>text = text.replace(/%chart\s+([^"][^]+?)%end/gi, function</vh>
<v t="leo.20210414171955.14"><vh>content = content.replace(/\[\[(.+?)\]\((.+?)\)/gi, function</vh></v>
<v t="leo.20210414171955.15"><vh>content = content.replace(/\[(.+?)\]\((.+?)\)/gi, function</vh></v>
</v>
</v>
<v t="leo.20210414171955.16"><vh>showdown.extension('wbSpoiler', function</vh>
<v t="leo.20210414171955.17"><vh>text = text.replace(/%spoiler\s*\"(.*)\"\n(^(?:(?!%end).+\n*)*\n)*\n%end/gim, function</vh></v>
</v>
<v t="leo.20210414171955.18"><vh>showdown.extension('wbRobotComponent', function</vh>
<v t="leo.20210414171955.19"><vh>text = text.replace(/%robot\s+([^ \n]+)\s+([^ \n]+)/gi, function</vh></v>
</v>
<v t="leo.20210414171955.20"><vh>showdown.extension('wbTabComponent', function</vh>
<v t="leo.20210414171955.21"><vh>text = text.replace(/%tab-component\s+"([^]+?)"([^]+?)%end/gi, function</vh>
<v t="leo.20210414171955.22"><vh>var subText = content.replace(/%tab\s+"([^]+?)"([^]+?)%tab-end/gi, function</vh></v>
</v>
</v>
</v>
<v t="leo.20210414172500.1"><vh>@edit showdown-extensions.js</vh></v>
</v>
<v t="leo.20210414172143.1"><vh>@path guide</vh>
<v t="leo.20210414172153.1"><vh>@clean ure.md</vh>
<v t="leo.20210414172209.1"><vh>INSERTED NODE</vh></v>
<v t="leo.20210414172209.2"><vh>Universal Robots UR3e, UR5e and UR10e</vh>
<v t="leo.20210414172209.3"><vh>Movie Presentation</vh></v>
<v t="leo.20210414172209.4"><vh>UR3e, UR5e and UR10e PROTO</vh>
<v t="leo.20210414172209.5"><vh>Field Summary</vh></v>
</v>
<v t="leo.20210414172209.6"><vh>Samples</vh>
<v t="leo.20210414172209.7"><vh>[ure.wbt](https://github.com/cyberbotics/webots/tree/master/projects/robots/universal_robots/worlds/ure.wbt)</vh></v>
</v>
<v t="leo.20210414172209.8"><vh>ROS</vh>
<v t="leo.20210414172209.9"><vh>MoveIt!</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20210414171731.1"></t>
<t tx="leo.20210414171833.1"></t>
<t tx="leo.20210414171912.1">/* eslint no-extend-native: ["error", { "exceptions": ["String"] }] */
/* global getGETQueryValue */
/* global getGETQueriesMatchingRegularExpression */
/* global setup */
/* global showdown */
/* global hljs */
/* global THREE */
/* global webots */
/* exported resetRobotComponent */
/* exported toggleDeviceComponent */
/* exported highlightX3DElement */
/* exported openTabFromEvent */

'use strict';

var handle;

if (typeof String.prototype.startsWith !== 'function') {
  @others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20210414171924.1">  String.prototype.startsWith = function(prefix) {
    return this.slice(0, prefix.length) === prefix;
  };
}

if (typeof String.prototype.endsWith !== 'function') {
</t>
<t tx="leo.20210414171924.10">function forgeUrl(book, page, tabs, anchor) {
  var tabOption;
  var isFirstArgument;
  var anchorString = (anchor &amp;&amp; anchor.length &gt; 0) ? ('#' + anchor) : '';
  var url = location.href;
  if (isCyberboticsUrl) {
    var i = location.href.indexOf('cyberbotics.com/doc');
    url = location.href.substr(0, i) + 'cyberbotics.com/doc/' + book + '/' + page;
    if (localSetup.branch !== '' &amp;&amp; localSetup.repository &amp;&amp; localSetup.repository !== 'cyberbotics')
      url += '?version=' + localSetup.repository + ':' + localSetup.branch;
    else if (localSetup.branch !== '')
      url += '?version=' + localSetup.branch;
    isFirstArgument = localSetup.branch === '';
    for (tabOption in tabs) {
      if (!tabs[tabOption])
        continue;
      url += (isFirstArgument ? '?' : '&amp;') + tabOption + '=' + tabs[tabOption];
      isFirstArgument = false;
    }
    url += anchorString;
  } else {
    isFirstArgument = (url.indexOf('?') &lt; 0);

    // Remove anchor from url
    url = url.split('#')[0];

    // Add or replace the book argument.
    if (url.indexOf('book=') &gt; -1)
      url = url.replace(/book=([^&amp;]+)?/, 'book=' + book);
    else
      url += (isFirstArgument ? '?' : '&amp;') + 'book=' + book;

    // Add or replace the page argument.
    if (url.indexOf('page=') &gt; -1)
      url = url.replace(/page=([\w-]+)?/, 'page=' + page);
    else
      url += '&amp;page=' + page;

    // Add or replace the tab argument.
    for (tabOption in tabs) {
      let tabName = tabs[tabOption] ? tabs[tabOption] : '';
      if (url.indexOf(tabOption + '=') &gt; -1)
        url = url.replace(new RegExp(tabOption + '=([^&amp;]+)(#[\\w-]+)?'), tabOption + '=' + tabName);
      else if (tabName)
        url += '&amp;' + tabOption + '=' + tabName;
    }

    url += anchorString;
  }
  return url;
}

</t>
<t tx="leo.20210414171924.11">function addDynamicAnchorEvent(el) {
  if (el.classList.contains('dynamicAnchor'))
    return;
  el.addEventListener('click',
    function(event) {
      if (event.ctrlKey)
        return;
      var node = event.target;
      while (node &amp;&amp; !node.hasAttribute('href'))
        node = node.getParent();
      if (node) {
        localSetup.anchor = extractAnchor(node.getAttribute('href'));
        applyAnchor();
        event.preventDefault();
      }
    },
    false
  );
  el.classList.add('dynamicAnchor');
}

</t>
<t tx="leo.20210414171924.12"></t>
<t tx="leo.20210414171924.13">function addDynamicLoadEvent(el) {
  if (el.classList.contains('dynamicLoad'))
    return;
  el.addEventListener('click',
    function(event) {
      if (event.ctrlKey)
        return;
      aClick(event.target);
      event.preventDefault();
    },
    false
  );
  el.classList.add('dynamicLoad');
}

</t>
<t tx="leo.20210414171924.14"></t>
<t tx="leo.20210414171924.15">function aClick(el) {
  setupUrl(el.getAttribute('href'));
  getMDFile();
  updateBrowserUrl();
  updateContributionBannerUrl();
}

</t>
<t tx="leo.20210414171924.16">function redirectImages(node) {
  // redirect img's src
  var imgs = node.querySelectorAll('img');
  var targetPath = computeTargetPath();
  for (var i = 0; i &lt; imgs.length; i++) {
    var img = imgs[i];
    var src = img.getAttribute('src');
    var match = /^images\/(.*)$/.exec(src);
    if (match &amp;&amp; match.length === 2)
      img.setAttribute('src', targetPath + 'images/' + match[1]);
  }
}

</t>
<t tx="leo.20210414171924.17">function setupModalWindow() {
  var doc = document.querySelector('#webots-doc');

  // Create the following HTML tags:
  // &lt;div id="modal-window" class="modal-window"&gt;
  //   &lt;span class="modal-window-close-button"&gt;&amp;times;&lt;/span&gt;
  //   &lt;img class="modal-window-image-content" /&gt;
  //   &lt;div class="modal-window-caption"&gt;&lt;/div&gt;
  // &lt;/div&gt;

  var close = document.createElement('span');
  close.classList.add('modal-window-close-button');
  close.innerHTML = '&amp;times;';
  @others
}

</t>
<t tx="leo.20210414171924.18">close.onclick = function() {
  modal.style.display = 'none';
};

var loadImage = document.createElement('img');
loadImage.classList.add('modal-window-load-image');
loadImage.setAttribute('src', computeTargetPath() + '../css/images/load_animation.gif');

var image = document.createElement('img');
image.classList.add('modal-window-image-content');

var caption = document.createElement('div');
caption.classList.add('modal-window-caption');

var modal = document.createElement('div');
modal.setAttribute('id', 'modal-window');
modal.classList.add('modal-window');

modal.appendChild(close);
modal.appendChild(loadImage);
modal.appendChild(image);
modal.appendChild(caption);
doc.appendChild(modal);

</t>
<t tx="leo.20210414171924.19">window.onclick = function(event) {
  if (event.target === modal) {
    modal.style.display = 'none';
    loadImage.style.display = 'block';
    image.style.display = 'none';
  }
};
</t>
<t tx="leo.20210414171924.2">  String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };
}

</t>
<t tx="leo.20210414171924.20">function updateModalEvents(view) {
  var modal = document.querySelector('#modal-window');
  var image = modal.querySelector('.modal-window-image-content');
  var loadImage = modal.querySelector('.modal-window-load-image');
  var caption = modal.querySelector('.modal-window-caption');

  // Add the modal events on each image.
  var imgs = view.querySelectorAll('img');
  for (var i = 0; i &lt; imgs.length; i++) {
    imgs[i].onclick = function(event) {
      var img = event.target;
      // The modal window is only enabled on big enough images and on thumbnail.
      if (img.src.indexOf('thumbnail') === -1 &amp;&amp; !(img.naturalWidth &gt; 128 &amp;&amp; img.naturalHeight &gt; 128))
        return;

      // Show the modal window and the caption.
      modal.style.display = 'block';
      caption.innerHTML = (typeof this.parentNode.childNodes[1] !== 'undefined') ? this.parentNode.childNodes[1].innerHTML : '';

      if (img.src.indexOf('.thumbnail.') === -1) {
        // this is not a thumbnail =&gt; show the image directly.
        image.src = img.src;
        loadImage.style.display = 'none';
        image.style.display = 'block';
      } else {
        // this is a thumbnail =&gt; load the actual image.
        var url = img.src.replace('.thumbnail.', '.');
        if (image.src === url) {
          // The image has already been loaded.
          loadImage.style.display = 'none';
          image.style.display = 'block';
          return;
        } else {
          // The image has to be loaded: show the loading image.
          loadImage.style.display = 'block';
          image.style.display = 'none';
        }
        // In case of thumbnail, search for the original png or jpg
        @others
    };
  }
}

</t>
<t tx="leo.20210414171924.21"></t>
<t tx="leo.20210414171924.22">image.onload = function() {
  // The original image has been loaded successfully =&gt; show it.
  loadImage.style.display = 'none';
  image.style.display = 'block';
};
</t>
<t tx="leo.20210414171924.23">  image.onerror = function() {
    // The original image has not been loaded successfully =&gt; try to change the extension and reload it.
    image.onerror = function() {
      // The original image has not been loaded successfully =&gt; abort.
      modal.style.display = 'none';
      loadImage.style.display = 'block';
      image.style.display = 'none';
    };
    url = img.src.replace('.thumbnail.jpg', '.png');
    image.src = url;
  };
  image.src = url;
}
</t>
<t tx="leo.20210414171924.24"></t>
<t tx="leo.20210414171924.25">function applyAnchor() {
  var firstAnchor = document.querySelector("[name='" + localSetup.anchor + "']");
  if (firstAnchor) {
    firstAnchor.scrollIntoView(true);
    if (document.querySelector('.contribution-banner'))
      window.scrollBy(0, -38); // GitHub banner.
    if (isCyberboticsUrl)
      window.scrollBy(0, -44); // Cyberbotics header.
  } else
    window.scrollTo(0, 0);
}

</t>
<t tx="leo.20210414171924.26">function applyToTitleDiv() {
  var titleContentElement = document.querySelector('#title-content');
  if (titleContentElement) {
    var newTitle;
    if (localSetup.book === 'guide')
      newTitle = 'Webots User Guide';
    else if (localSetup.book === 'reference')
      newTitle = 'Webots Reference Manual';
    else if (localSetup.book === 'blog')
      newTitle = 'Webots Blog';
    else if (localSetup.book === 'discord')
      newTitle = 'Webots Discord Archives';
    else if (localSetup.book === 'automobile')
      newTitle = 'Webots for automobiles';
    else
      newTitle = '';
    if (newTitle.length &gt; 0) {
      newTitle += " &lt;div class='release-tag'&gt;" + getWebotsVersion() + '&lt;/div&gt;';
      titleContentElement.innerHTML = newTitle;
    }
  }
}

</t>
<t tx="leo.20210414171924.27">function addContributionBanner() {
  // if we're on the website we need to move the banner down by the height of the navbar
  var displacement = isCyberboticsUrl ? '44px' : '0px';

  // append contribution sticker to primary doc element
  document.querySelector('#center').innerHTML += '&lt;div style="top:' + displacement + '" class="contribution-banner"&gt;' +
                                                 'Found an error?' +
                                                 '&lt;a target="_blank" class="contribution-banner-url" href="https://github.com/cyberbotics/webots/tree/master/docs"&gt; ' +
                                                 'Contribute on GitHub!' +
                                                 '&lt;span class=github-logo /&gt;' +
                                                 '&lt;/a&gt;' +
                                                 '&lt;p id="contribution-close"&gt;X&lt;/p&gt;' +
                                                 '&lt;/div&gt;';
  updateContributionBannerUrl();

  var contributionBanner = document.querySelector('.contribution-banner');

  document.querySelector('#contribution-close').onclick = function() {
    contributionBanner.parentNode.removeChild(contributionBanner);
  };
}

</t>
<t tx="leo.20210414171924.28"></t>
<t tx="leo.20210414171924.29">function updateContributionBannerUrl() {
  var contributionBanner = document.querySelector('.contribution-banner-url');
  if (contributionBanner)
    contributionBanner.href = 'https://github.com/cyberbotics/webots/edit/master/docs/' + localSetup.book + '/' + localSetup.page + '.md';
}

</t>
<t tx="leo.20210414171924.3">function isInternetExplorer() {
  var userAgent = navigator.userAgent;
  return userAgent.indexOf('MSIE') !== -1 || userAgent.indexOf('Trident') !== -1;
};

var localSetup = (typeof setup === 'undefined') ? {} : setup;
var isCyberboticsUrl = location.href.indexOf('cyberbotics.com/doc') !== -1;

</t>
<t tx="leo.20210414171924.30">function addNavigationToBlogIfNeeded() {
  if (!document.querySelector('#next-previous-section') &amp;&amp; localSetup.book === 'blog') {
    let menu = document.querySelector('#menu');
    let lis = menu.querySelectorAll('li');
    let currentPageIndex = -1;
    for (let i = 0; i &lt; lis.length; ++i) {
      if (lis[i].className === 'selected') {
        currentPageIndex = i;
        break;
      }
    }

    if (currentPageIndex === -1)
      return;

    // console.log(currentPageIndex, lis.length);
    // console.log(lis);
    let div = document.createElement('div');
    div.setAttribute('id', 'next-previous-section');
    // previous post
    if (currentPageIndex &gt; 0) {
      let previous = lis[currentPageIndex - 1];
      let a = previous.firstChild.cloneNode();
      a.innerHTML += '&lt;&lt; Previous Post: ' + previous.textContent;
      a.setAttribute('class', 'post-selector left');
      div.appendChild(a);
    }

    if (currentPageIndex &lt; lis.length - 1) {
      let next = lis[currentPageIndex + 1];
      let a = next.firstChild.cloneNode();
      a.innerHTML += 'Next Post: ' + next.textContent + ' &gt;&gt;';
      a.setAttribute('class', 'post-selector right');
      div.appendChild(a);
    }

    document.querySelector('#publish-data').parentNode.insertBefore(div, document.querySelector('#publish-data').nextSibling);
  }
}

</t>
<t tx="leo.20210414171924.31">function setupBlogFunctionalitiesIfNeeded() {
  if (localSetup.book === 'blog') {
    // hide index, this doesn't make sense for a blog post
    let index = document.querySelector('#index');
    let indexTitle = document.querySelector('#indexTitle');

    if (index !== null)
      index.style.display = 'none';

    if (indexTitle !== null)
      indexTitle.style.display = 'none';

    // hide the release tag, this is also nonsensical here
    document.querySelector('.release-tag').style.display = 'none';

    document.title = document.title.replace('documentation', 'Blog');
  }
}

</t>
<t tx="leo.20210414171924.32">function createIndex(view) {
  // Note: the previous index is cleaned up when the parent title is destroyed.

  // Get all the view headings.
  var headings = [].slice.call(view.querySelectorAll('h1, h2, h3, h4'));

  // Do not create too small indexes.
  var content = document.querySelector('#content');
  if ((content.offsetHeight &lt; 2 * window.innerHeight || headings.length &lt; 4) &amp;&amp; (localSetup.book !== 'discord' || headings.length &lt; 2))
    return;

  var level = parseInt(headings[0].tagName[1]) + 1; // current heading level.

  // Create an empty index, and insert it before the second heading.
  var indexTitle = document.createElement('h' + level);
  indexTitle.textContent = 'Index';
  indexTitle.setAttribute('id', 'indexTitle');
  headings[0].parentNode.insertBefore(indexTitle, headings[1]);
  var ul = document.createElement('ul');
  ul.setAttribute('id', 'index');
  headings[0].parentNode.insertBefore(ul, headings[1]);

  headings.forEach(function(heading, i) {
    if (i === 0) // Skip the first heading.
      return;

    // Update current level and ul.
    var newLevel = parseInt(heading.tagName[1]);
    while (newLevel &gt; level) {
      var newUl = document.createElement('ul');
      ul.appendChild(newUl);
      ul = newUl;
      level += 1;
    }
    while (newLevel &lt; level) {
      ul = ul.parentNode;
      level -= 1;
    }

    // Add the &lt;li&gt; tag.
    var anchor = heading.getAttribute('name');
    var a = document.createElement('a');
    a.setAttribute('href', '#' + anchor);
    a.textContent = heading.textContent;
    var li = document.createElement('li');
    li.appendChild(a);
    ul.appendChild(li);
  });
}

</t>
<t tx="leo.20210414171924.33"></t>
<t tx="leo.20210414171924.34">function getWebotsVersion() {
  if (localSetup.branch)
    return localSetup.branch;
  // Get the Webots version from the showdown wbVariables extension
  var version = '{{ webots.version.full }}';
  var converter = new showdown.Converter({extensions: ['wbVariables']});
  var html = converter.makeHtml(version);
  var tmp = document.createElement('div');
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || '';
}

</t>
<t tx="leo.20210414171924.35">function applyToPageTitle(mdContent) {
  var hashtagIndex = mdContent.indexOf('#');
  if (hashtagIndex &gt;= 0) {
    while (hashtagIndex + 1 &lt; mdContent.length &amp;&amp; mdContent[hashtagIndex + 1] === '#')
      hashtagIndex += 1;
    var hashtagCarriageReturn = mdContent.indexOf('\n', hashtagIndex);
    if (hashtagCarriageReturn &gt;= 0) {
      var title = mdContent.substring(hashtagIndex + 1, hashtagCarriageReturn).trim();
      document.title = 'Webots documentation: ' + title;
    }
  }
}

</t>
<t tx="leo.20210414171924.36">function populateViewDiv(mdContent) {
  setupUrl(document.location.href);

  var view = document.querySelector('#view');
  while (view.firstChild)
    view.removeChild(view.firstChild);

  // console.log('Raw MD content:\n\n');
  // console.log(mdContent);

  applyToPageTitle(mdContent);

  // markdown to html
  window.mermaidGraphCounter = 0;
  window.mermaidGraphs = {};
  var converter = new showdown.Converter({tables: 'True', extensions: ['wbTabComponent', 'wbRobotComponent', 'wbSpoiler', 'wbChart', 'wbVariables', 'wbAPI', 'wbFigure', 'wbAnchors', 'wbIllustratedSection', 'youtube']});
  var html = converter.makeHtml(mdContent);

  // console.log('HTML content: \n\n')
  // console.log(html);

  view.innerHTML = html;

  createRobotComponent(view);
  renderGraphs();
  redirectImages(view);
  updateModalEvents(view);
  redirectUrls(view);
  collapseMovies(view);

  applyAnchorIcons(view);
  highlightCode(view);

  updateSelection();
  createIndex(view);

  setupBlogFunctionalitiesIfNeeded();
  addNavigationToBlogIfNeeded();

  var images = view.querySelectorAll('img');
  if (images.length &gt; 0) {
    // apply the anchor only when the images are loaded,
    // otherwise, the anchor can be overestimated.
    var lastImage = images[images.length - 1];
    $(lastImage).load(applyAnchor);
  } else
    applyAnchor();
  applyTabs();
}

</t>
<t tx="leo.20210414171924.37">// replace the browser URL after a dynamic load
function updateBrowserUrl() {
  var url = forgeUrl(localSetup.book, localSetup.page, localSetup.tabs, localSetup.anchor);
  if (history.pushState) {
    try {
      history.pushState({state: 'new'}, null, url);
    } catch (err) {
    }
  }
  var canonicalUrl = 'https://cyberbotics.com/doc/' + localSetup.book + '/' + localSetup.page;
  $('link[rel="canonical"]').attr('href', canonicalUrl);
}

</t>
<t tx="leo.20210414171924.38">// Make in order that the back button is working correctly
window.onpopstate = function(event) {
  setupUrl(document.location.href);
  getMDFile();
};

</t>
<t tx="leo.20210414171924.39">function highlightCode(view) {
  var supportedLanguages = ['c', 'cpp', 'java', 'python', 'matlab', 'sh', 'ini', 'tex', 'makefile', 'lua', 'xml'];

  for (var i = 0; i &lt; supportedLanguages.length; i++) {
    var language = supportedLanguages[i];
    hljs.configure({languages: [ language ]});
    var codes = document.querySelectorAll('.' + language);
    for (var j = 0; j &lt; codes.length; j++) {
      var code = codes[j];
      hljs.highlightBlock(code);
    }
  }
}

</t>
<t tx="leo.20210414171924.4">function setupCyberboticsUrl(url) {
  localSetup.book = 'guide';
  localSetup.page = 'index';
  localSetup.anchor = '';
  if (!localSetup.tabs)
    localSetup.tabs = {};

  var m = url.match(new RegExp('/([^/]+)/([^/\\?#]+)([^/]*)$'));
  if (m) {
    localSetup.book = m[1];
    localSetup.page = m[2];
    var args = m[3];

    m = url.match(/version=([^&amp;#]*)/);
    if (m) {
      var version = m[1];
      var n = version.indexOf(':');
      if (n === -1)
        localSetup.branch = version;
      else
        localSetup.branch = version.substr(n + 1);
    }

    // Extract tab options
    var tabRegex = /[?&amp;](tab-[^=]+)=([^&amp;#]+)/g;
    while ((m = tabRegex.exec(url)) !== null)
      localSetup.tabs[m[1]] = m[2];

    m = args.match(/#([^&amp;#]*)/);
    if (m)
      localSetup.anchor = m[1];
    else
      localSetup.anchor = '';
  }
}

</t>
<t tx="leo.20210414171924.40">function resetRobotComponent(robot) {
  unhighlightX3DElement(robot);
  var robotComponent = getRobotComponentByRobotName(robot);
  // Reset the Viewpoint
  var camera = robotComponent.webotsView.x3dScene.getCamera();
  camera.position.copy(camera.userData.initialPosition);
  camera.quaternion.copy(camera.userData.initialQuaternion);
  // Reset the motor sliders.
  var sliders = robotComponent.querySelectorAll('.motor-slider');
  for (var s = 0; s &lt; sliders.length; s++) {
    var slider = sliders[s];
    slider.value = slider.getAttribute('webots-position');
    var id = slider.getAttribute('webots-transform-id');
    sliderMotorCallback(robotComponent.webotsView.x3dScene.getObjectById(id, true), slider);
  }
  robotComponent.webotsView.x3dScene.render();
}

</t>
<t tx="leo.20210414171924.41">function updateRobotComponentDimension(robot) {
  var robotComponent = getRobotComponentByRobotName(robot);
  var deviceMenu = robotComponent.querySelector('.device-component');
  var robotView = robotComponent.querySelector('.robot-view');

  if (typeof robotComponent.showDeviceComponent === 'undefined')
    robotComponent.showDeviceComponent = true;
  if (robotComponent.showDeviceComponent === true) {
    deviceMenu.style.display = '';
    robotView.style.width = '70%';
  } else {
    deviceMenu.style.display = 'none';
    robotView.style.width = '100%';
  }

  robotComponent.webotsView.x3dScene.resize();
}

</t>
<t tx="leo.20210414171924.42">function toggleDeviceComponent(robot) {
  var robotComponent = getRobotComponentByRobotName(robot);
  if (typeof robotComponent.showDeviceComponent === 'undefined')
    robotComponent.showDeviceComponent = true;
  robotComponent.showDeviceComponent = !robotComponent.showDeviceComponent;
  updateRobotComponentDimension(robot);
}

</t>
<t tx="leo.20210414171924.43">function toogleRobotComponentFullScreen(robot) { // eslint-disable-line no-unused-vars
  // Source: https://stackoverflow.com/questions/7130397/how-do-i-make-a-div-full-screen
  var element = getRobotComponentByRobotName(robot);
  if (
    document.fullscreenElement ||
    document.webkitFullscreenElement ||
    document.mozFullScreenElement ||
    document.msFullscreenElement
  ) {
    if (document.exitFullscreen)
      document.exitFullscreen();
    else if (document.mozCancelFullScreen)
      document.mozCancelFullScreen();
    else if (document.webkitExitFullscreen)
      document.webkitExitFullscreen();
    else if (document.msExitFullscreen)
      document.msExitFullscreen();
  } else {
    if (element.requestFullscreen) {
      element.requestFullscreen();
      @others
}

</t>
<t tx="leo.20210414171924.44">  document.addEventListener('fullscreenchange', function() {
    updateRobotComponentDimension(robot);
  });
} else if (element.mozRequestFullScreen) {
  element.mozRequestFullScreen();
</t>
<t tx="leo.20210414171924.45">  document.addEventListener('mozfullscreenchange', function() {
    updateRobotComponentDimension(robot);
  });
} else if (element.webkitRequestFullscreen) {
  element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
</t>
<t tx="leo.20210414171924.46">  document.addEventListener('webkitfullscreenchange', function() {
    updateRobotComponentDimension(robot);
  });
} else if (element.msRequestFullscreen) {
  element.msRequestFullscreen();
</t>
<t tx="leo.20210414171924.47">    document.addEventListener('msfullscreenchange', function() {
      updateRobotComponentDimension(robot);
    });
  }
}
</t>
<t tx="leo.20210414171924.48">function sliderMotorCallback(transform, slider) {
  if (typeof transform === 'undefined')
    return;

  if (typeof transform.firstRotation === 'undefined' &amp;&amp; typeof transform.quaternion !== 'undefined')
    transform.firstRotation = transform.quaternion.clone();

  if (typeof transform.firstPosition === 'undefined' &amp;&amp; typeof transform.position !== 'undefined')
    transform.firstPosition = transform.position.clone();

  var axis = slider.getAttribute('webots-axis').split(/[\s,]+/);
  axis = new THREE.Vector3(parseFloat(axis[0]), parseFloat(axis[1]), parseFloat(axis[2]));

  var value = parseFloat(slider.value);
  var position = parseFloat(slider.getAttribute('webots-position'));

  if (slider.getAttribute('webots-type') === 'LinearMotor') {
    // Compute translation
    var translation = new THREE.Vector3();
    if ('initialTranslation' in transform.userData)
      translation = transform.userData.initialTranslation.clone();
    else {
      translation = transform.position;
      transform.userData.initialTranslation = translation.clone();
    }
    translation = translation.add(axis.multiplyScalar(value - position));
    // Apply the new position.
    transform.position.copy(translation);
    transform.updateMatrix();
  } else {
    // extract anchor
    var anchor = slider.getAttribute('webots-anchor').split(/[\s,]+/);
    anchor = new THREE.Vector3(parseFloat(anchor[0]), parseFloat(anchor[1]), parseFloat(anchor[2]));

    // Compute angle.
    var angle = value - position;

    // Apply the new axis-angle.
    var q = new THREE.Quaternion();
    q.setFromAxisAngle(
      axis,
      angle
    );

    if (typeof transform.firstRotation !== 'undefined')
      q.multiply(transform.firstRotation);

    if (typeof transform.firstPosition !== 'undefined')
      transform.position.copy(transform.firstPosition);

    transform.position.sub(anchor); // remove the offset
    transform.position.applyAxisAngle(axis, angle); // rotate the POSITION
    transform.position.add(anchor); // re-add the offset

    transform.quaternion.copy(q);
    transform.updateMatrix();
  }
}

</t>
<t tx="leo.20210414171924.49">function unhighlightX3DElement(robot) {
  var robotComponent = getRobotComponentByRobotName(robot);
  var scene = robotComponent.webotsView.x3dScene;

  if (robotComponent.billboardOrigin) {
    robotComponent.billboardOrigin.parent.remove(robotComponent.billboardOrigin);
    robotComponent.billboardOrigin = undefined;
  }

  for (var h = 0; h &lt; robotComponent.highlightedAppearances.length; h++) {
    var appearance = robotComponent.highlightedAppearances[h];
    appearance.emissive.set(appearance.userData.initialEmissive);
  }
  robotComponent.highlightedAppearances = [];
  scene.render();
}

</t>
<t tx="leo.20210414171924.5">function setupDefaultUrl(url) {
  var m;

  m = url.match(/page=([^&amp;#]*)/);
  if (m)
    localSetup.page = m[1].replace(/.md$/, '');
  else
    localSetup.page = 'index';

  m = url.match(/book=([^&amp;#]*)/);
  if (m)
    localSetup.book = m[1];
  else if (!localSetup.book)
    localSetup.book = 'guide';

  // Extract tab options
  if (!localSetup.tabs)
    localSetup.tabs = {};
  var tabRegex = /[?&amp;](tab-[^=]+)=([^&amp;#]+)/g;
  while ((m = tabRegex.exec(url)) !== null)
    localSetup.tabs[m[1]] = m[2];

  m = url.match(/#([^&amp;#]*)/);
  if (m)
    localSetup.anchor = m[1];
  else
    localSetup.anchor = '';
}

</t>
<t tx="leo.20210414171924.50">function highlightX3DElement(robot, deviceElement) {
  unhighlightX3DElement(robot);

  var robotComponent = getRobotComponentByRobotName(robot);
  var scene = robotComponent.webotsView.x3dScene;
  var id = deviceElement.getAttribute('webots-transform-id');
  var type = deviceElement.getAttribute('webots-type');
  var object = scene.getObjectById(id, true);

  if (object) {
    // Show billboard origin.
    var originBillboard = robotComponent.billboardOriginMesh.clone();
    if (deviceElement.hasAttribute('device-anchor')) {
      var anchor = deviceElement.getAttribute('device-anchor').split(/[\s,]+/);
      anchor = new THREE.Vector3(parseFloat(anchor[0]), parseFloat(anchor[1]), parseFloat(anchor[2]));
      originBillboard.position.add(anchor);
      object.parent.add(originBillboard);
    } else {
      if (deviceElement.hasAttribute('webots-transform-offset')) {
        var offset = deviceElement.getAttribute('webots-transform-offset').split(/[\s,]+/);
        offset = new THREE.Vector3(parseFloat(offset[0]), parseFloat(offset[1]), parseFloat(offset[2]));
        originBillboard.position.add(offset);
      }
      object.add(originBillboard);
    }
    robotComponent.billboardOrigin = originBillboard;

    if (type === 'LED') {
      var pbrIDs = deviceElement.getAttribute('ledPBRAppearanceIDs').split(' ');
      for (var p = 0; p &lt; pbrIDs.length; p++) {
        var pbrID = pbrIDs[p];
        if (pbrID) {
          var ledColor = deviceElement.getAttribute('targetColor').split(' ');
          ledColor = new THREE.Color(ledColor[0], ledColor[1], ledColor[2]);
          object.traverse(function(child) {
            if (child.material &amp;&amp; child.material.name === pbrID) {
              if (!child.material.userData.initialEmissive)
                child.material.userData.initialEmissive = child.material.emissive.clone();
              child.material.emissive.set(ledColor);
              robotComponent.highlightedAppearances.push(child.material);
            }
          });
        }
      }
    }

    scene.render();
  }
}

</t>
<t tx="leo.20210414171924.51"></t>
<t tx="leo.20210414171924.52">function setBillboardSize(robotComponent, scene) {
  // Estimate roughly the robot scale based on the AABB.
  var robotID = robotComponent.getAttribute('robot-node-id');
  if (typeof robotID === 'undefined')
    return;
  var robot;
  scene.traverse(function(object) {
    if (object.isObject3D &amp;&amp; object.name === robotID)
      robot = object;
  });
  if (typeof robot === 'undefined')
    return;
  var aabb = new THREE.Box3().setFromObject(robot);
  var max = Math.max(aabb.max.x - aabb.min.x, Math.max(aabb.max.y - aabb.min.y, aabb.max.z - aabb.min.z));
  var size = Math.max(0.01, max) / 30.0;
  robotComponent.billboardOriginMesh.geometry = new THREE.PlaneGeometry(size, size);
}

</t>
<t tx="leo.20210414171924.53"></t>
<t tx="leo.20210414171924.54">function getRobotComponentByRobotName(robotName) {
  return document.querySelector('#' + robotName + '-robot-component');
}

</t>
<t tx="leo.20210414171924.55">function createRobotComponent(view) {
  var robotComponents = document.querySelectorAll('.robot-component');
  for (var c = 0; c &lt; robotComponents.length; c++) { // foreach robot components of this page.
    var robotComponent = robotComponents[c];
    var webotsViewElement = document.querySelectorAll('.robot-webots-view')[0];
    var robotName = webotsViewElement.getAttribute('id').replace('-robot-webots-view', '');
    var webotsView = new webots.View(webotsViewElement);
    robotComponent.webotsView = webotsView; // Store the Webots view in the DOM element for a simpler access.
    @others
}

</t>
<t tx="leo.20210414171924.56">webotsView.onready = function() { // When Webots View has been successfully loaded.
  var camera = webotsView.x3dScene.getCamera();

  // Make sure the billboard remains well oriented.
  webotsView.x3dScene.preRender = function() {
    if (robotComponent.billboardOrigin)
      robotComponent.billboardOrigin.lookAt(camera.position);
  };
  robotComponent.highlightedAppearances = [];

  // Store viewpoint.
  camera.userData.initialQuaternion = camera.quaternion.clone();
  camera.userData.initialPosition = camera.position.clone();

  // Create the origin billboard mesh.
  var loader = new THREE.TextureLoader();
  var planeGeometry = new THREE.PlaneGeometry(0.05, 0.05);
  var planeMaterial = new THREE.MeshBasicMaterial({
    depthTest: false,
    transparent: true,
    opacity: 0.5,
    map: loader.load(
      computeTargetPath() + '../css/images/center.png'
    )
  });
  robotComponent.billboardOriginMesh = new THREE.Mesh(planeGeometry, planeMaterial);
  robotComponent.billboardOriginMesh.renderOrder = 1;

  setBillboardSize(robotComponent, webotsView.x3dScene.scene);
};

// Load the robot X3D file.
webotsView.open(
  computeTargetPath() + 'scenes/' + robotName + '/' + robotName + '.x3d',
  undefined,
  computeTargetPath() + 'scenes/' + robotName + '/'
);

// Load the robot meta JSON file.
$.ajax({
  type: 'GET',
  url: computeTargetPath() + 'scenes/' + robotName + '/' + robotName + '.meta.json',
  dataType: 'text',
  success: function(content) { // When successfully loaded.
    // Populate the device component from the JSON file.
    var deviceComponent = view.querySelector('#' + robotName + '-device-component');
    var data = JSON.parse(content);
    var categories = {};
    robotComponent.setAttribute('robot-node-id', data['robotID']);
    setBillboardSize(robotComponent, webotsView.x3dScene.scene);
    if (data['devices'].length === 0)
      toggleDeviceComponent(robotName);
    for (var d = 0; d &lt; data['devices'].length; d++) {
      var device = data['devices'][d];
      var deviceName = device['name'];
      var deviceType = device['type'];

      // Create or retrieve the device category container.
      var category = null;
      if (deviceType in categories)
        category = categories[deviceType];
      else {
        category = document.createElement('div');
        category.classList.add('device-category');
        category.innerHTML = '&lt;div class="device-title"&gt;' + deviceType + '&lt;/div&gt;';
        deviceComponent.appendChild(category);
        categories[deviceType] = category;
      }

      // Create the new device.
      var deviceDiv = document.createElement('div');
      deviceDiv.classList.add('device');
      deviceDiv.setAttribute('onmouseover', 'highlightX3DElement("' + robotName + '", this)');
      deviceDiv.setAttribute('webots-type', deviceType);
      deviceDiv.setAttribute('webots-transform-id', device['transformID']);
      if ('transformOffset' in device) // The Device Transform has not been exported. The device is defined relatively to it's Transform parent.
        deviceDiv.setAttribute('webots-transform-offset', device['transformOffset']);
      deviceDiv.innerHTML = '&lt;div class="device-name"&gt;' + deviceName + '&lt;/div&gt;';

      // Create the new motor.
      if (deviceType.endsWith('Motor') &amp;&amp; !device['track']) {
        var minLabel = document.createElement('div');
        minLabel.classList.add('motor-label');
        var maxLabel = document.createElement('div');
        maxLabel.classList.add('motor-label');
        var slider = document.createElement('input');
        slider.classList.add('motor-slider');
        slider.setAttribute('type', 'range');
        slider.setAttribute('step', 'any');
        if (device['minPosition'] === device['maxPosition']) { // infinite range.
          slider.setAttribute('min', -Math.PI);
          slider.setAttribute('max', Math.PI);
          minLabel.innerHTML = -3.14; // 2 decimals.
          maxLabel.innerHTML = 3.14;
        } else { // fixed range.
          var epsilon = 0.000001; // To solve Windows browser bugs on slider when perfectly equals to 0.
          slider.setAttribute('min', device['minPosition'] - epsilon);
          slider.setAttribute('max', device['maxPosition'] + epsilon);
          minLabel.innerHTML = Math.round(device['minPosition'] * 100) / 100; // 2 decimals.
          maxLabel.innerHTML = Math.round(device['maxPosition'] * 100) / 100;
        }
        slider.setAttribute('value', device['position']);
        slider.setAttribute('webots-position', device['position']);
        slider.setAttribute('webots-transform-id', device['transformID']);
        slider.setAttribute('webots-axis', device['axis']);
        slider.setAttribute('webots-anchor', device['anchor']);
        slider.setAttribute('webots-type', deviceType);
</t>
<t tx="leo.20210414171924.57"></t>
<t tx="leo.20210414171924.58">          slider.addEventListener(isInternetExplorer() ? 'change' : 'input', function(e) {
            var id = e.target.getAttribute('webots-transform-id');
            sliderMotorCallback(webotsView.x3dScene.getObjectById(id, true), e.target);
            webotsView.x3dScene.render();
          });

          var motorDiv = document.createElement('div');
          motorDiv.classList.add('motor-component');
          motorDiv.appendChild(minLabel);
          motorDiv.appendChild(slider);
          motorDiv.appendChild(maxLabel);
          deviceDiv.appendChild(motorDiv);
          deviceDiv.setAttribute('device-anchor', device['anchor']);
        }

        // LED case: set the target color.
        if (deviceType === 'LED' &amp;&amp; 'ledColors' in device &amp;&amp; 'ledPBRAppearanceIDs' in device) {
          // For now, simply take the first color. More complex mechanism could be implemented if required.
          var targetColor = (device['ledColors'].length &gt; 0) ? device['ledColors'][0] : '0 0 1';
          deviceDiv.setAttribute('targetColor', targetColor);
          deviceDiv.setAttribute('ledPBRAppearanceIDs', device['ledPBRAppearanceIDs'].join(' '));
        }

        category.appendChild(deviceDiv);
      }
    },
    error: function(XMLHttpRequest, textStatus, errorThrown) {
      console.log('Status: ' + textStatus);
      console.log('Error: ' + errorThrown);
    }
  });
}
</t>
<t tx="leo.20210414171924.59">// Open a tab component tab
function openTabFromEvent(evt, option, name) {
  // update links
  var a = document.querySelectorAll('a');
  for (var i = 0; i &lt; a.length; i++) {
    var href = a[i].getAttribute('href');
    if (!href)
      continue;
    if (localSetup.tabs[option]) {
      if (href.includes(option + '=' + localSetup.tabs[option]))
        a[i].setAttribute('href', href.replace(option + '=' + localSetup.tabs[option], option + '=' + name.toLowerCase()));
      else if (!href.startsWith('#'))
        a[i].setAttribute('href', href + (href.indexOf('?') &gt; -1 ? '&amp;' : '?') + option + '=' + name.toLowerCase());
    }
  }
  // open tab
  localSetup.tabs[option] = name.toLowerCase();
  updateBrowserUrl();
  openTab(evt.target.parentNode, localSetup.tabs[option]);
}

</t>
<t tx="leo.20210414171924.6">function setupUrl(url) {
  if (isCyberboticsUrl)
    setupCyberboticsUrl(url);
  else
    setupDefaultUrl(url);

  var tabsQuery = '';
  for (var option in localSetup.tabs) {
    if (!localSetup.tabs[option])
      continue;
    if (tabsQuery)
      tabsQuery += ',';
    tabsQuery += option + '=' + localSetup.tabs[option];
  }
  tabsQuery = '[' + tabsQuery + ']';
  console.log('book=' + localSetup.book + ' page=' + localSetup.page + ' branch=' + localSetup.branch + ' tabs=' + tabsQuery + ' anchor=' + localSetup.anchor);
}

</t>
<t tx="leo.20210414171924.60">// Open a tab component tab
function openTab(tabcomponent, name) {
  var tabID = tabcomponent.getAttribute('tabid');

  var tabcontent = tabcomponent.parentNode.querySelectorAll('.tab-content[tabid="' + tabID + '"][name="' + name + '"]')[0];
  if (typeof tabcontent === 'undefined')
    return false;

  var tabcontents = tabcomponent.parentNode.querySelectorAll('.tab-content[tabid="' + tabID + '"]');
  for (var i = 0; i &lt; tabcontents.length; i++)
    tabcontents[i].style.display = 'none';

  var tablinks = tabcomponent.querySelectorAll('.tab-links');
  for (var j = 0; j &lt; tablinks.length; j++)
    tablinks[j].classList.remove('active');

  tabcontent = tabcomponent.parentNode.querySelectorAll('.tab-content[tabid="' + tabID + '"][name="' + name + '"]')[0];
  tabcontent.style.display = 'block';

  var tablink = tabcomponent.querySelectorAll('.tab-links[name="' + name + '"]')[0];
  tablink.classList.add('active');
  return true;
}

</t>
<t tx="leo.20210414171924.61">function applyTabs() {
  var tabComponents = document.querySelectorAll('.tab-component');
  for (var k = 0; k &lt; tabComponents.length; k++) {
    for (var tabName in localSetup.tabs) {
      if (openTab(tabComponents[k], localSetup.tabs[tabName]))
        break;
    }
  }
}

</t>
<t tx="leo.20210414171924.62">function renderGraphs() {
  for (var id in window.mermaidGraphs) {
    window.mermaidAPI.render(id, window.mermaidGraphs[id], function(svgCode, bindFunctions) {
      document.querySelector('#' + id + 'Div').innerHTML = svgCode;
      // set min-width to be 2/3 of the max-width otherwise the text might become too small
      var element = document.querySelector('#' + id);
      var style = element.getAttribute('style');
      element.setAttribute('style', style + ' min-width:' + Math.floor(0.66 * parseInt(style.split('max-width:')[1].split('px'))) + 'px;');
    });
  }
}

</t>
<t tx="leo.20210414171924.63"></t>
<t tx="leo.20210414171924.64">function applyAnchorIcons(view) {
  var elements = [];
  var tags = ['figcaption', 'h1', 'h2', 'h3', 'h4', 'h5'];
  var i;
  for (i = 0; i &lt; tags.length; i++) {
    var array = Array.prototype.slice.call(view.querySelectorAll(tags[i]));
    elements = elements.concat(array);
  }
  for (i = 0; i &lt; elements.length; i++) {
    var el = elements[i];
    var name = null;
    if (el.parentNode &amp;&amp; el.tagName.toLowerCase() === 'figcaption' &amp;&amp; el.parentNode.tagName.toLowerCase() === 'figure')
      name = el.parentNode.getAttribute('name');
    else
      name = el.getAttribute('name');
    if (name) {
      el.classList.add('anchor-header');
      var span = document.createElement('span');
      span.classList.add('anchor-link-image');
      var a = document.createElement('a');
      a.setAttribute('href', '#' + name);
      a.classList.add('anchor-link');
      a.appendChild(span);
      el.insertBefore(a, el.firstChild);
    }
  }
}

</t>
<t tx="leo.20210414171924.65">function receiveMenuContent(menuContent) {
  // console.log('Menu content:\n\n');
  // console.log(menuContent);

  var menu = null;

  var converter = new showdown.Converter();
  var html = converter.makeHtml(menuContent);
  var div = document.createElement('div');
  div.innerHTML = html;

  for (var i = 0; i &lt; div.childNodes.length; i++) {
    var child = div.childNodes[i];
    if (child &amp;&amp; child.tagName &amp;&amp; child.tagName.length &gt; 0 &amp;&amp; child.tagName.toLowerCase() === 'ul') {
      menu = child;
      break;
    }
  }

  if (!menu) {
    console.error('Cannot extract Menu.');
    return;
  }

  populateMenu(menu);
  redirectUrls(menu);
  updateSelection();
  addNavigationToBlogIfNeeded();
}

</t>
<t tx="leo.20210414171924.66">function updateMenuScrollbar() {
  var e = document.documentElement;
  var t = document.documentElement.scrollTop || document.body.scrollTop;
  var p = e.scrollHeight - t - e.clientHeight;
  var footerHeight = 192;
  if (p &lt; footerHeight)
    document.querySelector('#left').style.height = (e.clientHeight - footerHeight + p) + 'px';
  else
    document.querySelector('#left').style.height = '100%';
}

</t>
<t tx="leo.20210414171924.67">function updateSelection() {
  var selected = changeMenuSelection();
  populateNavigation(selected);
  if (isCyberboticsUrl)
    updateMenuScrollbar();
}

</t>
<t tx="leo.20210414171924.68">function changeMenuSelection() {
  var menu = document.querySelector('#menu');
  var selecteds = [].slice.call(menu.querySelectorAll('.selected'));
  var i;
  var selected;
  for (i = 0; i &lt; selecteds.length; i++) {
    selected = selecteds[i];
    selected.classList.remove('selected');
  }
  var as = menu.querySelectorAll('a');
  for (i = 0; i &lt; as.length; i++) {
    var a = as[i];
    var href = a.getAttribute('href');
    var selection;
    if (!isCyberboticsUrl) {
      var pageIndex = href.indexOf('page=' + localSetup.page);
      // Notes:
      // - the string length test is done to avoid wrong positive cases
      //   where a page is a prefix of another.
      // - 5 matches with the 'page=' string length.
      if (pageIndex &gt; -1 &amp;&amp; (5 + pageIndex + localSetup.page.length) === href.length)
        selection = true;
      else
        selection = false;
    } else {
      var n = href.indexOf('?');
      if (n &gt; -1)
        href = href.substring(0, n);
      n = href.indexOf('#');
      if (n &gt; -1)
        href = href.substring(0, n);
      if (href.endsWith('/doc/' + localSetup.book + '/' + localSetup.page))
        selection = true;
      else
        selection = false;
    }
    if (selection) {
      selected = a.parentNode;
      selected.classList.add('selected');
      if (selected.parentNode.parentNode.tagName.toLowerCase() === 'li') {
        selected.parentNode.parentNode.classList.add('selected');
        var firstChild = selected.parentNode.parentNode.firstChild;
        if (firstChild.tagName.toLowerCase() === 'a')
          showAccodionItem(firstChild);
      } else
        showAccodionItem(a);
      return selected;
    }
  }
}

</t>
<t tx="leo.20210414171924.69">function populateNavigation(selected) {
  var next = document.querySelector('#next');
  var previous = document.querySelector('#previous');
  var up = document.querySelector('#up');
  var toc = document.querySelector('#toc');
  var as;

  toc.setAttribute('href', forgeUrl(localSetup.book, 'menu'));
  addDynamicLoadEvent(toc);

  if (!selected) {
    next.classList.add('disabled');
    previous.classList.add('disabled');
    up.classList.add('disabled');
    return;
  }

  if (next) {
    var nextElement = null;

    var nextLiSibling = selected.nextSibling;
    while (nextLiSibling) {
      if (nextLiSibling.tagName &amp;&amp; nextLiSibling.tagName.toLowerCase() === 'li')
        break;
      nextLiSibling = nextLiSibling.nextSibling;
    }
    if (nextLiSibling) {
      as = nextLiSibling.querySelectorAll('a');
      if (as.length &gt; 0)
        nextElement = as[0];
    }

    if (nextElement) {
      next.classList.remove('disabled');
      next.setAttribute('href', nextElement.getAttribute('href'));
      addDynamicLoadEvent(next);
    } else
      next.classList.add('disabled');
  }

  if (previous) {
    var previousElement = null;

    var previousLiSibling = selected.previousSibling;
    while (previousLiSibling) {
      if (previousLiSibling.tagName &amp;&amp; previousLiSibling.tagName.toLowerCase() === 'li')
        break;
      previousLiSibling = previousLiSibling.previousSibling;
    }
    if (previousLiSibling) {
      as = previousLiSibling.querySelectorAll('a');
      if (as.length &gt; 0)
        previousElement = as[0];
    }

    if (previousElement) {
      previous.classList.remove('disabled');
      previous.setAttribute('href', previousElement.getAttribute('href'));
      addDynamicLoadEvent(previous);
    } else
      previous.classList.add('disabled');
  }

  if (up) {
    var upElement = null;
    var parentLi = null;
    if (selected.parentNode.parentNode.tagName.toLowerCase() === 'li')
      parentLi = selected.parentNode.parentNode;
    if (parentLi) {
      as = parentLi.querySelectorAll('a');
      if (as.length &gt; 0)
        upElement = as[0];
    }

    if (upElement) {
      up.classList.remove('disabled');
      up.setAttribute('href', upElement.getAttribute('href'));
      addDynamicLoadEvent(up);
    } else {
      up.setAttribute('href', forgeUrl(localSetup.book, 'index'));
      addDynamicLoadEvent(up);
      up.classList.remove('disabled');
    }
  }
}

</t>
<t tx="leo.20210414171924.7">function computeTargetPath() {
  var branch = 'master';
  var targetPath = '';
  if (localSetup.branch)
    branch = localSetup.branch;
  if (localSetup.url.startsWith('http'))
    targetPath = localSetup.url + branch + '/docs/';
  targetPath += localSetup.book + '/';
  return targetPath;
}

</t>
<t tx="leo.20210414171924.70">function populateMenu(menu) {
  // make in order that the &lt;li&gt; tags above the &lt;a&gt; are also clickable
  var lis = menu.querySelectorAll('li');
  for (var i = 0; i &lt; lis.length; i++) {
    var li = lis[i];
    li.addEventListener('click',
      @others
}

</t>
<t tx="leo.20210414171924.71">    function(event) {
      var as = event.target.querySelectorAll('a');
      if (as.length &gt; 0)
        aClick(as[0]);
    }
  );
}

var menuDiv = document.querySelector('#menu');
menuDiv.appendChild(menu);

menu.setAttribute('id', 'accordion');
</t>
<t tx="leo.20210414171924.72">$('#accordion &gt; li &gt; a').click(function() {
  showAccodionItem(this);
});
</t>
<t tx="leo.20210414171924.73">function showAccodionItem(item) {
  if (!$(item).hasClass('active')) {
    $('#accordion li ul').slideUp();
    $(item).next().slideToggle();
    $('#accordion li a').removeClass('active');
    $(item).addClass('active');
  }
}

</t>
<t tx="leo.20210414171924.74">function getMDFile() {
  var target = computeTargetPath() + localSetup.page + '.md';
  console.log('Get MD file: ' + target);
  $.ajax({
    type: 'GET',
    url: target,
    dataType: 'text',
    success: populateViewDiv,
    error: function(XMLHttpRequest, textStatus, errorThrown) {
      console.log('Status: ' + textStatus);
      console.log('Error: ' + errorThrown);
      var mainPage = 'index';
      // get the main page instead
      if (localSetup.page !== mainPage) {
        localSetup.page = mainPage;
        getMDFile();
      }
    }
  });
}

</t>
<t tx="leo.20210414171924.75">function getMenuFile() {
  var target = computeTargetPath() + 'menu.md';
  console.log('Get menu file: ' + target);
  $.ajax({
    type: 'GET',
    url: target,
    dataType: 'text',
    success: receiveMenuContent,
    error: function(XMLHttpRequest, textStatus, errorThrown) {
      console.log('Status: ' + textStatus);
      console.log('Error: ' + errorThrown);
    }
  });
}

</t>
<t tx="leo.20210414171924.76">function extractAnchor(url) {
  var match = /#([\w-]+)/.exec(url);
  if (match &amp;&amp; match.length === 2)
    return match[1];
  return '';
}

</t>
<t tx="leo.20210414171924.77">// width: in pixels
function setHandleWidth(width) {
  handle.left.css('width', width + 'px');
  handle.menu.css('width', width + 'px');
  handle.handle.css('left', width + 'px');
  handle.center.css('left', width + 'px');
  handle.center.css('width', 'calc(100% - ' + width + 'px)');
}

</t>
<t tx="leo.20210414171924.78">function initializeHandle() {
  // inspired from: http://stackoverflow.com/questions/17855401/how-do-i-make-a-div-width-draggable
  handle = {}; // structure where all the handle info is stored

  handle.left = $('#left');
  handle.menu = $('#menu');
  handle.center = $('#center');
  handle.handle = $('#handle');
  handle.container = $('#webots-doc');

  // dimension bounds of the handle in pixels
  handle.min = 0;
  handle.minThreshold = 90; // under this threshold, the handle is totally hidden
  handle.initialWidth = Math.max(handle.minThreshold, handle.left.width());
  handle.max = Math.max(250, handle.initialWidth);

  handle.isResizing = false;
  handle.lastDownX = 0;

  if (isCyberboticsUrl) {
    handle.left.addClass('cyberbotics');
    handle.handle.addClass('cyberbotics');
    handle.center.addClass('cyberbotics');
  } else {
    handle.left.addClass('default');
    handle.handle.addClass('default');
    handle.center.addClass('default');
  }

  setHandleWidth(handle.initialWidth);

  @others
}

</t>
<t tx="leo.20210414171924.79">handle.handle.on('mousedown touchstart', function(e) {
  if (e.type === 'touchstart')
    e = e.originalEvent.touches[0];
  handle.isResizing = true;
  handle.lastDownX = e.clientX;
  handle.container.css('user-select', 'none');
}).on('dblclick', function(e) {
  if (handle.left.css('width').startsWith('0'))
    setHandleWidth(handle.initialWidth);
  else
    setHandleWidth(0);
});

</t>
<t tx="leo.20210414171924.8">function redirectUrls(node) {
  // redirect a's href
  var as = node.querySelectorAll('a');
  for (var i = 0; i &lt; as.length; i++) {
    var a = as[i];
    var href = a.getAttribute('href');
    if (!href)
      continue;
    else if (href.startsWith('#'))
      addDynamicAnchorEvent(a); // on firefox, the second click on the anchor is not dealt cleanly
    else if (href.startsWith('http')) // open external links in a new window
      a.setAttribute('target', '_blank');
    else if (href.endsWith('.md') || href.indexOf('.md#') &gt; -1) {
      var match, newPage, anchor;
      if (href.startsWith('../')) { // Cross-book hyperlink case.
        match = /^..\/([\w-]+)\/([\w-]+).md(#[\w-]+)?$/.exec(href);
        if (match &amp;&amp; match.length &gt;= 3) {
          var book = match[1];
          newPage = match[2];
          anchor = match[3];
          if (anchor)
            anchor = anchor.substring(1); // remove the '#' character
          a.setAttribute('href', forgeUrl(book, newPage, localSetup.tabs, anchor));
        }
      } else { // Cross-page hyperlink case.
        addDynamicLoadEvent(a);
        match = /^([\w-]+).md(#[\w-]+)?$/.exec(href);
        if (match &amp;&amp; match.length &gt;= 2) {
          newPage = match[1];
          anchor = match[2];
          if (anchor)
            anchor = anchor.substring(1); // remove the '#' character
          a.setAttribute('href', forgeUrl(localSetup.book, newPage, localSetup.tabs, anchor));
        }
      }
    }
  }
}

</t>
<t tx="leo.20210414171924.80">$(document).on('mousemove touchmove', function(e) {
  if (e.type === 'touchmove')
    e = e.originalEvent.touches[0];
  if (!handle.isResizing)
    return;
  var mousePosition = e.clientX - handle.container.offset().left; // in pixels
  if (mousePosition &lt; handle.minThreshold / 2) {
    setHandleWidth(0);
    return;
  } else if (mousePosition &lt; handle.minThreshold)
    return;
  if (mousePosition &lt; handle.min || mousePosition &gt; handle.max)
    return;
  setHandleWidth(mousePosition);
}).on('mouseup touchend', function(e) {
  handle.isResizing = false;
  handle.container.css('user-select', 'auto');
});
</t>
<t tx="leo.20210414171924.81">window.onscroll = function() {
  if (!isCyberboticsUrl)
    return;
  updateMenuScrollbar();
};

</t>
<t tx="leo.20210414171924.82">document.addEventListener('DOMContentLoaded', function() {
  window.mermaidAPI.initialize({startOnLoad: false});
  initializeHandle();

  if (!isCyberboticsUrl) {
    if (!localSetup.url)
      localSetup.url = getGETQueryValue('url', 'https://raw.githubusercontent.com/cyberbotics/webots/');
    if (!localSetup.book)
      localSetup.book = getGETQueryValue('book', 'guide');
    if (!localSetup.page)
      localSetup.page = getGETQueryValue('page', 'index');
    if (!localSetup.anchor)
      localSetup.anchor = window.location.hash.substring(1);
    if (!localSetup.branch)
      localSetup.branch = getGETQueryValue('branch', 'master');
    if (!localSetup.tabs)
      localSetup.tabs = getGETQueriesMatchingRegularExpression('^tab-\\w+$', 'g');
    // backward compatibility &lt;= R2019b revision 1
    if (!localSetup.tabs['tab-language']) {
      if (localSetup.tab) {
        localSetup.tabs['tab-language'] = localSetup.tab;
        delete localSetup.tab;
      } else
        localSetup.tabs['tab-language'] = getGETQueryValue('tab', '').toLowerCase();
    }
  }

  // prevent FOUC for blog
  if (localSetup.book === 'blog') {
    var center = document.querySelector('#center');
    center.setAttribute('class', 'blog');
    setHandleWidth(0);
  }

  addContributionBanner();
  setupModalWindow();
  applyToTitleDiv();
  getMDFile();
  getMenuFile();
});
</t>
<t tx="leo.20210414171924.9">function collapseMovies(node) {
  if (location.href.startsWith('file:')) { // if it's the offline documentation embedded in Webots (possibly without network):
    var iframes = node.querySelectorAll('iframe');
    for (var i = 0; i &lt; iframes.length; i++) { // foreach iframe:
      var iframe = iframes[i];
      var src = iframe.getAttribute('src');
      if (src &amp;&amp; src.indexOf('youtube')) { // if the iframe is a youtube frame:
        // then, replace the iframe by a text and an hyperlink to the youtube page.
        src = src.replace(/embed\/(.*)\?rel=0/, 'watch?v=$1'); // e.g. https://www.youtube.com/embed/vFwNwT8dZTU?rel=0 to https://www.youtube.com/watch?v=vFwNwT8dZTU
        var p = document.createElement('p');
        p.innerHTML = '&lt;a href="' + src + '"&gt;Click here to see the youtube movie.&lt;/a&gt;';
        iframe.parentNode.replaceChild(p, iframe);
      }
    }
  }
}

</t>
<t tx="leo.20210414171942.1">/* global showdown */

// function allowing to convert some text to its slug
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20210414171955.1">function wbSlugify(obj) {
  var text = '';
  if (typeof obj === 'string')
    text = obj;
  else if (obj instanceof HTMLElement)
    text = obj.textContent;
  else
    console.error('wbSlugify: Unsupported input');

  return text
    .trim()
    .toLowerCase()
    .replace(/[\s.:]/g, '-')
    .replace(/[-]+/g, '-')
    .replace(/^-*/, '')
    .replace(/-*$/, '')
    .replace('+', 'p')
    .replace(/[^\w-]+/g, '');
}

// This extension is a template-like mechanism, allowing
// to replace variables by a static content.
</t>
<t tx="leo.20210414171955.10">//     `![battery.png](images/battery.png) In this example, etc.`
showdown.extension('wbIllustratedSection', function() {
  return [
    {
      type: 'lang',
      filter: function(text, converter, options) {
        text = text.replace(/\n(!\[[^\]]*\]\s*\([^)]*\)) +([^]+?)(?=\n\n)/gi, function(match, image, content) {
          var htmlImage = converter.makeHtml(image);
          if (htmlImage.startsWith('&lt;p&gt;') &amp;&amp; htmlImage.endsWith('&lt;/p&gt;')) // Remove useless 'p' encapsulation.
            htmlImage = htmlImage.substr(3, htmlImage.length - 7);
          var htmlContent = converter.makeHtml(content);
          return '&lt;section class="illustrated-section"&gt;' + htmlImage + htmlContent + '&lt;/section&gt;';
        });
        return text;
      }
    }
  ];
});

</t>
<t tx="leo.20210414171955.11"></t>
<t tx="leo.20210414171955.12">// This extension allows to define graph using mermaidJS
showdown.extension('wbChart', function() {
  return [
    { // chart with legend to HTML
      type: 'lang',
      filter: function(text, converter, options) {
        text = text.replace(/%chart\s+([^"][^]+?)%end/gi, function(match, content) {
          // handle links
          @others
        });
        return text;
      }
    }
  ];
});

</t>
<t tx="leo.20210414171955.13"></t>
<t tx="leo.20210414171955.14">content = content.replace(/\[\[(.+?)\]\((.+?)\)/gi, function(match, name, link) {
  return '[&lt;a href=' + link + '&gt;' + name + '&lt;/&gt;';
});
</t>
<t tx="leo.20210414171955.15">content = content.replace(/\[(.+?)\]\((.+?)\)/gi, function(match, name, link) {
  return '&lt;a href=' + link + '&gt;' + name + '&lt;/&gt;';
});
// save content
var id = 'mermaidGraph' + window.mermaidGraphCounter;
window.mermaidGraphCounter++;
window.mermaidGraphs[id] = content;
return '&lt;div id="' + id + 'Div' + '" class="mermaid"&gt;&lt;/div&gt;';
</t>
<t tx="leo.20210414171955.16">// This extension allows to define extensible part (hided by default)
showdown.extension('wbSpoiler', function() {
  return [
    {
      type: 'lang',
      filter: function(text, converter, options) {
        text = text.replace(/%spoiler\s*\"(.*)\"\n(^(?:(?!%end).+\n*)*\n)*\n%end/gim, function(match, title, content) {
          var replacement =
            '&lt;details&gt;\n' +
            '  &lt;summary&gt;' + title + '&lt;/summary&gt;\n' +
            '  ' + content + '\n' +
            '&lt;/details&gt;\n';
          return replacement;
        });
        return text;
      }
    }
  ];
});

// This extension allows to add robot component.
</t>
<t tx="leo.20210414171955.17"></t>
<t tx="leo.20210414171955.18">// Example: "%robot nao"
showdown.extension('wbRobotComponent', function() {
  return [
    {
      type: 'lang',
      filter: function(text, converter, options) {
        text = text.replace(/%robot\s+([^ \n]+)\s+([^ \n]+)/gi, function(match, robot, imageFallback) {
          var replacement = '';
          if (location.href.startsWith('file:')) {
            // offline documentation embedded in Webots.
            // Ogre, webgl (QWebKit) are not working smoothly together: the image image fallback is used instead.
            replacement =
              '%figure\n\n' +
              '![](' + imageFallback + ')\n\n' +
              '%end\n';
          } else {
            replacement =
              '&lt;div id="%ROBOT%-robot-component" class="robot-component"&gt;\n' +
              '  &lt;div id="%ROBOT%-robot-view" class="robot-view"&gt;\n' +
              '    &lt;div id="%ROBOT%-robot-webots-view" class="robot-webots-view"&gt;\n' +
              '    &lt;/div&gt;\n' +
              '    &lt;div class="menu"&gt;\n' +
              '      &lt;div class="menu-items"&gt;\n' +
              '        &lt;button class="reset-button" title="Reset Viewpoint and sliders." onclick="resetRobotComponent(\'%ROBOT%\')"&gt;&lt;/button&gt;\n' +
              '        &lt;button class="menu-button" title="Show/Hide the device list." onclick="toggleDeviceComponent(\'%ROBOT%\')"&gt;&lt;/button&gt;\n' +
              '        &lt;button class="fullscreen-button" title="Enter/Leave full-screen." onclick="toogleRobotComponentFullScreen(\'%ROBOT%\')"&gt;&lt;/button&gt;\n' +
              '      &lt;/div&gt;\n' +
              '    &lt;/div&gt;\n' +
              '  &lt;/div&gt;\n' +
              '  &lt;div id="%ROBOT%-device-component" class="device-component"&gt;&lt;/div&gt;\n' +
              '&lt;/div&gt;\n';
            replacement = replacement.replace(/%ROBOT%/g, robot);
          }
          return replacement;
        });
        return text;
      }
    }
  ];
});

// This extension allows to add a tab component with custom tab labels.
// Example:
//
//     %tab-component
//     %tab "Title 1"
//     |                        |
//     |------------------------|
//     | It could be a table... |
//     %tab-end
//     %tab "Title 2"
//     ```java
//     // It could be code...
//     ```
//     %tab-end
//     %tab "Title 3"
//     &gt; It could be notes...
//     %tab-end
//     %end
</t>
<t tx="leo.20210414171955.19"></t>
<t tx="leo.20210414171955.2">// For example, the markdown string '{{ date.year }}' is replaced by '2016'
showdown.extension('wbVariables', function() {
  // static variables to maintain
  // TODO: could be computed
  var vars = {
    webots: {
      version: {
        major: 'R2021a',
        // full is equal to major for the first major version
        // and contains the revision number for subsequent versions
        full: 'R2021a',
        package: 'R2021a'
      }
    },
    date: {
      year: 2021
    }
  };

  // compute debian package version format by removing initial 'R'
  vars.webots.version.debian_package = vars.webots.version.package.substring(1);

  return [
    { // replace '{{ var }}' by the vars dictionary above
      type: 'html',
      regex: /\{\{([^]+?)\}\}/gi,
      replace: function(match, content) {
        var key = content.replace(/\s/g, ''); // remove spaces
        try {
          // cf: http://stackoverflow.com/questions/6393943/convert-javascript-string-in-dot-notation-into-an-object-reference
          var value = key.split('.').reduce(function(obj, i) { return obj[i]; }, vars);
          if (value === undefined) {
            console.error('wbVariables: Undefined value');
            return '';
          }
          return value;
        } catch (err) {
          console.log('Variable "' + key + '" not found: ' + err);
          return key;
        }
      }
    }
  ];
});

// This extension is dealing with some figure content (data with legend having an anchor)
// For example, the markdown string `%figure 'legend'\ncontent\n%end` is replaced by
</t>
<t tx="leo.20210414171955.20">//
showdown.extension('wbTabComponent', function() {
  var tabComponentCounter = 0;
  return [
    {
      type: 'lang',
      filter: function(text, converter, options) {
        text = text.replace(/%tab-component\s+"([^]+?)"([^]+?)%end/gi, function(match, tabTitle, content) {
          tabComponentCounter++;
          var buttons = '';
          var first = true;
          @others
        });
        return text;
      }
    }
  ];
});
</t>
<t tx="leo.20210414171955.21"></t>
<t tx="leo.20210414171955.22">var subText = content.replace(/%tab\s+"([^]+?)"([^]+?)%tab-end/gi, function(subMatch, title, subContent) {
  buttons += '&lt;button name="' + title.toLowerCase() + '" class="tab-links' + (first ? ' active' : '') + '" onclick="openTabFromEvent(event, \'tab-' + tabTitle + '\', \'' + title + '\')"&gt;' + title + '&lt;/button&gt;';
  var result = '&lt;div class="tab-content" name="' + title.toLowerCase() + '"' + (first ? ' style="display:block"' : '') + ' tabid="' + tabComponentCounter + '"&gt;' + converter.makeHtml(subContent) + '&lt;/div&gt;';
  first = false;
  return result;
});
return '&lt;div class="tab-component" tabid="' + tabComponentCounter + '"&gt;' + buttons + '&lt;/div&gt;' + subText;
</t>
<t tx="leo.20210414171955.3">// '&lt;figure&gt;content&lt;figcaption&gt;legend&lt;/figcaption&gt;&lt;/figure&gt;'
showdown.extension('wbFigure', function() {
  return [
    { // figure with legend to HTML
      type: 'lang',
      filter: function(text, converter, options) {
        @others
});

</t>
<t tx="leo.20210414171955.4">    text = text.replace(/%figure\s+"([^]+?)"([^]+?)%end/gi, function(match, title, content) {
      var foo = converter.makeHtml(content);
      return '&lt;figure name="' + wbSlugify(title) + '"&gt;' + foo + '&lt;figcaption&gt;' + title + '&lt;/figcaption&gt;&lt;/figure&gt;';
    });
    return text;
  }
},
{ // figure without legend to HTML
  type: 'lang',
  filter: function(text, converter, options) {
</t>
<t tx="leo.20210414171955.5">      text = text.replace(/%figure\s+([^"][^]+?)%end/gi, function(match, content) {
        console.log('content ' + content);
        var foo = converter.makeHtml(content);
        return '&lt;figure&gt;' + foo + '&lt;/figure&gt;';
      });
      return text;
    }
  },
  { // remove &lt;p&gt; tags inside the &lt;figure&gt; tag
    type: 'html',
    regex: /&lt;figure([^&gt;]*)&gt;&lt;p&gt;&lt;img([^]+?)&lt;\/p&gt;/gi,
    replace: function(match, args, content) {
      return '&lt;figure' + args + '&gt;&lt;img' + content;
    }
  }
];
</t>
<t tx="leo.20210414171955.6">// This extension is dealing with some API content
showdown.extension('wbAPI', function() {
  return [
    { // api tag to HTML
      type: 'lang',
      filter: function(text, converter, options) {
        @others
});

// This extension is defining an id with a custom slug on the headers and on the figures
// Note: showdown is already generating the ids with a slug function, but only for
</t>
<t tx="leo.20210414171955.7">    text = text.replace(/%api\s+"([^]+?)"([^]+?)%end/gi, function(match, anchor, content) {
      var foo = converter.makeHtml(content);
      return '&lt;div name="' + anchor + '" class="api"&gt;' + foo + '&lt;/div&gt;';
    });
    return text;
  }
},
{ // '#### `.*`' to h[4|5] + "api-title" class
  type: 'lang',
  filter: function(text, converter, options) {
</t>
<t tx="leo.20210414171955.8">      text = text.replace(/(#{4,5}) `([^`\n]+?)`\n/gi, function(match, hashes, content) {
        return '&lt;h' + hashes.length + ' name="' + content + '" class="api-title"&gt;' + content + '&lt;/h' + hashes.length + '&gt;';
      });
      return text;
    }
  }
];
</t>
<t tx="leo.20210414171955.9">// headers, and without hyphens.
showdown.extension('wbAnchors', function() {
  return [
    {
      type: 'html',
      regex: /&lt;h(\d)\s([^&gt;]*)&gt;([^]+?)&lt;\/h(\d)&gt;/gi,
      replace: function(match, level1, args, content, level2) {
        if (level1 !== level2) {
          console.error('wbAnchors: level mismatch');
          return '';
        }

        var tmpDiv = document.createElement('DIV');
        tmpDiv.innerHTML = content;
        var rawContent = tmpDiv.textContent || tmpDiv.innerText || '';

        return '&lt;h' + level1 + ' name="' + wbSlugify(rawContent) + '" ' + args + '&gt;' + content + '&lt;/h' + level1 + '&gt;';
      }
    }
  ];
});

// This extension allows to define an illustrated section, simply if a paragraph is starting with an image:
// e.g:
</t>
<t tx="leo.20210414172143.1"></t>
<t tx="leo.20210414172153.1">@language md
@tabwidth -4
</t>
<t tx="leo.20210414172209.1"></t>
<t tx="leo.20210414172209.2">
%robot ure images/robots/ure/model.thumbnail.png

The Universal Robots [UR3e](https://www.universal-robots.com/products/ur3-robot/), [UR5e](https://www.universal-robots.com/products/ur5-robot/) and [UR10e](https://www.universal-robots.com/products/ur10-robot/) are flexible collaborative robot arms with 6 degrees of freedom.

The Universal Robots UR3e, UR5e and UR10e models in Webots are fully compatible with ROS.

These robot models and controllers are sponsored by the [ROSin european project](http://rosin-project.eu/ftp/cross-platform-ros-simulation-for-mobile-manipulators).

</t>
<t tx="leo.20210414172209.3">
![youtube video](https://www.youtube.com/watch?v=WIY9ebqSXUc)

</t>
<t tx="leo.20210414172209.4">
Derived from [Robot](../reference/robot.md).

```
UR5e/UR5e/UR10e {
  SFVec3f    translation     0 0 0
  SFRotation rotation        1 0 0 4.712388966
  SFString   name            "UR5e"
  SFString   controller      "void"
  MFString   controllerArgs  []
  SFBool     supervisor      FALSE
  SFBool     synchronization TRUE
  SFBool     selfCollision   TRUE
  MFNode     toolSlot        []
  SFBool     staticBase      TRUE
}
```

&gt; **File location**: "[WEBOTS\_HOME/projects/robots/universal\_robots/protos/UR3e.proto](https://github.com/cyberbotics/webots/tree/master/projects/robots/universal_robots/protos/UR3e.proto)", "[WEBOTS\_HOME/projects/robots/universal\_robots/protos/UR5e.proto](https://github.com/cyberbotics/webots/tree/master/projects/robots/universal_robots/protos/UR5e.proto)" and "[WEBOTS\_HOME/projects/robots/universal\_robots/protos/UR10e.proto](https://github.com/cyberbotics/webots/tree/master/projects/robots/universal_robots/protos/UR10e.proto)"

</t>
<t tx="leo.20210414172209.5">
- `toolSlot`: Extend the robot with new nodes at the end of the arm.

- `staticBase`: Defines if the robot base should be pinned to the static environment.

</t>
<t tx="leo.20210414172209.6">
You will find the following sample in this folder: "[WEBOTS\_HOME/projects/robots/universal\_robots/worlds](https://github.com/cyberbotics/webots/tree/master/projects/robots/universal_robots/worlds)".

</t>
<t tx="leo.20210414172209.7">
![ure.wbt.png](images/robots/ure/ure.wbt.thumbnail.jpg) This simulation shows an UR3e, an UR5e and an UR10e robot, equipped with a [ROBOTIQ 3F Gripper](gripper-actuators.md#robotiq-3f-gripper), grabbing cans on conveyor belts and putting them in crates.

</t>
<t tx="leo.20210414172209.8">
To use ROS with the simulated UR3e/UR5e/UR10e robot in Webots, the `&lt;extern&gt;` controller should be assigned to the robot.
Then the `ur_e_webots` ROS package located in "[WEBOTS\_HOME/projects/robots/universal\_robots/resources/ros\_package/ur\_e\_webots](https://github.com/cyberbotics/webots/tree/master/projects/robots/universal_robots/resources/ros_package/ur_e_webots)" should be copied into your catkin workspace.

Once `roscore` is started the `ur5e` (replace `5` by `3` or `10` for the UR3e or UR10e) node of the `ur_e_webots` package can be launched:
```
roslaunch ur_e_webots ur5e.launch
```

The simulation can now be started.

</t>
<t tx="leo.20210414172209.9">
Thanks to the [universal\_robot](http://wiki.ros.org/universal_robot) ROS package, MoveIt! can be used for motion planning. It can be started with the following launch file:
```
roslaunch ur5_e_moveit_config ur5_e_moveit_planning_execution.launch
```
Finally, to start RViz with a configuration including the MoveIt! Motion Planning plugin, run:
```
roslaunch ur5_e_moveit_config moveit_rviz.launch config:=true
```

&gt; **Note**: As MoveIt! seems to have difficulties with finding plans for the robot with full joint limits [-2pi, 2pi], there is a joint_limited version using joint limits restricted to [-pi,pi]. In order to use this joint limited version, simply use instead the `ur5e_joint_limited` launch file instead of the `ur5e.launch` one, i.e.: `roslaunch ur_e_webots ur5e_joint_limited.launch`
</t>
<t tx="leo.20210414172957.1">// This extension allows to add robot component.
// Example: "%robot nao"
showdown.extension('wbRobotComponent', function() {
  return [
    {
      type: 'lang',
      filter: function(text, converter, options) {
        text = text.replace(/%robot\s+([^ \n]+)\s+([^ \n]+)/gi, function(match, robot, imageFallback) {
          var replacement = '';
          if (location.href.startsWith('file:')) {
            // offline documentation embedded in Webots.
            // Ogre, webgl (QWebKit) are not working smoothly together: the image image fallback is used instead.
            replacement =
              '%figure\n\n' +
              '![](' + imageFallback + ')\n\n' +
              '%end\n';
          } else {
            replacement =
              '&lt;div id="%ROBOT%-robot-component" class="robot-component"&gt;\n' +
              '  &lt;div id="%ROBOT%-robot-view" class="robot-view"&gt;\n' +
              '    &lt;div id="%ROBOT%-robot-webots-view" class="robot-webots-view"&gt;\n' +
              '    &lt;/div&gt;\n' +
              '    &lt;div class="menu"&gt;\n' +
              '      &lt;div class="menu-items"&gt;\n' +
              '        &lt;button class="reset-button" title="Reset Viewpoint and sliders." onclick="resetRobotComponent(\'%ROBOT%\')"&gt;&lt;/button&gt;\n' +
              '        &lt;button class="menu-button" title="Show/Hide the device list." onclick="toggleDeviceComponent(\'%ROBOT%\')"&gt;&lt;/button&gt;\n' +
              '        &lt;button class="fullscreen-button" title="Enter/Leave full-screen." onclick="toogleRobotComponentFullScreen(\'%ROBOT%\')"&gt;&lt;/button&gt;\n' +
              '      &lt;/div&gt;\n' +
              '    &lt;/div&gt;\n' +
              '  &lt;/div&gt;\n' +
              '  &lt;div id="%ROBOT%-device-component" class="device-component"&gt;&lt;/div&gt;\n' +
              '&lt;/div&gt;\n';
            replacement = replacement.replace(/%ROBOT%/g, robot);
          }
          return replacement;
        });
        return text;
      }
    }
  ];
});</t>
<t tx="leo.20210414173045.1"></t>
<t tx="leo.20210414173045.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20210414173045.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20210414173734.1"></t>
<t tx="leo.20210414180353.1">Webots Open source first public version:

https://github.com/cyberbotics/webots/tree/8364fc97662b6278e01e1da1c1a96fd1009017f1

very first public commit page: https://github.com/cyberbotics/webots/commits/master?after=f66a3e251b21c43b2f27d5d6626db39ab856ccf5+12515&amp;branch=master</t>
<t tx="leo.20210414180847.1"></t>
<t tx="leo.20210414180856.1">/*
 * Injects a Webots 3D view inside a HTML tag.
 * @class
 * @classdesc
 *   The Webots view object displays a 3D view on a web page.
 *   This view represents a Webots simulation world that may be
 *   connected to a webots instance running on a remote server.
 *   This library depends on the x3dom-full.js library
 * @example
 *   // Example: Initialize from a Webots streaming server
 *   var view = new webots.View(document.getElementById("myDiv"));
 *   view.open("ws://localhost:80/simple/worlds/simple.wbt");
 *   // or view.open("ws://localhost:80");
 *   // or view.open("file.x3d");
 *   view.onready = function() {
 *       // the initialization is done
 *   }
 *   view.onclose = function() {
 *       view = null;
 *   }
 */

var webots = webots || {};

var scripts = document.getElementsByTagName('script');
webots.WwiUrl = scripts[scripts.length - 1].src;
webots.WwiUrl = webots.WwiUrl.substr(0, webots.WwiUrl.lastIndexOf('/') + 1); // remove "webots.js"
webots.Owner = null;

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20210414180912.1">webots.View = function(view3D) {
  webots.currentView = this;
  var that = this;
  @others
}

</t>
<t tx="leo.20210414180912.10">$(document).bind("keydown keypress", function(e) {
  if (e.which == 8) { // backspace key
    if (!rx.test(e.target.tagName) || e.target.disabled || e.target.readOnly)
      e.preventDefault();
  }
});
this.view3D.className = view3D.className + ' webotsView';
$(this.view3D).append(
  "&lt;ul id='contextMenu'&gt;" +
  "&lt;li class='ui-widget-header'&gt;&lt;div id='contextMenuTitle'&gt;Object&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuFollow'&gt;&lt;div&gt;Follow&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuUnfollow'&gt;&lt;div&gt;Unfollow&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Zoom&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuRobotWindow'&gt;&lt;div id='contextMenuRobotWindowDiv'&gt;Robot window&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuEditController'&gt;&lt;div id='contextMenuEditControllerDiv'&gt;Edit controller&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Delete&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Properties&lt;/div&gt;&lt;/li&gt;" +
  "&lt;/ul&gt;");
$('#contextMenu').menu({items: '&gt; :not(.ui-widget-header)'});
$('#contextMenu').css('position', 'absolute');
$('#contextMenu').css('z-index', 1);
$('#contextMenu').css('display','none');
</t>
<t tx="leo.20210414180912.100">function webotsEnablePointerEvents() {
  document.body.style['pointer-events'] = 'auto';
}

</t>
<t tx="leo.20210414180912.101">webots.Editor = function(parent,view) {
  that = this;
  @others
}

</t>
<t tx="leo.20210414180912.102">function webotsEditorResize() {
  var padding = $('#webotsEditorTab').outerHeight() - $('#webotsEditorTab').height();
  $("#webotsEditorTab").height(that.tabs.clientHeight - that.tabsHeader.scrollHeight - padding);
  that.editor.resize();
}
</t>
<t tx="leo.20210414180912.103">function hideMenu() {
  if ($('#webotsEditorMenu').hasClass("pressed"))
    $('#webotsEditorMenu').removeClass("pressed");
}
</t>
<t tx="leo.20210414180912.104">function openResetConfirmDialog(allFiles) {
  that.resetAllFiles = allFiles;
  var titleText, message;
  message = "Permanently reset ";
  if (allFiles) {
    message += "all the files"
    titleText = "Reset files?";
  } else {
    message += "this file"
    titleText = "Reset file?";
  }
  message += " to the original version?";
  message += "&lt;br/&gt;&lt;br/&gt;Your modifications will be lost.";
  var confirmDialog = document.createElement('div');
  that.panel.appendChild(confirmDialog);
  $(confirmDialog).html(message);
  $(confirmDialog).dialog({
    title: titleText,
    modal: true,
    autoOpen: true,
    resizable: false,
    dialogClass: "alert",
    open: webotsOpenDialog,
    appendTo: that.parent,
    buttons: {
      "Cancel": function() {
        $(this).dialog('close');
        $("#webotsEditorConfirmDialog").remove();
      },
      "Reset": function() {
        $(this).dialog('close');
        $("#webotsEditorConfirmDialog").remove();
        if (that.resetAllFiles) {
          for (var i = 0; i &lt; that.filenames.length; i++)
            that.view.server.resetController(that.dirname + '/' + that.filenames[i]);
        } else
          that.view.server.resetController(that.dirname + '/' + that.filenames[that.currentSession]);
      }
    }
  });
  hideMenu();
}
this.view = view;
this.filenames = [];
this.needToUploadFiles = [];
this.sessions = [];
this.panel = document.createElement('div');
this.panel.id = 'webotsEditor';
this.panel.className = 'webotsTabContainer';
that.parent = parent;
parent.appendChild(this.panel);
var clampedSize = webotsClampDialogSize({left: 0, top : 0, width: 800, height: 600});
$('#webotsEditor').dialog({title: 'Editor', resize: webotsEditorResize, resizeStart: webotsDisablePointerEvents,
  resizeStop: webotsEnablePointerEvents, dragStart: webotsDisablePointerEvents, dragStop: webotsEnablePointerEvents,
  width: clampedSize.width, height: clampedSize.height, autoOpen: false, appendTo: parent, open: webotsOpenDialog}).dialogExtend({maximizable : true});
var edit = document.createElement('div');
edit.id = 'webotsEditorTab';
edit.className = 'webotsTab';
this.editor = ace.edit(edit);
this.sessions[0] = this.editor.getSession();
this.currentSession = 0;
this.tabs = document.createElement('div');
this.tabs.id = 'webotsEditorTabs';
this.tabs.className = 'webotsTabs';
this.tabsHeader = document.createElement('ul');
this.tabs.appendChild(this.tabsHeader);
this.tabs.appendChild(edit);
$(this.tabs).tabs({activate: function(event, ui) {
  that.currentSession = parseInt(ui.newTab.attr('id').substr(5)); // skip 'file-'
  that.editor.setSession(that.sessions[that.currentSession]);
}});
this.panel.appendChild(this.tabs);
this.menu = document.createElement('div');
this.menu.id = 'webotsEditorMenu';
var saveShortcut;
if (navigator.appVersion.indexOf("Mac") == -1)
  saveShortcut = "Ctrl-S";
else // macOS
  saveShortcut = "Cmd-S";
this.menu.innerHTML = '&lt;input type="image" id="webotsEditorMenuImage" width="17px" src="' + webots.WwiUrl + '/images/menu.png"&gt;' +
                      '&lt;div id="webotsEditorMenuContent"&gt;' +
                      '&lt;div id="webotsEditorSaveAction" class="webotsEditorMenuContentItem" title="Save current file"&gt;Save&lt;span style="float:right"&gt;&lt;i&gt;&lt;small&gt;' + saveShortcut + '&lt;/small&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;' +
                      '&lt;div id="webotsEditorSaveAllAction" class="webotsEditorMenuContentItem" title="Save all the files"&gt;Save All&lt;/div&gt;' +
                      '&lt;div id="webotsEditorResetAction" class="webotsEditorMenuContentItem" title="Reset current file to the original version"&gt;Reset&lt;/div&gt;' +
                      '&lt;div id="webotsEditorResetAllAction" class="webotsEditorMenuContentItem" title="Reset all the files to the original version"&gt;Reset All&lt;/div&gt;' +
                      '&lt;/div&gt;';
this.panel.appendChild(this.menu);
this.editor.commands.addCommand({
  name: 'save',
  bindKey: {win: "Ctrl-S", mac: "Cmd-S"},
  exec: function(editor) {
    that.save(that.currentSession);
  }
});
</t>
<t tx="leo.20210414180912.105">$('#webotsEditorSaveAction').click(function() {
  that.save(that.currentSession);
  hideMenu();
});
</t>
<t tx="leo.20210414180912.106">$('#webotsEditorSaveAllAction').click(function() {
  for (var i = 0; i &lt; that.filenames.length; i++)
    that.save(i);
  hideMenu();
});
</t>
<t tx="leo.20210414180912.107">$('#webotsEditorResetAction').click(function() {
  openResetConfirmDialog(false)
});
</t>
<t tx="leo.20210414180912.108">$('#webotsEditorResetAllAction').click(function() {
  openResetConfirmDialog(true)
});
</t>
<t tx="leo.20210414180912.109">$('#webotsEditorMenuImage').click(function() {
  if ($('#webotsEditorMenu').hasClass("pressed"))
    $('#webotsEditorMenu').removeClass("pressed");
  else
    $('#webotsEditorMenu').addClass("pressed");
});
</t>
<t tx="leo.20210414180912.11">$("#contextMenu").on("menuselect", function(event, ui) {
  if (ui.item.children().hasClass('ui-state-disabled'))
    return;
  id = ui.item.attr('id');
  if (id == 'contextMenuFollow')
    that.follow(that.selection.id);
  else if (id == 'contextMenuUnfollow')
    that.follow('none');
  else if (id == 'contextMenuEditController') {
    var controller = that.selection.getAttribute('controller');
    $('#webotsEditor').dialog('open');
    $('#webotsEditor').dialog('option', 'title', 'Controller: ' + controller);
    if (that.editor.dirname != controller) {
      that.editor.closeAllTabs();
      that.editor.dirname = controller;
      that.stream.socket.send('get controller:' + controller);
    }
  } else if (id == 'contextMenuRobotWindow') {
    robotName = that.selection.getAttribute('name');
    win = that.robotWindows[that.robotWindowNames[robotName]];
    if (win) {
      if (win == that.infoWindow) {
        if (!that.infoWindow.isOpen())
          toggleInfo();
      } else
        win.open();
    } else
      console.log("No valid robot window for robot: " + that.selection.getAttribute('name'));
  } else
    console.log("Unknown menu item: " + id);
  $('#contextMenu').css('display','none');
});
this.console = new webots.Console(view3D);
this.editor = new webots.Editor(view3D, this);
this.infoWindow = null;
this.selection = null;
this.x3dScene = null;
this.x3dNode = null;
this.initialMouseX = 0;
this.initialMouseY = 0;
this.mouseMoveInitialized = false;
this.pickPosition = null;
this.animation = null;
this.enableNavigation = true;
this.mouseDown = 0;
this.mouseMove = false;
this.debug = false;
this.timeout = 60 * 1000; // default to one minute
this.time = undefined;
this.deadline = this.timeout;
this.runOnLoad = false;
this.quitting = false;
</t>
<t tx="leo.20210414180912.110">$("#webotsEditorMenu").focusout(function() {
  // let the time to handle the menu actions if needed
  window.setTimeout(function() {
    if ($(".webotsEditorMenuContentItem:hover").length &gt; 0)
      return;
    if ($('#webotsEditorMenu').hasClass("pressed"))
      $('#webotsEditorMenu').removeClass("pressed");
  }, 100);
});
</t>
<t tx="leo.20210414180912.111"></t>
<t tx="leo.20210414180912.112">webots.Editor.prototype.hasUnsavedChanges = function() {
  for(var i = 0; i &lt; this.filenames.length; i++) {
    if ($('#filename-' + i).html().endsWith('*'))
      return true;
  }
  return false;
}

</t>
<t tx="leo.20210414180912.113">webots.Editor.prototype.storeUserFile = function(i) {
  var formData = new FormData();
  formData.append('dirname', this.view.server.project + '/controllers/' + this.dirname);
  formData.append('filename', this.filenames[i]);
  formData.append('content', this.sessions[i].getValue());
  $.ajax({
    url: '/ajax/upload-file.php',
    type: 'POST',
    data: formData,
    processData: false,
    contentType: false,
    success: function(data) {
      if (data != 'OK')
        webots.alert("File saving error", data);
    }
  });
}

</t>
<t tx="leo.20210414180912.114">webots.Editor.prototype.upload = function(i) { // upload to the simulation server
  this.view.stream.socket.send('set controller:'
    + this.dirname + '/'
    + this.filenames[i] + ':'
    + this.sessions[i].getLength() + '\n'
    + this.sessions[i].getValue());
  this.needToUploadFiles[i] = false;
}

</t>
<t tx="leo.20210414180912.115">webots.Editor.prototype.save = function(i) { // save to the web site
  if ($('#filename-' + i).html().endsWith('*')) { // file was modified
    $('#filename-' + i).html(this.filenames[i]);
    this.needToUploadFiles[i] = true;
    if (webots.userCredentials()) // user logged in
      this.storeUserFile(i);
    else
      this.view.unloggedFileModified = true;

    if (this.view.time == 0)
      this.upload(i);
    else {
      if (!this.statusMessage) {
        this.statusMessage = document.createElement('div');
        this.statusMessage.id = 'webotsEditorStatusMessage';
        this.statusMessage.className = 'webotsEditorStatusMessage';
        this.statusMessage.innerHTML = "&lt;font size=\"2\"&gt;Reload the simulation to apply the changes.&lt;/font&gt;";
      }
      this.panel.appendChild(this.statusMessage);
      setTimeout(this.hideReloadMessage, 1500);
    }
  }
}

</t>
<t tx="leo.20210414180912.116">webots.Editor.prototype.hideReloadMessage = function() {
  $("#webotsEditorStatusMessage").remove();
}

</t>
<t tx="leo.20210414180912.117">webots.Editor.prototype.textChange = function(index) {
  if (!$('#filename-' + index).html().endsWith('*') &amp;&amp; that.editor.curOp &amp;&amp; that.editor.curOp.command.name) { // user change
    $('#filename-' + index).html(that.filenames[index] + '*');
  }
}

</t>
<t tx="leo.20210414180912.118">webots.Editor.prototype.aceMode = function(filename) {
  if (filename.toLowerCase() == 'makefile')
    return 'ace/mode/makefile';
  var extension = filename.split('.').pop().toLowerCase();
  if (extension == 'py')
    return 'ace/mode/python';
  if (extension == 'c' || extension == 'cpp' || extension == 'c++' || extension == 'cxx' || extension == 'cc' ||
      extension == 'h' || extension == 'hpp' || extension == 'h++' || extension == 'hxx' || extension == 'hh')
    return 'ace/mode/c_cpp';
  if (extension == 'java')
    return 'ace/mode/java';
  if (extension == 'm')
    return 'ace/mode/matlab';
  if (extension == 'json')
    return 'ace/mode/json';
  if (extension == 'xml')
    return 'ace/mode/xml';
  if (extension == 'yaml')
    return 'ace/mode/yaml';
  if (extension == 'ini')
    return 'ace/mode/ini';
  if (extension == 'html')
    return 'ace/mode/html';
  if (extension == 'js')
    return 'ace/mode/javascript';
  if (extension == 'css')
    return 'ace/mode/css';
  return 'ace/mode/text';
}

</t>
<t tx="leo.20210414180912.119">webots.Editor.prototype.addFile = function(filename, content) {
  var index = this.filenames.indexOf(filename);
  if (index &gt;= 0) {
    this.needToUploadFiles[index] = false; // just received from the simulation server
    this.sessions[index].setValue(content);
    if ($('#filename-' + index).html().endsWith('*'))
      $('#filename-' + index).html(filename);
    if (webots.userCredentials())
      this.storeUserFile(index);
    return;
  }

  index = this.filenames.length;
  this.filenames.push(filename);
  this.needToUploadFiles[index] = false;
  if (index == 0) {
    this.sessions[index].setMode(this.aceMode(filename));
    this.sessions[index].setValue(content);
    $("#webotsEditorMenu").show();
    $("#webotsEditorTabs").show();
  } else
    this.sessions.push(ace.createEditSession(content, this.aceMode(filename)));
  this.sessions[index].on('change', function(e) { that.textChange(index); });
  $("div#webotsEditorTabs ul").append("&lt;li id='file-" + index + "'&gt;&lt;a href='#webotsEditorTab' id='filename-" + index + "'&gt;" + filename + "&lt;/a&gt;&lt;/li&gt;");
  $("div#webotsEditorTabs").tabs("refresh");
  if (index == 0)
    $("div#webotsEditorTabs").tabs("option", "active", index);
}

</t>
<t tx="leo.20210414180912.12">webots.View.prototype.setTimeout = function(timeout) { // expressed in seconds
  if (timeout &lt; 0) {
    this.timeout = timeout;
    this.deadline = 0;
    return;
  }

  this.timeout = timeout * 1000; // convert to millisecons
  this.deadline = this.timeout;
  if (this.time !== undefined)
    this.deadline += this.time;
}

</t>
<t tx="leo.20210414180912.120">webots.Editor.prototype.closeAllTabs = function() {
  this.editor.setSession(ace.createEditSession("",""));
  this.filenames = [];
  this.needToUploadFiles = [];
  this.sessions = [];
  this.sessions[0] = this.editor.getSession();
  this.currentSession = 0;
  $("div#webotsEditorTabs ul").empty();
  $("#webotsEditorMenu").hide();
  $("#webotsEditorTabs").hide();
}

</t>
<t tx="leo.20210414180912.121">webots.Console = function(parent) {
  function closeConsole() {
    $('#consoleButton').removeClass('toolBarButtonActive');
  }
  this.panel = document.createElement('div');
  this.panel.id = 'webotsConsole';
  this.panel.className = 'webotsConsole';
  parent.appendChild(this.panel);
  var clampedSize = webotsClampDialogSize({left: 0, top : 0, width: 600, height: 400});
  $('#webotsConsole').dialog({title: 'Console', resizeStart: webotsDisablePointerEvents, resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents, dragStop: webotsEnablePointerEvents, width: clampedSize.width, height: clampedSize.height, autoOpen: false,
    appendTo: parent, close: closeConsole, open: webotsOpenDialog}).dialogExtend({maximizable : true});
}

</t>
<t tx="leo.20210414180912.122"></t>
<t tx="leo.20210414180912.123">webots.Console.prototype.scrollDown = function() {
  if (this.panel)
    this.panel.scrollTop = this.panel.scrollHeight;
}

</t>
<t tx="leo.20210414180912.124">webots.Console.prototype.clear = function() {
  if (this.panel)
    while (this.panel.firstChild)
      this.panel.removeChild(this.panel.firstChild);
  else
    console.clear();
}

</t>
<t tx="leo.20210414180912.125">webots.Console.prototype.log = function(message, type) {
  var para = document.createElement('p');
  var style = 'margin:0;';
  var title = ''
  switch(type) {
  case 0:
    style += 'color:Blue;';
    title = 'Webots stdout';
    break;
  case 1:
    style += 'color:Red;';
    title = 'Webots stderr';
    break;
  case 2:
    style += 'color:Gray;';
    title = 'info';
    break;
  case 3:
    style += 'color:Salmon;';
    title = 'error';
    break;
  }
  if (this.panel) {
    para.style.cssText = style;
    para.title = title + ' (' + hourString() + ')';
    var t = document.createTextNode(message);
    para.appendChild(t);
    this.panel.appendChild(para);
    this.scrollDown();
  } else
    console.log('%c' + message, style);
  function hourString() {
    var d = new Date();
    return d.getHours() + ':' +
         ((d.getMinutes() &lt; 10) ? '0' : '') + d.getMinutes() + ':' +
         ((d.getSeconds() &lt; 10) ? '0' : '') + d.getSeconds();
  }
}

</t>
<t tx="leo.20210414180912.126"></t>
<t tx="leo.20210414180912.127">webots.Console.prototype.stdout = function(message) {
  this.log(message, 0)
}

</t>
<t tx="leo.20210414180912.128">webots.Console.prototype.stderr = function(message) {
  this.log(message, 1)
}

</t>
<t tx="leo.20210414180912.129">webots.Console.prototype.info = function(message) {
  this.log(message, 2)
}

</t>
<t tx="leo.20210414180912.13">webots.View.prototype.open = function(url, mode) {
  if (mode === undefined)
    mode = 'x3dom';
  var that = this;
  this.mode = mode;
  this.videoStream = null;
  if (mode == 'video') {
    this.url = url;
    this.video = document.createElement('video');
    this.video.style.background = 'grey';
    this.video.id = 'remoteVideo';
    this.video.class = 'rounded centered';
    this.video.autoplay = 'true';
    this.video.width = 800;
    this.video.height = 600;
    this.view3D.appendChild(this.video);
    initWorld();
    return;
  }
  if (mode != 'x3dom') {
    console.log("Error: webots.View.open: wrong mode argument: " + mode);
    return;
  }
  if (this.broadcast)
    this.setTimeout(-1);
  if (!this.x3dScene) {
    this.x3dNode = document.createElement('x3d');
    this.x3dNode.className = 'webots3DView';
    this.view3D.appendChild(this.x3dNode);
    var param = document.createElement('param');
    param.name = 'showProgress';
    param.value = false;
    this.x3dNode.appendChild(param);
    this.x3dScene = document.createElement('Scene');
    this.x3dNode.appendChild(this.x3dScene);
  }
  if (this.url === undefined) {
    this.url = url;
    initX3Dom();
  } else {
    this.url = url;
    initWorld();
  }
  this.isWebSocketProtocol = that.url.startsWith('ws://') || that.url.startsWith('wss://');
  @others
}

</t>
<t tx="leo.20210414180912.130">webots.Console.prototype.error = function(message) {
  this.log(message, 3)
}

</t>
<t tx="leo.20210414180912.131">webots.HelpWindow = function(parent, createWebotsDocTab) {
  @others
}

</t>
<t tx="leo.20210414180912.132">function closeConsole() {
  $('#helpButton').removeClass('toolBarButtonActive');
}
</t>
<t tx="leo.20210414180912.133">function finalize() {
  $('#webotsHelpTabs').tabs("refresh");
  $("#webotsHelpTabs").tabs("option", "active", 0);
  $(that.panel).dialog('open');
}
that = this;
this.name = name;
this.panel = document.createElement('div');
this.panel.id = "webotsHelp";
that.panel.style.overflow = "hidden";
this.panel.className += 'webotsTabContainer';
this.tabs = document.createElement('div');
this.tabs.id = 'webotsHelpTabs';
this.tabs.className += 'webotsTabs';
this.tabsHeader = document.createElement('ul');
this.tabs.appendChild(this.tabsHeader);
this.panel.appendChild(this.tabs);
parent.appendChild(this.panel);
var clampedSize = webotsClampDialogSize({left: 5, top: 5, width: 600, height: 600});
$(this.panel).dialog({title: 'Help', resizeStart: webotsDisablePointerEvents, resizeStop: webotsEnablePointerEvents,
  dragStart: webotsDisablePointerEvents, dragStop: webotsEnablePointerEvents, autoOpen: false, appendTo: parent, close: closeConsole,
  open: webotsOpenDialog, position: {at: "right-5 top+5", my: "right top", of: parent}, width: clampedSize.width, height: clampedSize.height})
  .dialogExtend({maximizable : true});

if (createWebotsDocTab) {
  var header = document.createElement("li");
  header.innerHTML = '&lt;a href="#webotsHelpReference"&gt;Webots Reference Manual&lt;/a&gt;';
  that.tabsHeader.appendChild(header);
  var page = document.createElement("div");
  page.id = "webotsHelpReference";
  var host = location.protocol + "//" + location.hostname.replace(/^www./, ''); // remove 'www' prefix
  page.innerHTML =  "&lt;iframe src=" + host + "/webots_documentation.php?book=reference&gt;&lt;/iframe&gt;";
  that.tabs.appendChild(page);
  $('#webotsHelpTabs').tabs();
}

$.ajax({
  url: webots.currentScriptPath() + 'help.php',
  success: function(data) {
    // we need to fix the img src relative URLs
    html = data.replace(/ src=\"images/g, ' src=\"' + webots.currentScriptPath() + '/images');
    var header = document.createElement("li");
    header.innerHTML = '&lt;a href="#webotsHelpGuide"&gt;User Guide&lt;/a&gt;';
    $(that.tabsHeader).prepend(header);
    var page = document.createElement("div");
    page.id = "webotsHelpGuide";
    page.innerHTML = html;
    if (document.getElementById("webotsHelpReference"))
      $("#webotsHelpReference").before(page);
    else {
      that.tabs.appendChild(page);
      $('#webotsHelpTabs').tabs();
    }
    finalize();
  },
  error: function() {
    finalize();
  }
});
</t>
<t tx="leo.20210414180912.134">webots.RobotWindow = function(parent, name) {
  this.name = name;
  this.panel = document.createElement('div');
  this.panel.id = name;
  this.panel.className = 'webotsTabContainer';
  parent.appendChild(this.panel);
  var clampedSize = webotsClampDialogSize({left: 5, top: 5, width: 400, height: 400});
  $(this.panel).dialog({title: 'Robot Window', resizeStart: webotsDisablePointerEvents, resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents, dragStop: webotsEnablePointerEvents, autoOpen: false, appendTo: parent,
    open: webotsOpenDialog, position: {at: "left+5 top+5", my: "left top", of: parent}, width: clampedSize.width, height: clampedSize.height})
    .dialogExtend({maximizable : true});
}

</t>
<t tx="leo.20210414180912.135">webots.RobotWindow.prototype.setProperties = function(properties) {
  $(this.panel).dialog(properties);
}

</t>
<t tx="leo.20210414180912.136">webots.RobotWindow.prototype.geometry = function() {
  var webotsTabs = this.panel.getElementsByClassName("webotsTabs");
  var activeTabIndex = -1;
  if (webotsTabs.length &gt; 0)
    activeTabIndex = $(webotsTabs[0]).tabs('option', 'active');
  return {
    width: $(this.panel).dialog("option", "width"),
    height: $(this.panel).dialog("option", "height"),
    position: $(this.panel).dialog("option", "position"),
    activeTabIndex: activeTabIndex,
    open: this.isOpen()
  };
}

</t>
<t tx="leo.20210414180912.137">webots.RobotWindow.prototype.restoreGeometry = function(data) {
  $(this.panel).dialog({
    width: data.width,
    height: data.height,
    position: data.position
  });
  var webotsTabs = this.panel.getElementsByClassName("webotsTabs");
  if (data.activeTabIndex &gt;= 0 &amp;&amp; webotsTabs.length &gt; 0)
    $(webotsTabs[0]).tabs('option', 'active', data.activeTabIndex);
}

</t>
<t tx="leo.20210414180912.138">webots.RobotWindow.prototype.destroy = function() {
  this.close();
  this.panel.parentNode.removeChild(this.panel);
  this.panel = null;
}

</t>
<t tx="leo.20210414180912.139">webots.RobotWindow.prototype.setContent = function(content) {
  $(this.panel).html(content);
}

</t>
<t tx="leo.20210414180912.14">function requestQuit() {
  if (that.unloggedFileModified || that.editor.hasUnsavedChanges()) {
    if (that.unloggedFileModified || !webots.userCredentials())
      var text = "Your changes to the robot controller will be lost because you are not logged in.";
    else
      var text = "Your unsaved changes to the robot controller will be lost.";
    var quitDialog = document.getElementById("quitDialog");
    if (!quitDialog) {
      quitDialog = document.createElement('div');
      quitDialog.id = "quitDialog";
      $(quitDialog).html(text);
      that.view3D.appendChild(quitDialog);
      $(quitDialog).dialog({
        title: 'Quit the simulation?',
        modal: true,
        resizable: false,
        appendTo: that.view3D,
        open: webotsOpenDialog,
        buttons: {
          "Cancel": function() {
            $(this).dialog('close');
          },
          "Quit": function() {
            $(this).dialog('close');
            quit();
          }
        }
      });
    } else
      $(quitDialog).dialog('open');
    return;
  }
  quit();
}
</t>
<t tx="leo.20210414180912.140">webots.RobotWindow.prototype.open = function() {
  $(this.panel).dialog('open');
}

</t>
<t tx="leo.20210414180912.141">webots.RobotWindow.prototype.isOpen = function() {
  return $(this.panel).dialog('isOpen');
}

</t>
<t tx="leo.20210414180912.142">webots.RobotWindow.prototype.close = function() {
  $(this.panel).dialog('close');
}

</t>
<t tx="leo.20210414180912.143">webots.RobotWindow.prototype.send = function(message, robot) {
  webots.currentView.stream.socket.send('robot:' + robot + ':' + message);
  if (webots.currentView.real_timeButton.style.display == 'inline') // if paused, make a simulation step
    webots.currentView.stream.socket.send('step'); // so that the robot controller handles the message
  // FIXME: there seems to be a bug here: after that step, the current time is not incremented in the web interface,
  // this is because the next 'application/json:' is not received, probably because it gets overwritten by the
  // answer to the robot message...
}

</t>
<t tx="leo.20210414180912.144">webots.RobotWindow.prototype.receive = function(message, robot) { // to be overriden
  console.log("Robot window '" + this.name + "' received message from Robot '" + robot + "': " + message);
}

</t>
<t tx="leo.20210414180912.145">webots.window = function(name) {
  var win = webots.currentView.robotWindows[name];
  if (!win)
    console.log("Robot window '" + name + "' not found.")
  return win;
}

</t>
<t tx="leo.20210414180912.146">webots.alert = function(title, message, callback) {
  webots.currentView.ondialogwindow(true);
  var parent = webots.currentView.view3D;
  var panel = document.createElement('div');
  panel.id = 'webotsAlert';
  panel.innerHTML = message;
  parent.appendChild(panel);
  $('#webotsAlert').dialog({
    title: title,
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    appendTo: parent,
    open: webotsOpenDialog,
    modal: true,
    width: 400, // enough room to display the social network buttons in a line
    buttons: {Ok: function() {$(this).dialog("close");}},
    close: function() {
      if (callback !== undefined)
        callback();
      $(this).dialog('destroy').remove();
      webots.currentView.ondialogwindow(false);
    }
  });
}

</t>
<t tx="leo.20210414180912.147">webots.confirm = function(title, message, callback) {
  webots.currentView.ondialogwindow(true);
  var parent = webots.currentView.view3D;
  var panel = document.createElement('div');
  panel.id = 'webotsConfirm';
  panel.innerHTML = message;
  parent.appendChild(panel);
  $('#webotsConfirm').dialog({
    title: title,
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    appendTo: parent,
    open: webotsOpenDialog,
    modal: true,
    width: 400, // enough room to display the social network buttons in a line
    buttons: {Ok: function() {$(this).dialog("close"); callback();}, Cancel: function() {$(this).dialog("close");}},
    close: function() {$(this).dialog('destroy').remove(); webots.currentView.ondialogwindow(false);}});
}

</t>
<t tx="leo.20210414180912.148">webots.userCredentials = function() {
  function getCookie(name) {
    var value = '; ' + document.cookie;
    var parts = value.split('; ' + name + '=');
    if (parts.length == 2)
      return parts.pop().split(';').shift();
  }
  var email = getCookie('email');
  var password = getCookie('password');
  if (email === undefined || password === undefined ||
      email == '' || password == '')
    return '';
  return email + ':' + password;
}

</t>
<t tx="leo.20210414180912.149"></t>
<t tx="leo.20210414180912.15">function quit() {
  if (that.broadcast)
    return;
  $("#webotsProgressMessage").html("Bye bye...");
  $("#webotsProgress").show();
  that.quitting = true;
  that.onquit();
}
</t>
<t tx="leo.20210414180912.150">webots.parseMillisecondsIntoReadableTime = function(milliseconds) {
  var hours = (milliseconds + 0.9) / (1000 * 60 * 60);
  var absoluteHours = Math.floor(hours);
  var h = absoluteHours &gt; 9 ? absoluteHours : '0' + absoluteHours;
  var minutes = (hours - absoluteHours) * 60;
  var absoluteMinutes = Math.floor(minutes);
  var m = absoluteMinutes &gt; 9 ? absoluteMinutes : '0' +  absoluteMinutes;
  var seconds = (minutes - absoluteMinutes) * 60;
  var absoluteSeconds = Math.floor(seconds);
  var s = absoluteSeconds &gt; 9 ? absoluteSeconds : '0' + absoluteSeconds;
  var ms = Math.floor((seconds - absoluteSeconds) * 1000);
  if (ms &lt; 10)
    ms = '00' + ms;
  else if (ms &lt; 100)
    ms = '0' + ms;
  return h + ':' + m + ':' + s + ':' + ms;
}

// get the directory path to the currently executing script file
</t>
<t tx="leo.20210414180912.151">// for example: https://cyberbotics.com/wwi/8.6/
webots.currentScriptPath = function () {
  var scripts = document.querySelectorAll('script[src]');
  for (i = 0; i &lt; scripts.length; i++) {
    var src = scripts[i].src;
    if (!src.endsWith('webots.js'))
      continue;
    var index = src.lastIndexOf('/');
    return src.substring(0, index + 1);
  }
  return '';
}

// add startsWith() and endsWith() functions to the String prototype
if (typeof String.prototype.startsWith != 'function') {
</t>
<t tx="leo.20210414180912.152">  String.prototype.startsWith = function (prefix) {
    return this.slice(0, prefix.length) == prefix;
  }
}

if (typeof String.prototype.endsWith !== 'function') {
</t>
<t tx="leo.20210414180912.153">  String.prototype.endsWith = function (suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };
}
</t>
<t tx="leo.20210414180912.16">function revert() {
  if (that.broadcast)
    return;
  that.time = undefined; // reset time to correctly compute the initial deadline
  $("#webotsProgressMessage").html("Reverting...");
  $("#webotsProgress").show();
  that.runOnLoad = that.pauseButton.style.display == 'inline';
  pause();
  for (var i = 0; i &lt; that.editor.filenames.length; i++) {
    that.editor.save(i);
    if (that.editor.needToUploadFiles[i])
      that.editor.upload(i);
  }
  that.onrobotwindowsdestroy();
  if (that.timeout &gt;= 0) {
    that.deadline = that.timeout;
    $('#webotsTimeout').html(webots.parseMillisecondsIntoReadableTime(that.deadline));
  }
  enableToolBarButtons(false);
  that.stream.socket.send('revert');
}
</t>
<t tx="leo.20210414180912.17">function pause() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display','none');
  that.stream.socket.send('pause');
}
</t>
<t tx="leo.20210414180912.18">function realTime() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display','none');
  that.stream.socket.send('real-time:' + that.timeout);
  that.pauseButton.style.display = 'inline';
  that.real_timeButton.style.display = 'none';
}
</t>
<t tx="leo.20210414180912.19">function step() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display','none');
  that.pauseButton.style.display = 'none';
  that.real_timeButton.style.display = 'inline';
  that.stream.socket.send('step');
}
</t>
<t tx="leo.20210414180912.2">this.onerror = function(text) {
  console.log('%c' + text, 'color:black');
  that.onrobotwindowsdestroy();
}
</t>
<t tx="leo.20210414180912.20">function requestFullscreen() {
  $('#contextMenu').css('display','none');
  var elem = that.view3D;
  if (elem.requestFullscreen)
    elem.requestFullscreen();
  else if (elem.msRequestFullscreen)
    elem.msRequestFullscreen();
  else if (elem.mozRequestFullScreen)
    elem.mozRequestFullScreen();
  else if (elem.webkitRequestFullscreen)
    elem.webkitRequestFullscreen();
}
</t>
<t tx="leo.20210414180912.21">function exitFullscreen() {
  $('#contextMenu').css('display','none');
  if (document.exitFullscreen)
    document.exitFullscreen();
  else if (document.msExitFullscreen)
    document.msExitFullscreen();
  else if (document.mozCancelFullScreen)
    document.mozCancelFullScreen();
  else if (document.webkitExitFullscreen)
    document.webkitExitFullscreen();
}
</t>
<t tx="leo.20210414180912.22">function fullscreenchange(event) {
  var element = document.fullScreenElement || document.mozFullScreenElement || document.webkitFullScreenElement || document.msFullScreenElement || document.webkitCurrentFullScreenElement;
  if (element != null) {
    that.fullscreenButton.style.display = 'none';
    that.exit_fullscreenButton.style.display = 'inline';
  } else {
    that.fullscreenButton.style.display = 'inline';
    that.exit_fullscreenButton.style.display = 'none';
  }
}
</t>
<t tx="leo.20210414180912.23">function toolBarButton(name, tooltip) {
  var buttonName = name + 'Button';
  that[buttonName] = document.createElement('button');
  that[buttonName].id = buttonName;
  that[buttonName].className = 'toolBarButton';
  that[buttonName].title = tooltip;
  that[buttonName].style.backgroundImage = 'url(' + webots.WwiUrl + 'images/' + name + '.png)';
  return that[buttonName];
}
</t>
<t tx="leo.20210414180912.24">function toggleInfo() {
  $('#contextMenu').css('display','none');
  if (!that.infoWindow)
    return;
  if (that.infoWindow.isOpen()) {
    that.infoWindow.close();
    that.infoButton.classList.remove('toolBarButtonActive');
  } else {
    that.infoWindow.open();
    that.infoButton.classList.add('toolBarButtonActive');
  }
}
</t>
<t tx="leo.20210414180912.25">function toggleConsole() {
  $('#contextMenu').css('display','none');
  if ($('#webotsConsole').is(':visible')) {
    $('#webotsConsole').dialog('close');
    that.consoleButton.classList.remove('toolBarButtonActive');
  } else {
    $('#webotsConsole').dialog('open');
    that.consoleButton.classList.add('toolBarButtonActive');
  }
}
</t>
<t tx="leo.20210414180912.26">function toggleHelp() {
  $('#contextMenu').css('display','none');
  if (!that.helpWindow) {
    that.helpWindow = new webots.HelpWindow(that.view3D, !that.broadcast);
    that.helpButton.classList.add('toolBarButtonActive');
  } else if ($('#webotsHelp').is(':visible')) {
    $('#webotsHelp').dialog('close');
    that.helpButton.classList.remove('toolBarButtonActive');
  } else {
    $('#webotsHelp').dialog('open');
    that.helpButton.classList.add('toolBarButtonActive');
  }
}
</t>
<t tx="leo.20210414180912.27">function enableToolBarButtons(enabled) {
  var buttons = [that.infoButton, that.revertButton, that.stepButton, that.real_timeButton, that.pauseButton, that.consoleButton];
  for (var i in buttons) {
    if (buttons[i]) {
      if ((!that.broadcast || buttons[i] == that.consoleButton) &amp;&amp; enabled) {
        buttons[i].disabled = false;
        buttons[i].classList.remove('toolBarButtonDisabled');
      } else {
        buttons[i].disabled = true;
        buttons[i].classList.add('toolBarButtonDisabled');
      }
    }
  }
}
</t>
<t tx="leo.20210414180912.28">function initWorld() {
  // override the original x3dom function to workaround a bug with USE/DEF nodes
  @others
}

</t>
<t tx="leo.20210414180912.29">x3dom.Texture.prototype.update = function() {
  if (x3dom.isa(this.node, x3dom.nodeTypes.Text))
    this.updateText();
  else
    this.updateTexture();
  // x3dom bug: do not call validateGLObject because it somehow prevents USE Apperance update (bug #5117)
  //this.node.validateGLObject();
};

// redirect the X3Dom log entirely to the JS console
if (that.mode == 'x3dom') {
  if (this.debug) {
</t>
<t tx="leo.20210414180912.3">this.onstdout = function(text) {
  console.log('%c' + text, 'color:blue');
}
</t>
<t tx="leo.20210414180912.30">    x3dom.debug.doLog = function(msg, type) {
      console.log(type + ": " + msg);
    }
  }
  x3dom.runtime.ready = addX3domMouseNavigation;
}
if (that.isWebSocketProtocol) {
  that.progress = document.createElement('div');
  that.progress.id = 'webotsProgress';
  that.progress.innerHTML = "&lt;div&gt;&lt;img src='" + webots.WwiUrl + "images/load_animation.gif'&gt;" +
                            "&lt;/div&gt;&lt;div id='webotsProgressMessage'&gt;Initializing...&lt;/div&gt;";
  that.view3D.appendChild(that.progress);
  that.toolBar = document.createElement('div');
  that.toolBar.id = 'toolBar';
  that.toolBar.left = document.createElement('div');
  that.toolBar.left.className = 'toolBarLeft';
  that.toolBar.left.appendChild(toolBarButton('quit', "Quit the simulation"));
  that.quitButton.onclick = requestQuit;
  that.toolBar.left.appendChild(toolBarButton('info', "Open the information window"));
  that.infoButton.onclick = toggleInfo;
  that.toolBar.left.appendChild(toolBarButton('revert', "Save controllers and reload the simulation"));
  that.revertButton.onclick = revert;
  that.toolBar.left.appendChild(toolBarButton('step', "Perform one simulation step"));
  that.stepButton.onclick = step;
  that.toolBar.left.appendChild(toolBarButton('real_time', "Run the simulation in real time"));
  that.real_timeButton.onclick = realTime;
  that.toolBar.left.appendChild(toolBarButton('pause', "Pause the simulation"));
  that.pauseButton.onclick = pause;
  that.pauseButton.style.display = 'none';
  var div = document.createElement('div')
  div.className = 'webotsTime';
  var clock = document.createElement('span');
  clock.id = 'webotsClock';
  clock.title = "Current simulation time";
  clock.innerHTML = webots.parseMillisecondsIntoReadableTime(0);
  var timeout = document.createElement('span');
  timeout.id = 'webotsTimeout';
  timeout.title = "Simulation time out";
  timeout.innerHTML = webots.parseMillisecondsIntoReadableTime(that.deadline);
  div.appendChild(clock);
  div.appendChild(document.createElement('br'));
  div.appendChild(timeout);
  that.toolBar.left.appendChild(div);
  that.toolBar.left.appendChild(toolBarButton('console', "Open the console window"));
  that.consoleButton.onclick = toggleConsole;
  that.toolBar.right = document.createElement('div');
  that.toolBar.right.className = 'toolBarRight';
  that.toolBar.right.appendChild(toolBarButton('help', "Get help on the simulator"));
  that.helpButton.onclick = toggleHelp;
  that.toolBar.right.appendChild(toolBarButton('exit_fullscreen', "Exit fullscreen"));
  that.exit_fullscreenButton.onclick = exitFullscreen;
  that.exit_fullscreenButton.style.display = 'none';
  that.toolBar.right.appendChild(toolBarButton('fullscreen', "Enter fullscreen"));
  that.fullscreenButton.onclick = requestFullscreen;
  that.toolBar.appendChild(that.toolBar.left);
  that.toolBar.appendChild(that.toolBar.right);
  that.view3D.appendChild(that.toolBar);
  enableToolBarButtons(false);
  if (that.broadcast) {
    that.quitButton.disabled = true;
    that.quitButton.classList.add('toolBarButtonDisabled');
    $('#contextMenuRobotWindowDiv').addClass('ui-state-disabled');
    $('#contextMenuEditControllerDiv').addClass('ui-state-disabled');
  }
  document.addEventListener('fullscreenchange', fullscreenchange);
  document.addEventListener('webkitfullscreenchange', fullscreenchange);
  document.addEventListener('mozfullscreenchange', fullscreenchange);
  document.addEventListener('MSFullscreenChange', fullscreenchange);
  if (that.url.endsWith('.wbt')) {  // url expected form: "ws://localhost:80/simple/worlds/simple.wbt"
    var callback;
    if (that.mode == 'video')
      callback = videoFinalize;
    else
      callback = x3domFinalize;
    that.server = new webots.Server(that.url, that, callback);
  } else // url expected form: "ws://cyberbotics2.cyberbotics.com:80"
    that.stream = new webots.Stream(that.url, that, x3domFinalize);
} else // assuming it's an URL to a .x3d file
  initX3dFile();
</t>
<t tx="leo.20210414180912.31">function initX3Dom() { // load x3dom.css, x3dom-full.js and calls initWorld
  var head = document.getElementsByTagName('head')[0];
  var link  = document.createElement('link');
  link.rel  = 'stylesheet';
  link.type = 'text/css';
  link.href = 'https://www.cyberbotics.com/x3dom/dev/x3dom.css';
  link.media = 'all';
  head.appendChild(link);
  // source http://stackoverflow.com/questions/950087/include-a-javascript-file-in-another-javascript-file
  var script = document.createElement('script');
  script.src = "https://www.cyberbotics.com/x3dom/dev/x3dom-full.js";
  script.onload = initWorld;
  script.onerror = function() {
    that.onerror("Error when loading the X3DOM library");
  }
  head.appendChild(script); // fire the loading
}

</t>
<t tx="leo.20210414180912.32"></t>
<t tx="leo.20210414180912.33">function initX3dFile() {
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.open("GET", that.url, true);
  xmlhttp.overrideMimeType('text/xml');
  xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) {
      var scene = xmlhttp.responseText.substring(xmlhttp.responseText.indexOf('&lt;Scene&gt;') + 8, xmlhttp.responseText.lastIndexOf('&lt;/Scene&gt;'));
      $(that.x3dScene).append(scene);
      x3domFinalize();
    }
  }
  xmlhttp.send();
}

</t>
<t tx="leo.20210414180912.34"></t>
<t tx="leo.20210414180912.35">function x3domFinalize() {
  $("#webotsProgressMessage").html("Loading HTML and Javascript files...");
  if (that.followedObject == null || that.broadcast) {
    var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
    var viewpointFollowSmoothness = viewpoint.getAttribute('followSmoothness');
    if (viewpointFollowSmoothness !== null)
      that.setViewpointMass(viewpointFollowSmoothness)
    var viewpointFollowedId = viewpoint.getAttribute('followedId');
    if (viewpointFollowedId != null) {
      that.followedObject = viewpointFollowedId;
      that.follow(viewpointFollowedId);
    } else
      that.followedObject = 'none';
  } else
    // reset follow parameters
    that.follow(that.followedObject)

  if (!that.isWebSocketProtocol) { // skip robot windows initialization
    if (that.animation != null)
      that.animation.init(loadFinalize);
    else
      loadFinalize();
    that.onresize();
    return;
  }

  function loadRobotWindow(node) {
    var windowName = node.getAttribute('window');
    that.robotWindowNames[node.getAttribute('name')] = windowName;
    var win = new webots.RobotWindow(that.view3D, windowName);
    that.robotWindows[windowName] = win;
    // init robot windows dialogs
    if (windowName == infoWindowName) {
      @others
  }

  var worldInfo = that.x3dScene.getElementsByTagName('WorldInfo')[0];
  var infoWindowName = worldInfo.getAttribute('window');
  var pendingRequestsCount = 1; // start from 1 so that it can be 0 only after the loop is completed and all the nodes are checked
  var nodes = that.x3dScene.childNodes;
  for (var i = 0; i &lt; nodes.length; i++) {
    if (nodes[i].nodeType != 1 || nodes[i].nodeName.toUpperCase() != 'TRANSFORM' || !nodes[i].hasAttribute('window') || !nodes[i].hasAttribute('name'))
      continue;
    anyRobotWindowExists = true;
    loadRobotWindow(nodes[i]);
  }
  pendingRequestsCount--; // notify that loop is completed
  if (pendingRequestsCount == 0)
    // if no pending requests execute loadFinalize
    // otherwise it will be executed when the last request will be handled
    loadFinalize();
}

</t>
<t tx="leo.20210414180912.36"></t>
<t tx="leo.20210414180912.37">  function closeInfoWindow() {
    $('#infoButton').removeClass('toolBarButtonActive');
  }
  var user = webots.Owner;
  if (user == null)
    user = '';
  else
    user = ' [' + user + ']';
  win.setProperties({title: worldInfo.getAttribute('title') + user, close: closeInfoWindow});
  that.infoWindow = win;
} else
  win.setProperties({title: 'Robot: ' + node.getAttribute('name')});
pendingRequestsCount++;
</t>
<t tx="leo.20210414180912.38">$.get("window/" + windowName + "/" + windowName + ".html", function(data) {
  // we need to fix the img src relative URLs
  var d = data.replace(/ src='/g, ' src=\'window/' + windowName + '/').replace(/ src="/g, ' src="window/' + windowName + '/');
  win.setContent(d);
  MathJax.Hub.Queue(["Typeset", MathJax.Hub, win[0]]);
  $.get("window/" + windowName + "/" + windowName + ".js", function(data) {
    eval(data);
    pendingRequestsCount--;
    if (pendingRequestsCount == 0)
      loadFinalize();
  }).fail(function() {
    pendingRequestsCount--;
    if (pendingRequestsCount == 0)
      loadFinalize();
  });
}).fail(function() {
  pendingRequestsCount--;
  if (pendingRequestsCount == 0)
    loadFinalize();
});
</t>
<t tx="leo.20210414180912.39"></t>
<t tx="leo.20210414180912.4">this.onstderr = function(text) {
  console.log('%c' + text, 'color:red');
}
</t>
<t tx="leo.20210414180912.40">function loadFinalize() {
  $("#webotsProgress").hide();
  enableToolBarButtons(true);

  if (that.onready)
    that.onready();

  // restore robot windows
  if (that.robotWindowsGeometries) { // on revert
    for (var win in that.robotWindows) {
      if (win in that.robotWindowsGeometries) {
        that.robotWindows[win].restoreGeometry(that.robotWindowsGeometries[win]);
        if (that.robotWindowsGeometries[win].open) {
          if (that.robotWindows[win] == that.infoWindow)
            toggleInfo();
          else
            that.robotWindows[win].open();
        }
      }
    }
  } else if (that.infoWindow &amp;&amp; !that.broadcast) // at first load
    toggleInfo();
  that.viewpointLastUpdate = undefined;

  if (that.runOnLoad)
    realTime();
}

</t>
<t tx="leo.20210414180912.41">function addX3domMouseNavigation() {
  @others
}
</t>
<t tx="leo.20210414180912.42">that.x3dNode.addEventListener('wheel', function(event) {
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var vp = x3dom.fields.SFVec3f.parse(viewpoint.getAttribute('position'));
  var vo = x3dom.fields.SFVec4f.parse(viewpoint.getAttribute('orientation'));
  var mousePosition = that.x3dNode.runtime.mousePosition(event);
  shootRay = that.x3dNode.runtime.shootRay(mousePosition[0], mousePosition[1]);
  var distanceToPickPosition;
  that.pickPosition = shootRay.pickPosition;
  if (that.pickPosition == null)
    distanceToPickPosition = vp.length();
  else
    distanceToPickPosition = vp.subtract(that.pickPosition).length();
  if (distanceToPickPosition &lt; 0.001) // 1 mm
    distanceToPickPosition = 0.001;
  if (!that.enableNavigation || that.wheelFocus == false) {
    var offset = event.deltaY;
    if (event.deltaMode == 1)
      offset *= 40; // standard line height in pixel
    window.scroll(0, window.pageYOffset + offset);
    if (that.wheelTimeout) { // you have to rest at least 1.5 seconds over the x3d canvas
      clearTimeout(that.wheelTimeout); // so that the wheel focus will get enabled and
      that.wheelTimeout = setTimeout(wheelTimeoutCallback, 1500); // allow you to zoom in/out.
    }
    return;
  }
  var scaleFactor = 0.02 * distanceToPickPosition * ((event.deltaY &lt; 0) ? -1 : 1);
  var c = Math.cos(vo.w);
  var s = Math.sin(vo.w);
  var tz = (1 - c) * vo.z;
  var roll = new x3dom.fields.SFVec3f(tz * vo.x + s * vo.y, tz * vo.y - s * vo.x, tz * vo.z + c);
  var target = vp.add(roll.multiply(scaleFactor));
  viewpoint.setAttribute('position', target.toString());
  if (that.onmousewheel)
    that.onmousewheel(event);
}, true);
</t>
<t tx="leo.20210414180912.43">that.x3dNode.addEventListener('mousemove', function(event) {
  if (!that.enableNavigation &amp;&amp; event.button == 0)
    return;
  if ('buttons' in event)
    that.mouseDown = event.buttons;
  else if ('which' in event) { // Safari only
    switch(event.which) {
    case 0: that.mouseDown = 0; break;
    case 1: that.mouseDown = 1; break;
    case 2: that.mouseButton = 4; break;
    case 3: that.mouseButton = 2; break;
    default: that.mouseButton = 0; break;
    }
  }
  if (that.mouseDown == 0) {
    if (that.animation &amp;&amp; that.animation.playSlider &amp;&amp; that.animation.sliding) {
      var w = event.target.clientWidth - 66; // size of the borders of the slider
      var x = event.clientX - event.target.getBoundingClientRect().left - 48; // size of the left border (including play button) of the slider
      var value = 100 * x / w;
      if (value &lt; 0)
        value = 0;
      else if (value &gt;= 100)
        value = 99.999;
      that.animation.playSlider.slider('value', value);
      // setting the value should trigger the change event, unfortunately, doesn't seem to work reliably,
      // therefore, we need to trigger this event manually:
      var ui = new Object();
      ui.value = value;
      that.animation.playSlider.slider('option','change').call(that.animation.playSlider, event, ui);
    }
    return;
  }
  if (!that.mouseMoveInitialized)
    // prevent applying mouse move action before drag initialization in mousedrag event
    return;
  var dx = event.clientX - that.initialMouseX;
  var dy = event.clientY - that.initialMouseY;
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var vp = x3dom.fields.SFVec3f.parse(viewpoint.getAttribute('position'));
  var vo = x3dom.fields.SFVec4f.parse(viewpoint.getAttribute('orientation'));
  var c = Math.cos(vo.w);
  var s = Math.sin(vo.w);

  var distanceToPickPosition;
  if (that.pickPosition == null)
    distanceToPickPosition = vp.length();
  else
    distanceToPickPosition = vp.subtract(that.pickPosition).length() - 0.05; //FIXME this is different from webots.
  if (distanceToPickPosition &lt; 0.001) // 1 mm
    distanceToPickPosition = 0.001;

  //FIXME this is different from webots. We need to understand why the same formula doesn't work.
  var scaleFactor = 1.90 * Math.tan(that.viewpointFieldOfView / 2);
  var viewHeight = parseFloat($(that.x3dNode).css('height').slice(0, -2));
  var viewWidth = parseFloat($(that.x3dNode).css('width').slice(0, -2));
  scaleFactor /= Math.max(viewHeight, viewWidth);

  if (that.mouseDown == 1) { // left mouse button to rotate viewpoint
    var halfYawAngle   = -0.005 * dx;
    var halfPitchAngle = -0.005 * dy;
    if (that.pickPosition == null) {
      halfYawAngle /= -8;
      halfPitchAngle /= -8;
    }
    var sinusYaw = Math.sin(halfYawAngle);
    var sinusPitch = Math.sin(halfPitchAngle);
    var tx = (1 - c) * vo.x;
    var pitch = new x3dom.fields.SFVec3f(tx * vo.x + c, tx * vo.y + s * vo.z, tx * vo.z - s * vo.y);
    var pitchRotation = new x3dom.fields.Quaternion(sinusPitch * pitch.x, sinusPitch * pitch.y, sinusPitch * pitch.z, Math.cos(halfPitchAngle));
    var worldUp = new x3dom.fields.SFVec3f(0,1,0);
    var yawRotation = new x3dom.fields.Quaternion(sinusYaw * worldUp.x, sinusYaw * worldUp.y, sinusYaw * worldUp.z, Math.cos(halfYawAngle));
    var deltaRotation = yawRotation.multiply(pitchRotation);
    if (that.pickPosition) {
      var currentPosition = deltaRotation.toMatrix().multMatrixVec(vp.subtract(that.pickPosition)).add(that.pickPosition);
      viewpoint.setAttribute('position', currentPosition.toString());
    }
    var voq = x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(vo.x, vo.y, vo.z), vo.w);
    var currentOrientation = deltaRotation.multiply(voq);
    var aa = currentOrientation.toAxisAngle();
    viewpoint.setAttribute('orientation', aa[0].toString() + " " + aa[1]);
  } else if (that.mouseDown == 2) { // right mouse button to translate viewpoint
    var targetRight = -distanceToPickPosition * scaleFactor * dx;
    var targetUp    = distanceToPickPosition * scaleFactor * dy;
    var tx = (1 - c) * vo.x;
    var pitch = new x3dom.fields.SFVec3f(tx * vo.x + c, tx * vo.y + s * vo.z, tx * vo.z - s * vo.y);
    var ty = (1 - c) * vo.y;
    var yaw = new x3dom.fields.SFVec3f(ty * vo.x - s * vo.z, ty * vo.y + c, ty * vo.z + s * vo.x);
    var target = vp.add(pitch.multiply(targetRight).add(yaw.multiply(targetUp)));
    viewpoint.setAttribute('position', target.toString());
  } else if (that.mouseDown == 3 || that.mouseDown == 4) { // both left and right button or middle button to zoom
    var tz = (1 - c) * vo.z;
    var roll = new x3dom.fields.SFVec3f(tz * vo.x + s * vo.y, tz * vo.y - s * vo.x, tz * vo.z + c);
    var target = vp.add(roll.multiply(distanceToPickPosition * scaleFactor * 10 * dy)); //FIXME this is different from webots.
    viewpoint.setAttribute('position', target.toString());
    var zRotation = x3dom.fields.Quaternion.axisAngle(roll, 0.01 * dx);
    var voq = x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(vo.x, vo.y, vo.z), vo.w);
    var aa = zRotation.multiply(voq).toAxisAngle();
    viewpoint.setAttribute('orientation', aa[0].toString() + " " + aa[1]);
  }
  that.mouseMoved = event.clientX != that.initialMouseX || event.clientY != that.initialMouseY;
  that.initialMouseX = event.clientX;
  that.initialMouseY = event.clientY;
  if (that.onmousedrag)
    that.onmousedrag(event);
}, true);
</t>
<t tx="leo.20210414180912.44">that.x3dNode.addEventListener('mousedown', function(event) {
  that.wheelFocus = true;
  if (event.button == 0)
    that.mouseDown |= 1;
  else if (event.button == 1)
    that.mouseDown |= 4;
  else if (event.button == 2)
    that.mouseDown |= 2;
  that.initialMouseX = event.clientX;
  that.initialMouseY = event.clientY;
  that.mouseMoved = false;
  that.mouseTimeStamp = Date.now();
  var mousePosition = that.x3dNode.runtime.mousePosition(event);
  shootRay = that.x3dNode.runtime.shootRay(mousePosition[0], mousePosition[1]);
  that.pickPosition = shootRay.pickPosition;
  if ($('#contextMenu').css('display') == 'block') {
    $('#contextMenu').css('display','none');
    that.contextMenu = true;
  } else
    that.contextMenu = false;
  that.mouseMoveInitialized = true;
}, true);
</t>
<t tx="leo.20210414180912.45">that.x3dNode.addEventListener('mouseup', function(event) {
  if (that.mouseMoved == false &amp;&amp; Date.now() - that.mouseTimeStamp &lt; 1000) {
    that.previousSelection = that.selection;
    unselect();
  } else
    that.previousSelection = null;
  that.previousMouseDown = that.mouseDown;
  that.mouseDown = 0;
  that.mouseMoveInitialized = false;
}, true);
</t>
<t tx="leo.20210414180912.46">that.x3dNode.addEventListener('mouseover', function(event) {
  that.wheelTimeout = setTimeout(wheelTimeoutCallback, 1500);
}, true);
</t>
<t tx="leo.20210414180912.47">that.x3dNode.addEventListener('mouseleave', function(event) {
  if (that.wheelTimeout != null) {
    clearTimeout(that.wheelTimeout);
    that.wheelTimeout = null;
  }
  that.wheelFocus = false;
}, true);
</t>
<t tx="leo.20210414180912.48">that.x3dScene.addEventListener('mouseup', function(event) {
  if (that.mouseMoved == false &amp;&amp; Date.now() - that.mouseTimeStamp &lt; 1000) {
    var s = getTopX3dElement(event.target);
    if (that.previousSelection == null || that.previousSelection.id != s.id || that.previousMouseDown == 2)
      select(s);
    if (that.previousMouseDown == 2 &amp;&amp; that.contextMenu == false &amp;&amp; that.isWebSocketProtocol) {
      // right click: show popup menu
      $(function() {
        var title = that.selection.getAttribute('name');
        if (title == null || title == '') {
          title = that.selection.getAttribute('DEF');
          if (title == null || title == '')
            title = 'Object';
        }
        $('#contextMenuTitle').html(title);
        var controller = that.selection.getAttribute('controller');
        if (controller) { // the current selection is a robot
          $("#contextMenuEditController").css('display', 'inline');
          if (controller == "void" || controller.length == 0 || webots.Owner)
            $("#contextMenuEditController").children().addClass("ui-state-disabled");
          robotName = that.selection.getAttribute('name');
          if (that.robotWindows[that.robotWindowNames[robotName]])
            $("#contextMenuRobotWindow").css('display', 'inline');
          else
            $("#contextMenuRobotWindow").css('display', 'none');
        } else {
          $("#contextMenuEditController").css('display', 'none');
          $("#contextMenuRobotWindow").css('display', 'none');
        }
        if (that.followedObject != null &amp;&amp; (that.selection.id == that.followedObject || that.selection.getAttribute('DEF') == that.followedObject)) {
          $('#contextMenuFollow').css('display', 'none');
          $('#contextMenuUnfollow').css('display', 'inline');
        } else {
          $('#contextMenuFollow').css('display', 'inline');
          $('#contextMenuUnfollow').css('display', 'none');
        }
        $('#contextMenu').css('left', that.initialMouseX + 'px');
        $('#contextMenu').css('top', that.initialMouseY + 'px');
        $('#contextMenu').css('display','block');
      });
    }
  }
  if (that.onmouseup)
    that.onmouseup(event);
}, false);
</t>
<t tx="leo.20210414180912.49"></t>
<t tx="leo.20210414180912.5">this.onrobotmessage = function(robot, message) {
  if (that.robotWindowNames[robot] === undefined) {
    console.log("Robot '" + robot + "' has no associated robot window");
    return;
  }
  that.robotWindows[that.robotWindowNames[robot]].receive(message, robot);
}
</t>
<t tx="leo.20210414180912.50">function wheelTimeoutCallback(event) {
  that.wheelTimeout = null;
  that.wheelFocus = true;
}
</t>
<t tx="leo.20210414180912.51">function getTopX3dElement(el) {
  // If it exists, return the upmost Solid, otherwise the top node
  var upmostSolid = null;
  while (el) {
    if (el.getAttribute('solid'))
      upmostSolid = el;
    if (el.parentNode == that.x3dScene)
      break;
    el = el.parentNode;
  }
  if (upmostSolid)
    return upmostSolid;
  return el;
}

</t>
<t tx="leo.20210414180912.52">function unselect() {
  if (that.selection) {
    var selectors = that.selection.getElementsByClassName('selector');
    for (var i = 0; i &lt; selectors.length; i++) {
      var selector = selectors[i];
      selector.setAttribute('whichChoice', '-1');
    }
    that.selection = null;
  }
}

</t>
<t tx="leo.20210414180912.53">function select(el) {
  var selectors = el.getElementsByClassName('selector');
  for (var i = 0; i &lt; selectors.length; i++) {
    var selector = selectors[i];
    selector.setAttribute('whichChoice', '0');
  }
  that.selection = el;
}

</t>
<t tx="leo.20210414180912.54">function videoFinalize() {
  console.log("video finalize");
  addVideoMouseNavigation();
  if (that.onready)
    that.onready();
}

</t>
<t tx="leo.20210414180912.55">function sendVideoMouseEvent(type, event, wheel) {
  var socket = that.stream.socket;
  if (!socket || socket.readyState != 1)
     return;
  var modifier = (event.shiftKey?1:0) + (event.ctrlKey?2:0) + (event.altKey?4:0);
  socket.send('mouse ' + type + ' ' + event.button + ' ' + that.mouseDown + ' '
              + event.offsetX + ' ' + event.offsetY + ' ' + modifier + ' ' + wheel);
}

</t>
<t tx="leo.20210414180912.56">function onVideoMouseDown(event) {
  event.target.addEventListener('mousemove', onVideoMouseMove, false);
  sendVideoMouseEvent(-1, event, 0);
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414180912.57">function onVideoMouseMove(event) {
  if (that.mouseDown == 0) {
    event.target.removeEventListener('mousemove', onVideoMouseMove, false);
    return false;
  }
  sendVideoMouseEvent(0, event, 0);
  return false;
}

</t>
<t tx="leo.20210414180912.58">function onVideoMouseUp(event) {
  event.target.removeEventListener('mousemove', onVideoMouseMove, false);
  sendVideoMouseEvent(1, event, 0);
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414180912.59">function onVideoWheel(event) {
  sendVideoMouseEvent(2, event, Math.sign(event.deltaY));
  return false;
}

</t>
<t tx="leo.20210414180912.6">this.onrobotwindowsdestroy = function() {
  that.robotWindowsGeometries = {};
  for (var win in that.robotWindows) {
    that.robotWindowsGeometries[win] = that.robotWindows[win].geometry();
    that.robotWindows[win].destroy();
  }
  that.infoWindow = null;
  that.robotWindows = {} // delete robot windows
  that.robotWindowNames = {};
}
</t>
<t tx="leo.20210414180912.60">function onVideoContextMenu(event) {
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414180912.61">function addVideoMouseNavigation() {
  that.video.addEventListener('mousedown', onVideoMouseDown, false);
  that.video.addEventListener('mouseup', onVideoMouseUp, false);
  that.video.addEventListener('wheel', onVideoWheel, false);
  that.video.addEventListener('contextmenu', onVideoContextMenu, false);
}
</t>
<t tx="leo.20210414180912.62">webots.View.prototype.follow = function(id) {
  this.followedObject = id;
  this.viewpointForce = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
  this.viewpointVelocity = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
}

</t>
<t tx="leo.20210414180912.63">webots.View.prototype.setViewpointMass = function(mass) {
  this.viewpointMass = mass;
  if (this.viewpointMass &lt;= 0.05)
    this.viewpointMass = 0.0;
  else {
    if (this.viewpointMass &gt; 1.0)
      this.viewpointMass = 1.0;
    this.friction = 0.05 / this.viewpointMass;
  }
}

</t>
<t tx="leo.20210414180912.64">webots.View.prototype.updateViewpointPosition = function(forcePosition) {
  if (this.time === undefined)
    return;
  if (this.viewpointLastUpdate === undefined)
    this.viewpointLastUpdate = this.time;

  var timeInterval = Math.abs(this.time - this.viewpointLastUpdate) / 1000;
  var viewpoints = this.x3dScene.getElementsByTagName('Viewpoint');

  if (timeInterval &gt; 0 &amp;&amp; viewpoints[0]) {
    this.viewpointLastUpdate = this.time;
    var viewpointPosition = x3dom.fields.SFVec3f.parse(viewpoints[0].getAttribute('position'));
    var viewpointDeltaPosition;
    if (this.followedObjectDeltaPosition != null)
      this.viewpointForce = this.viewpointForce.add(this.followedObjectDeltaPosition);

    // Special case: if the mass is 0 we simply move the viewpoint to its equilibrium position.
    // If timeInterval is too large (longer than 1/10 of a second), the progression won't be smooth either way,
    // so in this case we simply move the viewpoint to the equilibrium position as well.
    if (forcePosition || this.viewpointMass == 0 || (timeInterval &gt; 0.1 &amp;&amp; this.animation == null)) {
      viewpointDeltaPosition = this.viewpointForce;
      this.viewpointVelocity = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
    } else {
      var acceleration = this.viewpointForce.divide(this.viewpointMass);
      this.viewpointVelocity = this.viewpointVelocity.add(acceleration.multiply(timeInterval));
      var scalarVelocity = this.viewpointVelocity.length();

      // Velocity of the object projected onto the velocity of the viewpoint.
      var scalarObjectVelocityProjection;
      if (this.followedObjectDeltaPosition != null) {
        var objectVelocity = this.followedObjectDeltaPosition.divide(timeInterval);
        scalarObjectVelocityProjection = objectVelocity.dot(this.viewpointVelocity) / scalarVelocity;
      } else
        scalarObjectVelocityProjection = 0;

      // The viewpoint is going "faster" than the object, to prevent oscillations we apply a slowing force.
      if (this.viewpointFriction &gt; 0 &amp;&amp; scalarVelocity &gt; scalarObjectVelocityProjection) {
        // We apply a friction based on the extra velocity.
        var velocityFactor = (scalarVelocity - (scalarVelocity - scalarObjectVelocityProjection) * this.viewpointFriction) / scalarVelocity;
        this.viewpointVelocity = this.viewpointVelocity.multiply(velocityFactor);
      }
      viewpointDeltaPosition = this.viewpointVelocity.multiply(timeInterval);
    }
    var viewpointNewPosition = viewpointPosition.add(viewpointDeltaPosition);
    this.viewpointForce = this.viewpointForce.subtract(viewpointDeltaPosition);
    viewpoints[0].setAttribute('position', viewpointNewPosition.toString());
    this.followedObjectDeltaPosition = null;
  }
}

</t>
<t tx="leo.20210414180912.65">webots.View.prototype.close = function() {
  if (this.server)
    this.server.socket.close();
  if (this.stream)
    this.stream.close();
}

</t>
<t tx="leo.20210414180912.66">webots.View.prototype.sendRobotMessage = function(robot, message) {
  this.stream.socket.send('robot:' + robot + ':' + message);
}

</t>
<t tx="leo.20210414180912.67">webots.View.prototype.resize = function(width, height) {
  if (this.mode != 'video')
    return;
  this.video.width = width;
  this.video.height = height;
  this.stream.socket.send('resize: ' + width + 'x' + height);
}

</t>
<t tx="leo.20210414180912.68">webots.View.prototype.getControllerUrl = function(name) {
  if (!this.server)
    return;
  this.server.controllers
  var port = 0;
  for(var i = 0; i &lt; this.server.controllers.length; i++) {
    if (this.server.controllers[i].name == name) {
      port = this.server.controllers[i].port;
      break;
    }
  }
  if (port == 0)
    return;
  return this.url.substring(0, this.url.indexOf(":", 6) + 1) + port;
}

</t>
<t tx="leo.20210414180912.69">webots.View.prototype.setAnimation = function(url, gui, loop) {
  if (gui === undefined)
    gui = 'play';
  if (loop === undefined)
    loop = true;
  this.animation = new webots.Animation(url, this, gui, loop);
}

</t>
<t tx="leo.20210414180912.7">this.onquit = function() {
  // If the simulation page URL is this https://mydomain.com/mydir/mysimulation.html, the quit action redirects to the
  // folder level, e.g., https://mydomain.com/mydir/
  // If the simulation page is https://mydomain.com/mydir/mysimulation/, the quit action redirects to the upper level:
  // https://mydomain.com/mydir/
  // You can change this behavior by overriding this onquit() method
  var currentLocation = window.location.href;
  // remove filename or last directory name from url and keep the final slash
  var quitDestination = currentLocation.substring(0, currentLocation.lastIndexOf('/', currentLocation.length - 2) + 1);
  window.location = quitDestination;
}
</t>
<t tx="leo.20210414180912.70">webots.View.prototype.applyPose = function(pose) {
  var id = pose.id;
  el = document.getElementById('n' + id);
  if (el &amp;&amp; !el.getAttribute('blockWebotsUpdate')) {
    for (var key in pose) {
      if (key != 'id') {
        value = pose[key];
        if (key == 'translation' &amp;&amp; this.followedObject  &amp;&amp;
            (id == this.followedObject ||  // animation case
             el.id == this.followedObject ||  // streaming case
             el.getAttribute('DEF') == this.followedObject)) {
          var objectPosition = x3dom.fields.SFVec3f.parse(el.getAttribute('translation'));
          el.setAttribute(key, value);
          // If this is the followed object, we save a vector with the translation applied
          // to the object to compute the new position of the viewpoint.
          var objectNewPosition = x3dom.fields.SFVec3f.parse(value);
          this.followedObjectDeltaPosition = objectNewPosition.subtract(objectPosition);
        } else
          el.setAttribute(key, value);
      }
    }
  }
}

</t>
<t tx="leo.20210414180912.71">webots.Animation = function(url, view, gui, loop) { // gui may be either "play" or "pause"
  this.url = url;
  this.view = view;
  this.gui = gui;
  this.loop = loop;
  this.sliding = false;
  this.onready = null;
}

</t>
<t tx="leo.20210414180912.72">webots.Animation.prototype.init = function(onready) {
  var that = this;
  this.onready = onready;
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.open('GET', this.url, true);
  xmlhttp.overrideMimeType("application/json");
  @others
}

</t>
<t tx="leo.20210414180912.73">xmlhttp.onreadystatechange = function() {
  if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)
    setup(JSON.parse(xmlhttp.responseText));
}
xmlhttp.send();
</t>
<t tx="leo.20210414180912.74">function setup(data) {
  that.data = data;
  var div = document.createElement('div');
  div.id = 'playBar';
  that.view.view3D.appendChild(div);
  that.button = document.createElement('button');
  that.button.id = 'playPauseButton';
  var action = (that.gui == 'play') ? 'pause' : 'play';
  that.button.style.backgroundImage = 'url(' + webots.WwiUrl + action + '.png)';
  that.button.style.padding = '0';
  that.button.onclick = triggerPlayPauseButton;
  div.appendChild(that.button);
  var slider = document.createElement('div');
  slider.id = 'playSlider';
  div.appendChild(slider);
  that.playSlider = $('#playSlider').slider({
      change: function(e, ui) { updateSlider(ui.value) },
      slide: function(e, ui) { updateSlider(ui.value) },
      start: function(e, ui) { that.sliding = true; },
      stop: function(e, ui) { that.sliding = false; }
  });
  that.start = new Date().getTime();
  that.step = 0;
  that.previousStep = 0;
  updateAnimation();
  if (that.onready)
    that.onready();
}

</t>
<t tx="leo.20210414180912.75">function elapsedTime() {
  var end = new Date().getTime();
  return end - that.start;
}

</t>
<t tx="leo.20210414180912.76">function triggerPlayPauseButton() {
  that.button.style.backgroundImage = 'url(' + webots.WwiUrl + that.gui + '.png)';
  if (that.gui == 'play') {
    that.gui = 'pause';
    if (that.step &lt; 0 || that.step &gt;= that.data.frames.length) {
      that.start = new Date().getTime();
      updateAnimationState(true);
    } else
      that.start = new Date().getTime() - that.data.basicTimeStep * that.step;
  } else {
    that.gui = 'play';
    that.start = new Date().getTime()  - that.data.basicTimeStep * that.step;
    requestAnimationFrame(updateAnimation);
  }
}

</t>
<t tx="leo.20210414180912.77">function connectSliderEvents() {
  that.playSlider = that.playSlider.slider({
    change: function(e, ui) { updateSlider(ui.value); },
    slide: function(e, ui) { updateSlider(ui.value); },
    start: function(e, ui) { that.sliding = true; },
    stop: function(e, ui) { that.sliding = false; }
  });
}

</t>
<t tx="leo.20210414180912.78">function disconnectSliderEvents() {
  that.playSlider.slider({change: null, slide: null});
}

</t>
<t tx="leo.20210414180912.79">function updateSlider(value) {
  that.step = Math.floor(that.data.frames.length * value / 100);
  that.start = (new Date().getTime()) - Math.floor(that.data.basicTimeStep * that.step);
  updateAnimationState(false);
}

</t>
<t tx="leo.20210414180912.8">this.onresize = function() {
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var viewHeight = parseFloat($(that.x3dNode).css('height').slice(0, -2));
  var viewWidth = parseFloat($(that.x3dNode).css('width').slice(0, -2));
  if (that.viewpointFieldOfView == null) {
    var fieldOfView = viewpoint.getAttribute('fieldOfView');
    // Sometimes the page is not fully loaded by that point and the field of view is not yet available.
    // In that case we add a callback at the end of the queue to try again when all other callbacks are finished.
    if (fieldOfView == null) {
      setTimeout(that.onresize, 0);
      return;
    }
    that.viewpointFieldOfView = fieldOfView;
  }

  var fieldOfViewY = that.viewpointFieldOfView
  if (viewWidth &gt; viewHeight) {
    var tanHalfFieldOfViewY = Math.tan(0.5 * that.viewpointFieldOfView) * viewHeight / viewWidth;
    fieldOfViewY =  2.0 * Math.atan(tanHalfFieldOfViewY);
  }

  viewpoint.setAttribute('fieldOfView', fieldOfViewY);
}
</t>
<t tx="leo.20210414180912.80">function updateAnimationState(moveSlider) {
  if (moveSlider) {
    that.step = Math.floor(elapsedTime() / that.data.basicTimeStep);
    if (that.step &lt; 0 || that.step &gt;= that.data.frames.length) {
      if (that.loop) {
        if (that.step &gt; that.data.frames.length) {
          that.step = 0;
          that.previousStep = 0;
          that.start = new Date().getTime();
        } else
          return;
      } else if (that.gui == 'play') {
        triggerPlayPauseButton();
        return;
      } else
        return;
    }
  }
  var appliedIds = [];
  if (that.data.frames[that.step].hasOwnProperty('poses')) {
    var poses = that.data.frames[that.step].poses;
    for (var p = 0; p &lt; poses.length; p++) {
      that.view.applyPose(poses[p]);
      appliedIds[appliedIds.length] = poses[p].id;
    }
  }
  // lookback mechanism: search in history
  if (that.step != that.previousStep + 1) {
    var previousPoseStep;
    if (that.step &gt; that.previousStep)
      // in forward animation check only the changes since last pose
      previousPoseStep = that.previousStep;
    else
      previousPoseStep = 0;
    var allIds = that.data.ids.split(';');
    for (var i = 0; i &lt; allIds.length; i++) {
      var id = parseInt(allIds[i]);
      if (appliedIds.indexOf(id) == -1) {
        outer:
        for (var f = that.step - 1; f &gt;= previousPoseStep; f--) {
          if (that.data.frames[f].poses) {
            for (var p = 0; p &lt; that.data.frames[f].poses.length; p++) {
              if (that.data.frames[f].poses[p].id == id) {
                that.view.applyPose(that.data.frames[f].poses[p]);
                break outer;
              }
            }
          }
        }
      }
    }
  }
  if (moveSlider) {
    disconnectSliderEvents();
    that.playSlider.slider('option', 'value', 100 * that.step / that.data.frames.length);
    connectSliderEvents();
  }
  that.previousStep = that.step;
  that.view.time = that.data.frames[that.step].time;
  if (that.view.followedObject != null &amp;&amp; that.view.followedObject != 'none')
    that.view.updateViewpointPosition(!moveSlider | that.step == 0);
}

</t>
<t tx="leo.20210414180912.81">function updateAnimation() {
  if (that.gui == 'play') {
    updateAnimationState(true);
    requestAnimationFrame(updateAnimation);
  }
}
</t>
<t tx="leo.20210414180912.82">webots.Server = function(url, view, onready) {
  var that = this;
  this.view = view;
  this.onready = onready;
  // url has the following form: "ws(s)://cyberbotics2.cyberbotics.com:80/simple/worlds/simple.wbt"
  var n = url.indexOf('/', 6);
  var m = url.lastIndexOf('/');
  this.url = 'http' + url.substring(2, n);    // e.g., "http(s)://cyberbotics2.cyberbotics.com:80"
  this.project = url.substring(n + 1, m - 7); // e.g., "simple"
  this.worldFile = url.substring(m + 1);      // e.g., "simple.wbt"
  this.controllers = [];
  var xhr = new XMLHttpRequest();
  xhr.open('GET', this.url + '/session', true);
  $("#webotsProgressMessage").html("Connecting to session server...");
  xhr.onreadystatechange = function(e) {
    if (xhr.readyState != 4)
      return;
    if (xhr.status != 200)
      return;
    var data = xhr.responseText;
    if (data.startsWith("Error:")) {
      $("#webotsProgress").hide();
      errorMessage = data.substring(6).trim();
      errorMessage = errorMessage.charAt(0).toUpperCase() + errorMessage.substring(1)
      webots.alert("Session server error", errorMessage);
      return;
    }
    that.socket = new WebSocket(data + '/client');
    @others
  }
  xhr.send();
}

</t>
<t tx="leo.20210414180912.83"></t>
<t tx="leo.20210414180912.84">that.socket.onopen = function(event) {
  var host = location.protocol + "//" + location.hostname.replace(/^www./, ''); // remove 'www' prefix
  var user = webots.Owner;
  if (user == null)
    user = webots.userCredentials();
  this.send('{ "init" : [ "' + host + '", "' + that.project + '", "' + that.worldFile + '", "' + user + '" ] }');
  $("#webotsProgressMessage").html("Starting simulation...");
}
</t>
<t tx="leo.20210414180912.85">that.socket.onclose = function(event) {
  view.console.info("Disconnected to the Webots server.")
}
</t>
<t tx="leo.20210414180912.86">that.socket.onmessage = function(event) {
  var message = event.data;
  if (message.indexOf('webots:ws://') == 0 || message.indexOf('webots:wss://') == 0)
    view.stream = new webots.Stream(message.substring(7), view, that.onready);
  else if (message.indexOf('controller:') == 0) {
    var n = message.indexOf(':', 11);
    var controller = {};
    controller.name = message.substring(11, n);
    controller.port = message.substring(n + 1);
    view.console.info("Using controller " + controller.name + " on port " + controller.port);
    that.controllers.push(controller);
  } else if (message.indexOf('queue:') == 0)
    view.console.error("The server is saturated. Queue to wait: " + message.substring(6) + " client(s).");
  else if (message == ".") { // received every 5 seconds when Webots is running
    // nothing to do
  } else if (message.indexOf('reset controller:') == 0)
    view.stream.socket.send('sync controller:' + message.substring(18).trim());
  else
    console.log('Received an unknown message from the Webots server socket: "' + message + '"');
}
</t>
<t tx="leo.20210414180912.87">that.socket.onerror = function(event) {
  view.console.error("Cannot connect to the simulation server");
}
</t>
<t tx="leo.20210414180912.88">webots.Server.prototype.resetController = function(filename) {
  this.socket.send('{ "reset controller" : "' + filename + '" }');
}

</t>
<t tx="leo.20210414180912.89">webots.Stream = function(url, view, onready) {
  var that = this;
  this.view = view;
  this.onready = onready;

  this.socket = new WebSocket(url);
  $("#webotsProgressMessage").html("Connecting to Webots instance...");
  @others
}

</t>
<t tx="leo.20210414180912.9">this.ondialogwindow = function(opening) {
  // Pause the simulation if needed when a pop-up dialog window is open
  // and restart running the simulation when it is closed
  if (opening &amp;&amp; that.isAutomaticallyPaused === undefined) {
    that.isAutomaticallyPaused = webots.currentView.pauseButton.style.display == 'inline';
    that.pauseButton.click();
  } else if (!opening &amp;&amp; that.isAutomaticallyPaused) {
    that.real_timeButton.click();
    that.isAutomaticallyPaused = undefined;
  }
}
window.onresize = this.onresize;
this.robotWindowNames = {}; // map robot name to robot window name used as key in robotWindows lists
this.robotWindows = {};
this.followedObject = null; // after initialization contains the id of the followed node or -1 if no object is followed
// If the followed object has moved since the last time we updated the viewpoint position, this field will contain a
// vector with the translation applied to the object.
this.followedObjectDeltaPosition = null;
this.viewpointMass = 1.0; // Mass of the viewpoint used during the object following algorithm.
this.viewpointFriction = 0.05; // Friction applied to the viewpoint whenever it is going faster than the followed object.
this.viewpointForce = null; // Vector with the force that will be applied to the viewpoint for the next delta T.
this.viewpointVelocity = null; // Current velocity of the viewpoint.
this.viewpointLastUpdate = undefined; // Last time we updated the position of the viewpoint.
this.wheelFocus = false;
this.wheelTimeout = null;
this.onmousedown = null;
this.onworldloaded = null;
this.view3D = view3D;
this.viewpointFieldOfView = null;
// prevent the backspace key to quit the simulation page
var rx = /INPUT|SELECT|TEXTAREA/i
</t>
<t tx="leo.20210414180912.90">this.socket.onopen = function() {
  var mode = that.view.mode;
  if (mode == 'video')
    mode += ': ' + that.view.video.width + 'x' + that.view.video.height;
  else if (that.view.broadcast)
    mode += ';broadcast';
  that.socket.send(mode);
}
</t>
<t tx="leo.20210414180912.91">this.socket.onclose = function(event) {
  view.onerror("Disconnected from " + url + " (" + event.code + ")");
  if ((event.code &gt; 1001 &amp;&amp; event.code &lt; 1016) || (event.code == 1001 &amp;&amp; view.quitting == false)) { // https://tools.ietf.org/html/rfc6455#section-7.4.1
    webots.alert("Streaming server error",
                 "Connection closed abnormally.&lt;br&gt;(Error code: " + event.code + ")&lt;br&gt;&lt;br&gt;" +
                 "Please reload the simulation by clicking " +
                 "&lt;a href='" + window.location.href + "'&gt;here&lt;/a&gt;.");
  }
  destroyWorld();
  if (view.onclose)
    view.onclose();
}
</t>
<t tx="leo.20210414180912.92">this.socket.onmessage = function(event) {
  var lines;
  var data = event.data;
  if (data.startsWith('robot:') ||
      data.startsWith('stdout:') ||
      data.startsWith('stderr:')) {
    lines = data.split('\n'); // in that case, we support one message per line
    for (var i=0; i&lt;lines.length; i++) {
      var line = lines[i];
      if (line == '') // FIXME: should not happen
        continue;
      if (line.startsWith('stdout:'))
        view.console.stdout(line.substring(7));
      else if (line.startsWith('stderr:'))
        view.console.stderr(line.substring(7));
      else if (line.startsWith('robot:')) {
        var second_colon_index = line.indexOf(':', 6);
        var robot = line.substring(6, second_colon_index);
        var message = line.substring(second_colon_index + 1);
        that.view.onrobotmessage(robot, message);
      }
    }
  } else if (data.startsWith('application/json:')) {
    if (that.view.time !== undefined) { // otherwise ignore late updates until the scene loading is completed
      data = data.substring(data.indexOf(':') + 1);
      var frame = JSON.parse(data);
      that.view.time = frame.time;
      $('#webotsClock').html(webots.parseMillisecondsIntoReadableTime(frame.time));
      if (frame.hasOwnProperty('poses'))
        for (var i = 0; i &lt; frame.poses.length; i++)
          that.view.applyPose(frame.poses[i]);
      if (that.view.followedObject != null &amp;&amp; that.view.followedObject != 'none')
        that.view.updateViewpointPosition();
    }
  } else if (data.startsWith('node:')) {
    data = data.substring(data.indexOf(':') + 1);
    var parser = new DOMParser();
    var x3d = parser.parseFromString(data, 'text/xml').children[0];
    that.view.x3dScene.appendChild(x3d);
  } else if (data.startsWith('delete:')) {
    data = data.substring(data.indexOf(':') + 1).trim();
    var itemToDelete = document.getElementById('n' + data);
    if (itemToDelete) {
      if (that.selection == itemToDelete)
        that.selection = null;
      itemToDelete.parentElement.removeChild(itemToDelete);
    }
  } else if (data.startsWith('model:')) {
    $("#webotsProgressMessage").html("Loading 3D scene...");
    destroyWorld();
    data = data.substring(data.indexOf(":") + 1).trim();
    if (!data) // received an empty model case: just destroy the view
      return;
    var scene = data.substring(data.indexOf('&lt;Scene&gt;') + 8, data.lastIndexOf('&lt;/Scene&gt;'));
    $(that.view.x3dScene).append(scene);
    that.view.onresize();
  } else if (data.startsWith('image')) {
    textureUrl = data.substring(data.indexOf('[') + 1, data.indexOf(']'));
    data = data.substring(data.indexOf(':') + 1);
    // replace in ImageTexture nodes
    var textures = that.view.x3dScene.getElementsByTagName('ImageTexture');
    for (var i = 0; i &lt; textures.length; i++) {
      texture = textures[i];
      if (texture.getAttribute('url') == ('"' + textureUrl + '"'))
        texture.setAttribute('url', data);
    }
    // replace in Background nodes
    var backgrounds = that.view.x3dScene.getElementsByTagName('Background');
    var backgroundUrlFieldNames = ['frontUrl', 'backUrl', 'leftUrl', 'rightUrl', 'topUrl', 'bottomUrl'];
    for (var i = 0; i &lt; backgrounds.length; i++) {
      background = backgrounds[i];
      for (var j = 0; j &lt; backgroundUrlFieldNames.length; j++) {
        backgroundUrlFieldName = backgroundUrlFieldNames[j];
        if (background.getAttribute(backgroundUrlFieldName) == ('"' + textureUrl + '"'))
          background.setAttribute(backgroundUrlFieldName, data);
      }
    }
  } else if (data.startsWith('video: ')) {
    console.log("Received data = " + data);
    var list = data.split(" ");
    var url = list[1];
    var stream_id = list[2];
    console.log("Received video message on " + url + " stream = " + stream_id);
    that.VideoStream = new webots.VideoStream(url, view.video, document.getElementById('BitrateViewer'), stream_id);
    if (that.onready)
      that.onready();
  } else if (data.startsWith('set controller:')) {
    var slash = data.indexOf('/', 15);
    var dirname = data.substring(15, slash);
    var filename = data.substring(slash + 1, data.indexOf(':', slash + 1));
    if (that.view.editor.dirname == dirname)
      that.view.editor.addFile(filename, data.substring(data.indexOf('\n') + 1));  // remove the first line
    else
      console.log("Warning: " + filename + " not in controller directory: " + dirname + " != " + that.view.editor.dirname);
  } else if (data == "pause") {
    that.view.pauseButton.style.display = 'none';
    that.view.real_timeButton.style.display = 'inline';
    if (that.view.timeout &gt; 0 &amp;&amp; !that.view.isAutomaticallyPaused) {
      that.view.deadline = that.view.timeout;
      if (that.view.time !== undefined)
        that.view.deadline += that.view.time;
      $('#webotsTimeout').html(webots.parseMillisecondsIntoReadableTime(that.view.deadline));
    }
  } else if (data == "scene load completed") {
    that.view.time = 0;
    $('#webotsClock').html(webots.parseMillisecondsIntoReadableTime(0));
    if (that.onready)
      that.onready();
  }
  else
    console.log("WebSocket error: Unknown message received: \"" + data + "\"");
}
</t>
<t tx="leo.20210414180912.93">this.socket.onerror = function(event) {
  destroyWorld();
  view.onerror("WebSocket error: " + event.data);
}
</t>
<t tx="leo.20210414180912.94">function destroyWorld() {
  that.view.selection = null;
  if (that.view.x3dScene)
    while (that.view.x3dScene.hasChildNodes())
      // remove from last to avoid issues with USE/DEF nodes
      that.view.x3dScene.removeChild(that.view.x3dScene.lastChild);
}
</t>
<t tx="leo.20210414180912.95">webots.Stream.prototype.close = function() {
  if (this.socket)
    this.socket.close();
  if (this.videoStream)
    this.videoStream.close();
}

</t>
<t tx="leo.20210414180912.96">function webotsClampDialogSize(preferredGeometry) {
  if ($("#playerDiv").height === undefined || $("#playerDiv").width === undefined)
    return preferredGeometry;

  var maxHeight = $("#playerDiv").height() - preferredGeometry.top - 20; // 20 is chosen arbitrarily
  var maxWidth = $("#playerDiv").width() - preferredGeometry.left - 20; // 20 is chosen arbitrarily
  var height = preferredGeometry.height;
  var width = preferredGeometry.width;
  if (maxHeight &lt; height)
    height = maxHeight;
  if (maxWidth &lt; width)
    width = maxWidth;
  return {width: width, height: height};
}

</t>
<t tx="leo.20210414180912.97">function webotsOpenDialog() {
  $(this).parent().css('opacity', 0.9);
  $(this).parent().hover(function () {
    $(this).css('opacity', 0.99);
  }, function (event) {
    $(this).css('opacity', 0.9);
  });
}

// the following two functions are used to make the resize and drag of the dialog
</t>
<t tx="leo.20210414180912.98"></t>
<t tx="leo.20210414180912.99">// steady (i.e., not loose the grab while resizing/dragging the dialog quickly)
function webotsDisablePointerEvents() {
  document.body.style['pointer-events'] = 'none';
}
</t>
<t tx="leo.20210414181008.1"></t>
<t tx="leo.20210414181014.1">/*
 * Injects a Webots 3D view inside a HTML tag.
 * @class
 * @classdesc
 *   The Webots view object displays a 3D view on a web page.
 *   This view represents a Webots simulation world that may be
 *   connected to a webots instance running on a remote server.
 *   This library depends on the x3dom-full.js library
 * @example
 *   // Example: Initialize from a Webots streaming server
 *   var view = new webots.View(document.getElementById("myDiv"));
 *   view.open("ws://localhost:80/simple/worlds/simple.wbt");
 *   // or view.open("ws://localhost:80");
 *   // or view.open("file.x3d");
 *   view.onready = function() {
 *       // the initialization is done
 *   }
 *   view.onclose = function() {
 *       view = null;
 *   }
 */

/* global x3dom: false */
/* global ace: false */
/* global MathJax: false */
/* eslint no-extend-native: ["error", { "exceptions": ["String"] }] */
/* eslint no-eval: "off" */

/* The following member variables should be set by the application:

webots.User1Id             // ID of the main user (integer value &gt; 0). If 0 or unset, the user is not logged in.
webots.User1Name           // user name of the main user.
webots.User1Authentication // password or authentication for the main user (empty or unset if user not authenticated).
webots.User2Id             // ID of the secondary user (in case of a soccer match between two different users). 0 or unset if not used.
webots.User2Name           // user name of the secondary user.
webots.CustomData          // application specific data to be passed to the simulation server

*/

var webots = window.webots || {};

var scripts = document.getElementsByTagName('script');
webots.WwiUrl = scripts[scripts.length - 1].src;
webots.WwiUrl = webots.WwiUrl.substr(0, webots.WwiUrl.lastIndexOf('/') + 1); // remove "webots.js"

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20210414181027.1">webots.View = function(view3D, mobile) {
  webots.currentView = this;
  var that = this;
  @others
};

</t>
<t tx="leo.20210414181027.10">$(document).bind('keydown keypress', function(e) {
  if (e.which === 8) { // backspace key
    if (!rx.test(e.target.tagName) || e.target.disabled || e.target.readOnly)
      e.preventDefault();
  }
});
this.view3D.className = view3D.className + ' webotsView';
$(this.view3D).append(
  "&lt;ul id='contextMenu'&gt;" +
  "&lt;li class='ui-widget-header'&gt;&lt;div id='contextMenuTitle'&gt;Object&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuFollow'&gt;&lt;div&gt;Follow&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuUnfollow'&gt;&lt;div&gt;Unfollow&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Zoom&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuRobotWindow'&gt;&lt;div id='contextMenuRobotWindowDiv'&gt;Robot window&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuEditController'&gt;&lt;div id='contextMenuEditControllerDiv'&gt;Edit controller&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Delete&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Properties&lt;/div&gt;&lt;/li&gt;" +
  '&lt;/ul&gt;');
$('#contextMenu').menu({items: '&gt; :not(.ui-widget-header)'});
$('#contextMenu').css('position', 'absolute');
$('#contextMenu').css('z-index', 1);
$('#contextMenu').css('display', 'none');
</t>
<t tx="leo.20210414181027.100">this.socket.onclose = function(event) {
  view.onerror('Disconnected from ' + url + ' (' + event.code + ')');
  if ((event.code &gt; 1001 &amp;&amp; event.code &lt; 1016) || (event.code === 1001 &amp;&amp; view.quitting === false)) { // https://tools.ietf.org/html/rfc6455#section-7.4.1
    webots.alert('Streaming server error',
      'Connection closed abnormally.&lt;br&gt;(Error code: ' + event.code + ')&lt;br&gt;&lt;br&gt;' +
      'Please reset the simulation by clicking ' +
      '&lt;a href="' + window.location.href + '"&gt;here&lt;/a&gt;.');
  }
  destroyWorld();
  if (view.onclose)
    view.onclose();
};
</t>
<t tx="leo.20210414181027.101">this.socket.onmessage = function(event) {
  var lines, i;
  var data = event.data;
  if (data.startsWith('robot:') ||
      data.startsWith('stdout:') ||
      data.startsWith('stderr:')) {
    lines = data.split('\n'); // in that case, we support one message per line
    for (i = 0; i &lt; lines.length; i++) {
      var line = lines[i];
      if (line === '') // FIXME: should not happen
        continue;
      if (line.startsWith('stdout:'))
        view.console.stdout(line.substring(7));
      else if (line.startsWith('stderr:'))
        view.console.stderr(line.substring(7));
      else if (line.startsWith('robot:')) {
        var secondColonIndex = line.indexOf(':', 6);
        var robot = line.substring(6, secondColonIndex);
        var message = line.substring(secondColonIndex + 1);
        that.view.onrobotmessage(robot, message);
      }
    }
  } else if (data.startsWith('application/json:')) {
    if (that.view.time !== undefined) { // otherwise ignore late updates until the scene loading is completed
      data = data.substring(data.indexOf(':') + 1);
      var frame = JSON.parse(data);
      that.view.time = frame.time;
      $('#webotsClock').html(webots.parseMillisecondsIntoReadableTime(frame.time));
      if (frame.hasOwnProperty('poses')) {
        for (i = 0; i &lt; frame.poses.length; i++)
          that.view.applyPose(frame.poses[i]);
      }
      if (that.view.followedObject != null &amp;&amp; that.view.followedObject !== 'none')
        that.view.updateViewpointPosition();
    }
  } else if (data.startsWith('node:')) {
    data = data.substring(data.indexOf(':') + 1);
    var parentId = data.split(':')[0];
    data = data.substring(data.indexOf(':') + 1);
    var parser = new DOMParser();
    var x3d = parser.parseFromString(data, 'text/xml').children[0];
    if (parentId === '0')
      that.view.x3dScene.appendChild(x3d);
    else
      document.getElementById('n' + parentId).appendChild(x3d);
  } else if (data.startsWith('delete:')) {
    data = data.substring(data.indexOf(':') + 1).trim();
    var itemToDelete = document.getElementById('n' + data);
    if (itemToDelete) {
      if (that.selection === itemToDelete)
        that.selection = null;
      itemToDelete.parentElement.removeChild(itemToDelete);
    }
  } else if (data.startsWith('model:')) {
    $('#webotsProgressMessage').html('Loading 3D scene...');
    destroyWorld();
    data = data.substring(data.indexOf(':') + 1).trim();
    if (!data) // received an empty model case: just destroy the view
      return;
    var scene = data.substring(data.indexOf('&lt;Scene&gt;') + 8, data.lastIndexOf('&lt;/Scene&gt;'));
    $(that.view.x3dScene).append(scene);
    that.view.onresize();
  } else if (data.startsWith('image')) {
    var textureUrl = data.substring(data.indexOf('[') + 1, data.indexOf(']'));
    data = data.substring(data.indexOf(':') + 1);
    // replace in ImageTexture nodes
    var textures = that.view.x3dScene.getElementsByTagName('ImageTexture');
    for (i = 0; i &lt; textures.length; i++) {
      var texture = textures[i];
      if (that.compareTextureUrl(texture.getAttribute('url'), textureUrl))
        texture.setAttribute('url', data);
    }
    // replace in Background nodes
    var backgrounds = that.view.x3dScene.getElementsByTagName('Background');
    var backgroundUrlFieldNames = ['frontUrl', 'backUrl', 'leftUrl', 'rightUrl', 'topUrl', 'bottomUrl'];
    for (i = 0; i &lt; backgrounds.length; i++) {
      var background = backgrounds[i];
      for (var j = 0; j &lt; backgroundUrlFieldNames.length; j++) {
        var backgroundUrlFieldName = backgroundUrlFieldNames[j];
        if (that.compareTextureUrl(background.getAttribute(backgroundUrlFieldName), textureUrl))
          background.setAttribute(backgroundUrlFieldName, data);
      }
    }
  } else if (data.startsWith('video: ')) {
    console.log('Received data = ' + data);
    var list = data.split(' ');
    var url = list[1];
    var streamId = list[2];
    console.log('Received video message on ' + url + ' stream = ' + streamId);
    that.VideoStream = new webots.VideoStream(url, view.video, document.getElementById('BitrateViewer'), streamId);
    if (that.onready)
      that.onready();
  } else if (data.startsWith('set controller:')) {
    var slash = data.indexOf('/', 15);
    var dirname = data.substring(15, slash);
    var filename = data.substring(slash + 1, data.indexOf(':', slash + 1));
    if (that.view.editor.dirname === dirname)
      that.view.editor.addFile(filename, data.substring(data.indexOf('\n') + 1)); // remove the first line
    else
      console.log('Warning: ' + filename + ' not in controller directory: ' + dirname + ' != ' + that.view.editor.dirname);
  } else if (data === 'pause') {
    that.view.pauseButton.style.display = 'none';
    that.view.real_timeButton.style.display = 'inline';
    if (that.view.timeout &gt; 0 &amp;&amp; !that.view.isAutomaticallyPaused) {
      that.view.deadline = that.view.timeout;
      if (that.view.time !== undefined)
        that.view.deadline += that.view.time;
      $('#webotsTimeout').html(webots.parseMillisecondsIntoReadableTime(that.view.deadline));
    }
  } else if (data === 'real-time' || data === 'run' || data === 'fast') {
    that.view.pauseButton.style.display = 'inline';
    that.view.real_timeButton.style.display = 'none';
    if (that.view.timeout &gt;= 0)
      that.view.stream.socket.send('timeout:' + that.view.timeout);
  } else if (data === 'scene load completed') {
    that.view.time = 0;
    $('#webotsClock').html(webots.parseMillisecondsIntoReadableTime(0));
    if (that.onready)
      that.onready();
  } else if (data === 'reset finished') {
    // remove labels
    var labels = document.getElementsByClassName('webotsLabel');
    for (i = labels.length - 1; i &gt;= 0; i--) {
      var element = labels.item(i);
      element.parentNode.removeChild(element);
    }
    $('#webotsClock').html(webots.parseMillisecondsIntoReadableTime(0));
    if (that.onready)
      that.onready();
    that.view.deadline = that.view.timeout;
    $('#webotsTimeout').html(webots.parseMillisecondsIntoReadableTime(that.view.deadline));
    // restore viewpoint
    var viewpoint = that.view.x3dScene.getElementsByTagName('Viewpoint')[0];
    viewpoint.setAttribute('position', that.view.initialViewpointPosition);
    viewpoint.setAttribute('orientation', that.view.initialViewpointOrientation);
    that.view.updateViewpointPosition(true);
  } else if (data.startsWith('label')) {
    var semiColon = data.indexOf(';');
    var id = data.substring(data.indexOf(':'), semiColon);
    var previousSemiColon;
    var labelProperties = []; // ['font', 'color', 'size', 'x', 'y', 'text']
    for (i = 0; i &lt; 5; i++) {
      previousSemiColon = semiColon + 1;
      semiColon = data.indexOf(';', previousSemiColon);
      labelProperties.push(data.substring(previousSemiColon, semiColon));
    }
    var text = data.substring(semiColon + 1, data.length);
    var labelElement = document.getElementById('label' + id);
    if (labelElement == null) {
      labelElement = document.createElement('div');
      labelElement.id = 'label' + id;
      labelElement.className = 'webotsLabel';
      that.view.x3dNode.appendChild(labelElement);
    }
    labelElement.style.fontFamily = labelProperties[0];
    labelElement.style.color = labelProperties[1];
    labelElement.style.fontSize = $(that.view.x3dNode).height() * labelProperties[2] / 2.25 + 'px'; // 2.25 is an empirical value to match with Webots appearance
    labelElement.style.left = $(that.view.x3dNode).width() * labelProperties[3] + 'px';
    labelElement.style.top = $(that.view.x3dNode).height() * labelProperties[4] + 'px';
    labelElement.innerHTML = text;
  } else
    console.log('WebSocket error: Unknown message received: "' + data + '"');
};
</t>
<t tx="leo.20210414181027.102">this.socket.onerror = function(event) {
  destroyWorld();
  view.onerror('WebSocket error: ' + event.data);
};
</t>
<t tx="leo.20210414181027.103">function destroyWorld() {
  that.view.selection = null;
  if (that.view.x3dScene) {
    while (that.view.x3dScene.hasChildNodes())
      // remove from last to avoid issues with USE/DEF nodes
      that.view.x3dScene.removeChild(that.view.x3dScene.lastChild);
  }

  // remove labels
  var labels = document.getElementsByClassName('webotsLabel');
  for (var i = labels.length - 1; i &gt;= 0; i--) {
    var element = labels.item(i);
    element.parentNode.removeChild(element);
  }
}
</t>
<t tx="leo.20210414181027.104">webots.Stream.prototype.compareTextureUrl = function(attributeUrl, textureUrl) {
  if (!attributeUrl || !textureUrl)
    return false;
  if (typeof attributeUrl === 'object')
    // Default url attribute is an Array instance (x3dom.field.MFString) of length 0
    return false;

  var value = attributeUrl.trim();
  if (!(value.startsWith('"') &amp;&amp; value.endsWith('"')))
    // single texture without list quotes
    return attributeUrl === textureUrl;

  // Simple algorithm supporting multiple textures with some limitations:
  // 1. the url attribute priority order is not respected: the first texture received by Webots is used
  // 2. escaped double quotes in url are not supported: for example "textures/my_\"texture\".jpeg"
  var start = 1;
  var end = value.indexOf('"', start);
  while (end &gt;= 0) {
    var url = value.slice(start, end);
    if (url === textureUrl)
      return true;
    start = value.indexOf('"', end + 1) + 1;
    if (start &lt;= 0)
      break;
    end = value.indexOf('"', start);
  }
  return false;
};

</t>
<t tx="leo.20210414181027.105">webots.Stream.prototype.close = function() {
  if (this.socket)
    this.socket.close();
  if (this.videoStream)
    this.videoStream.close();
};

</t>
<t tx="leo.20210414181027.106">function webotsClampDialogSize(preferredGeometry) {
  if ($('#playerDiv').height === undefined || $('#playerDiv').width === undefined)
    return preferredGeometry;

  var maxHeight = $('#playerDiv').height() - preferredGeometry.top - $('#toolBar').height() - 20; // 20 is chosen arbitrarily
  var maxWidth = $('#playerDiv').width() - preferredGeometry.left - 20; // 20 is chosen arbitrarily
  var height = preferredGeometry.height;
  var width = preferredGeometry.width;
  if (maxHeight &lt; height)
    height = maxHeight;
  if (maxWidth &lt; width)
    width = maxWidth;
  return {width: width, height: height};
}

</t>
<t tx="leo.20210414181027.107">function webotsResizeDialogOnOpen(dialog) {
  var w = $(dialog).parent().width();
  var h = $(dialog).parent().height();
  var clampedSize = webotsClampDialogSize({left: 0, top: 0, width: w, height: h});
  if (clampedSize.width &lt; w)
    $(dialog).dialog('option', 'width', clampedSize.width);
  if (clampedSize.height &lt; h)
    $(dialog).dialog('option', 'height', clampedSize.height);
}

</t>
<t tx="leo.20210414181027.108">function webotsOpenDialog() {
  webotsResizeDialogOnOpen(this);
  $(this).parent().css('opacity', 0.9);
  $(this).parent().hover(function() {
    $(this).css('opacity', 0.99);
  }, function(event) {
    $(this).css('opacity', 0.9);
  });
}

</t>
<t tx="leo.20210414181027.109"></t>
<t tx="leo.20210414181027.11">$('#contextMenu').on('menuselect', function(event, ui) {
  if (ui.item.children().hasClass('ui-state-disabled'))
    return;
  var id = ui.item.attr('id');
  if (id === 'contextMenuFollow')
    that.follow(that.selection.id);
  else if (id === 'contextMenuUnfollow')
    that.follow('none');
  else if (id === 'contextMenuEditController') {
    var controller = that.selection.getAttribute('controller');
    $('#webotsEditor').dialog('open');
    $('#webotsEditor').dialog('option', 'title', 'Controller: ' + controller);
    if (that.editor.dirname !== controller) {
      that.editor.closeAllTabs();
      that.editor.dirname = controller;
      that.stream.socket.send('get controller:' + controller);
    }
  } else if (id === 'contextMenuRobotWindow') {
    var robotName = that.selection.getAttribute('name');
    var win = that.robotWindows[that.robotWindowNames[robotName]];
    if (win) {
      if (win === that.infoWindow) {
        if (!that.infoWindow.isOpen())
          that.toggleInfo();
      } else
        win.open();
    } else
      console.log('No valid robot window for robot: ' + that.selection.getAttribute('name'));
  } else
    console.log('Unknown menu item: ' + id);
  $('#contextMenu').css('display', 'none');
});
this.console = new webots.Console(view3D, this.mobileDevice);
this.editor = new webots.Editor(view3D, this);
this.infoWindow = null;
this.selection = null;
this.x3dScene = null;
this.x3dNode = null;
this.initialViewpointPosition = null;
this.initialViewpointOrientation = null;
this.mouseState = {
  'initialized': false,
  'mouseDown': 0,
  'moved': false,
  'pickPosition': null,
  'wheelFocus': false,
  'wheelTimeout': null
};
this.animation = null;
this.enableNavigation = true;
this.debug = false;
this.timeout = 60 * 1000; // default to one minute
this.time = undefined;
this.deadline = this.timeout;
this.runOnLoad = false;
this.quitting = false;
</t>
<t tx="leo.20210414181027.110">function webotsMobileCreateDialog() {
  // mobile only setup
  var closeButton = $('button:contains("WbClose")');
  closeButton.html('');
  closeButton.removeClass('ui-button-text-only');
  closeButton.addClass('mobile-dialog-close-button');
  closeButton.addClass('ui-button-icon-primary');
  closeButton.prepend('&lt;span class="ui-icon ui-icon-closethick"&gt;&lt;/span&gt;');
}

</t>
<t tx="leo.20210414181027.111">function webotsAddMobileDialogAttributes(params, panel) {
  params.dialogClass = 'mobile-no-default-buttons';
  params.create = webotsMobileCreateDialog;
  params.buttons = { 'WbClose': function() { $(panel).dialog('close'); } };
}

// the following two functions are used to make the resize and drag of the dialog
</t>
<t tx="leo.20210414181027.112">// steady (i.e., not loose the grab while resizing/dragging the dialog quickly)
function webotsDisablePointerEvents() {
  document.body.style['pointer-events'] = 'none';
}
</t>
<t tx="leo.20210414181027.113">function webotsEnablePointerEvents() {
  document.body.style['pointer-events'] = 'auto';
}

</t>
<t tx="leo.20210414181027.114">webots.Editor = function(parent, view) {
  var that = this;
  @others
};

</t>
<t tx="leo.20210414181027.115">function webotsEditorResize() {
  var padding = $('#webotsEditorTab').outerHeight() - $('#webotsEditorTab').height();
  $('#webotsEditorTab').height(that.tabs.clientHeight - that.tabsHeader.scrollHeight - padding);
  that.editor.resize();
}
</t>
<t tx="leo.20210414181027.116">function hideMenu() {
  if ($('#webotsEditorMenu').hasClass('pressed'))
    $('#webotsEditorMenu').removeClass('pressed');
}
</t>
<t tx="leo.20210414181027.117">function openResetConfirmDialog(allFiles) {
  that.resetAllFiles = allFiles;
  var titleText, message;
  message = 'Permanently reset ';
  if (allFiles) {
    message += 'all the files';
    titleText = 'Reset files?';
  } else {
    message += 'this file';
    titleText = 'Reset file?';
  }
  message += ' to the original version?';
  message += '&lt;br/&gt;&lt;br/&gt;Your modifications will be lost.';
  var confirmDialog = document.createElement('div');
  that.panel.appendChild(confirmDialog);
  $(confirmDialog).html(message);
  $(confirmDialog).dialog({
    title: titleText,
    modal: true,
    autoOpen: true,
    resizable: false,
    dialogClass: 'alert',
    open: webotsOpenDialog,
    appendTo: that.parent,
    buttons: {
      'Cancel': function() {
        $(this).dialog('close');
        $('#webotsEditorConfirmDialog').remove();
      },
      'Reset': function() {
        $(this).dialog('close');
        $('#webotsEditorConfirmDialog').remove();
        if (that.resetAllFiles) {
          for (var i = 0; i &lt; that.filenames.length; i++)
            that.view.server.resetController(that.dirname + '/' + that.filenames[i]);
        } else
          that.view.server.resetController(that.dirname + '/' + that.filenames[that.currentSession]);
      }
    }
  });
  hideMenu();
}
this.view = view;
this.filenames = [];
this.needToUploadFiles = [];
this.sessions = [];
this.panel = document.createElement('div');
this.panel.id = 'webotsEditor';
this.panel.className = 'webotsTabContainer';
that.parent = parent;
parent.appendChild(this.panel);
var clampedSize = webotsClampDialogSize({left: 0, top: 0, width: 800, height: 600});
var params = {
  title: 'Editor',
  resize: webotsEditorResize,
  resizeStart: webotsDisablePointerEvents,
  resizeStop: webotsEnablePointerEvents,
  dragStart: webotsDisablePointerEvents,
  dragStop: webotsEnablePointerEvents,
  width: clampedSize.width,
  height: clampedSize.height,
  autoOpen: false,
  appendTo: parent,
  open: function() {
    webotsResizeDialogOnOpen(that.panel);
  }
};
if (this.view.mobileDevice)
  webotsAddMobileDialogAttributes(params, this.panel);
$(this.panel).dialog(params).dialogExtend({maximizable: !this.view.mobileDevice});
var edit = document.createElement('div');
edit.id = 'webotsEditorTab';
edit.className = 'webotsTab';
this.editor = ace.edit(edit);
this.sessions[0] = this.editor.getSession();
this.currentSession = 0;
this.tabs = document.createElement('div');
this.tabs.id = 'webotsEditorTabs';
this.tabs.className = 'webotsTabs';
this.tabsHeader = document.createElement('ul');
this.tabs.appendChild(this.tabsHeader);
this.tabs.appendChild(edit);
$(this.tabs).tabs({activate: function(event, ui) {
  that.currentSession = parseInt(ui.newTab.attr('id').substr(5)); // skip 'file-'
  that.editor.setSession(that.sessions[that.currentSession]);
}});
this.panel.appendChild(this.tabs);
this.menu = document.createElement('div');
this.menu.id = 'webotsEditorMenu';
var saveShortcut;
if (navigator.appVersion.indexOf('Mac') === -1)
  saveShortcut = 'Ctrl-S';
else // macOS
  saveShortcut = 'Cmd-S';
this.menu.innerHTML = '&lt;input type="image" id="webotsEditorMenuImage" width="17px" src="' + webots.WwiUrl + '/images/menu.png"&gt;' +
                      '&lt;div id="webotsEditorMenuContent"&gt;' +
                      '&lt;div id="webotsEditorSaveAction" class="webotsEditorMenuContentItem" title="Save current file"&gt;Save&lt;span style="float:right"&gt;&lt;i&gt;&lt;small&gt;' + saveShortcut + '&lt;/small&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;' +
                      '&lt;div id="webotsEditorSaveAllAction" class="webotsEditorMenuContentItem" title="Save all the files"&gt;Save All&lt;/div&gt;' +
                      '&lt;div id="webotsEditorResetAction" class="webotsEditorMenuContentItem" title="Reset current file to the original version"&gt;Reset&lt;/div&gt;' +
                      '&lt;div id="webotsEditorResetAllAction" class="webotsEditorMenuContentItem" title="Reset all the files to the original version"&gt;Reset All&lt;/div&gt;' +
                      '&lt;/div&gt;';
this.panel.appendChild(this.menu);
this.editor.commands.addCommand({
  name: 'save',
  bindKey: {win: 'Ctrl-S', mac: 'Cmd-S'},
  exec: function(editor) {
    that.save(that.currentSession);
  }
});
</t>
<t tx="leo.20210414181027.118">$('#webotsEditorSaveAction').click(function() {
  that.save(that.currentSession);
  hideMenu();
});
</t>
<t tx="leo.20210414181027.119">$('#webotsEditorSaveAllAction').click(function() {
  for (var i = 0; i &lt; that.filenames.length; i++)
    that.save(i);
  hideMenu();
});
</t>
<t tx="leo.20210414181027.12">webots.View.prototype.setTimeout = function(timeout) { // expressed in seconds
  if (timeout &lt; 0) {
    this.timeout = timeout;
    this.deadline = 0;
    return;
  }

  this.timeout = timeout * 1000; // convert to millisecons
  this.deadline = this.timeout;
  if (this.time !== undefined)
    this.deadline += this.time;
};

</t>
<t tx="leo.20210414181027.120">$('#webotsEditorResetAction').click(function() {
  openResetConfirmDialog(false);
});
</t>
<t tx="leo.20210414181027.121">$('#webotsEditorResetAllAction').click(function() {
  openResetConfirmDialog(true);
});
</t>
<t tx="leo.20210414181027.122">$('#webotsEditorMenuImage').click(function() {
  if ($('#webotsEditorMenu').hasClass('pressed'))
    $('#webotsEditorMenu').removeClass('pressed');
  else
    $('#webotsEditorMenu').addClass('pressed');
});
</t>
<t tx="leo.20210414181027.123">$('#webotsEditorMenu').focusout(function() {
  // let the time to handle the menu actions if needed
  window.setTimeout(function() {
    if ($('.webotsEditorMenuContentItem:hover').length &gt; 0)
      return;
    if ($('#webotsEditorMenu').hasClass('pressed'))
      $('#webotsEditorMenu').removeClass('pressed');
  }, 100);
});
</t>
<t tx="leo.20210414181027.124"></t>
<t tx="leo.20210414181027.125">webots.Editor.prototype.hasUnsavedChanges = function() {
  for (var i = 0; i &lt; this.filenames.length; i++) {
    if ($('#filename-' + i).html().endsWith('*'))
      return true;
  }
  return false;
};

</t>
<t tx="leo.20210414181027.126">webots.Editor.prototype.storeUserFile = function(i) {
  var formData = new FormData();
  formData.append('dirname', this.view.server.project + '/controllers/' + this.dirname);
  formData.append('filename', this.filenames[i]);
  formData.append('content', this.sessions[i].getValue());
  $.ajax({
    url: '/ajax/upload-file.php',
    type: 'POST',
    data: formData,
    processData: false,
    contentType: false,
    success: function(data) {
      if (data !== 'OK')
        webots.alert('File saving error', data);
    }
  });
};

</t>
<t tx="leo.20210414181027.127">webots.Editor.prototype.upload = function(i) { // upload to the simulation server
  this.view.stream.socket.send('set controller:' +
    this.dirname + '/' +
    this.filenames[i] + ':' +
    this.sessions[i].getLength() + '\n' +
    this.sessions[i].getValue());
  this.needToUploadFiles[i] = false;
};

</t>
<t tx="leo.20210414181027.128">webots.Editor.prototype.save = function(i) { // save to the web site
  if ($('#filename-' + i).html().endsWith('*')) { // file was modified
    $('#filename-' + i).html(this.filenames[i]);
    this.needToUploadFiles[i] = true;
    if (webots.User1Id &amp;&amp; webots.User1Authentication) // user logged in
      this.storeUserFile(i);
    else
      this.view.unloggedFileModified = true;

    if (this.view.time === 0)
      this.upload(i);
    else {
      if (!this.statusMessage) {
        this.statusMessage = document.createElement('div');
        this.statusMessage.id = 'webotsEditorStatusMessage';
        this.statusMessage.className = 'webotsEditorStatusMessage';
        this.statusMessage.innerHTML = '&lt;font size="2"&gt;Reset the simulation to apply the changes.&lt;/font&gt;';
      }
      this.panel.appendChild(this.statusMessage);
      setTimeout(this.hideResetMessage, 1500);
    }
  }
};

</t>
<t tx="leo.20210414181027.129">webots.Editor.prototype.hideResetMessage = function() {
  $('#webotsEditorStatusMessage').remove();
};

</t>
<t tx="leo.20210414181027.13">webots.View.prototype.setWebotsDocUrl = function(url) {
  this.webotsDocUrl = url;
};

</t>
<t tx="leo.20210414181027.130">webots.Editor.prototype.textChange = function(index) {
  if (!$('#filename-' + index).html().endsWith('*') &amp;&amp; this.editor.curOp &amp;&amp; this.editor.curOp.command.name) { // user change
    $('#filename-' + index).html(this.filenames[index] + '*');
  }
};

</t>
<t tx="leo.20210414181027.131">webots.Editor.prototype.aceMode = function(filename) {
  if (filename.toLowerCase() === 'makefile')
    return 'ace/mode/makefile';
  var extension = filename.split('.').pop().toLowerCase();
  if (extension === 'py')
    return 'ace/mode/python';
  if (extension === 'c' || extension === 'cpp' || extension === 'c++' || extension === 'cxx' || extension === 'cc' ||
      extension === 'h' || extension === 'hpp' || extension === 'h++' || extension === 'hxx' || extension === 'hh')
    return 'ace/mode/c_cpp';
  if (extension === 'java')
    return 'ace/mode/java';
  if (extension === 'm')
    return 'ace/mode/matlab';
  if (extension === 'json')
    return 'ace/mode/json';
  if (extension === 'xml')
    return 'ace/mode/xml';
  if (extension === 'yaml')
    return 'ace/mode/yaml';
  if (extension === 'ini')
    return 'ace/mode/ini';
  if (extension === 'html')
    return 'ace/mode/html';
  if (extension === 'js')
    return 'ace/mode/javascript';
  if (extension === 'css')
    return 'ace/mode/css';
  return 'ace/mode/text';
};

</t>
<t tx="leo.20210414181027.132">webots.Editor.prototype.addFile = function(filename, content) {
  var index = this.filenames.indexOf(filename);
  if (index &gt;= 0) {
    this.needToUploadFiles[index] = false; // just received from the simulation server
    this.sessions[index].setValue(content);
    if ($('#filename-' + index).html().endsWith('*'))
      $('#filename-' + index).html(filename);
    if (webots.User1Authentication &amp;&amp; webots.User1Id)
      this.storeUserFile(index);
    return;
  }

  index = this.filenames.length;
  this.filenames.push(filename);
  this.needToUploadFiles[index] = false;
  if (index === 0) {
    this.sessions[index].setMode(this.aceMode(filename));
    this.sessions[index].setValue(content);
    $('#webotsEditorMenu').show();
    $('#webotsEditorTabs').show();
  } else
    this.sessions.push(ace.createEditSession(content, this.aceMode(filename)));
  var that = this;
  this.sessions[index].on('change', function(e) { that.textChange(index); });
  $('div#webotsEditorTabs ul').append('&lt;li id="file-' + index + '"&gt;&lt;a href="#webotsEditorTab" id="filename-' + index + '"&gt;' + filename + '&lt;/a&gt;&lt;/li&gt;');
  $('div#webotsEditorTabs').tabs('refresh');
  if (index === 0)
    $('div#webotsEditorTabs').tabs('option', 'active', index);
};

</t>
<t tx="leo.20210414181027.133">webots.Editor.prototype.closeAllTabs = function() {
  this.editor.setSession(ace.createEditSession('', ''));
  this.filenames = [];
  this.needToUploadFiles = [];
  this.sessions = [];
  this.sessions[0] = this.editor.getSession();
  this.currentSession = 0;
  $('div#webotsEditorTabs ul').empty();
  $('#webotsEditorMenu').hide();
  $('#webotsEditorTabs').hide();
};

</t>
<t tx="leo.20210414181027.134">webots.Console = function(parent, mobile) {
  function closeConsole() {
    $('#consoleButton').removeClass('toolBarButtonActive');
  }
  this.panel = document.createElement('div');
  this.panel.id = 'webotsConsole';
  this.panel.className = 'webotsConsole';
  parent.appendChild(this.panel);
  var clampedSize = webotsClampDialogSize({left: 0, top: 0, width: 600, height: 400});
  var params = {
    title: 'Console',
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    width: clampedSize.width,
    height: clampedSize.height,
    autoOpen: false,
    appendTo: parent,
    close: closeConsole,
    open: webotsOpenDialog
  };
  if (mobile)
    webotsAddMobileDialogAttributes(params, this.panel);
  $(this.panel).dialog(params).dialogExtend({maximizable: mobile});
};

</t>
<t tx="leo.20210414181027.135"></t>
<t tx="leo.20210414181027.136">webots.Console.prototype.scrollDown = function() {
  if (this.panel)
    this.panel.scrollTop = this.panel.scrollHeight;
};

</t>
<t tx="leo.20210414181027.137">webots.Console.prototype.clear = function() {
  if (this.panel) {
    while (this.panel.firstChild)
      this.panel.removeChild(this.panel.firstChild);
  } else
    console.clear();
};

</t>
<t tx="leo.20210414181027.138">webots.Console.prototype.log = function(message, type) {
  var para = document.createElement('p');
  var style = 'margin:0;';
  var title = '';
  switch (type) {
    case 0:
      style += 'color:Blue;';
      title = 'Webots stdout';
      break;
    case 1:
      style += 'color:Red;';
      title = 'Webots stderr';
      break;
    case 2:
      style += 'color:Gray;';
      title = 'info';
      break;
    case 3:
      style += 'color:Salmon;';
      title = 'error';
      break;
  }
  if (this.panel) {
    para.style.cssText = style;
    para.title = title + ' (' + hourString() + ')';
    var t = document.createTextNode(message);
    para.appendChild(t);
    this.panel.appendChild(para);
    this.scrollDown();
  } else
    console.log('%c' + message, style);
  function hourString() {
    var d = new Date();
    return d.getHours() + ':' +
         ((d.getMinutes() &lt; 10) ? '0' : '') + d.getMinutes() + ':' +
         ((d.getSeconds() &lt; 10) ? '0' : '') + d.getSeconds();
  }
};

</t>
<t tx="leo.20210414181027.139"></t>
<t tx="leo.20210414181027.14">webots.View.prototype.open = function(url, mode) {
  if (mode === undefined)
    mode = 'x3dom';
  var that = this;
  this.mode = mode;
  this.videoStream = null;
  if (mode === 'video') {
    this.url = url;
    this.video = document.createElement('video');
    this.video.style.background = 'grey';
    this.video.id = 'remoteVideo';
    this.video.class = 'rounded centered';
    this.video.autoplay = 'true';
    this.video.width = 800;
    this.video.height = 600;
    this.view3D.appendChild(this.video);
    initWorld();
    return;
  }
  if (mode !== 'x3dom') {
    console.log('Error: webots.View.open: wrong mode argument: ' + mode);
    return;
  }
  if (this.broadcast)
    this.setTimeout(-1);
  if (!this.x3dScene) {
    this.x3dNode = document.createElement('x3d');
    this.x3dNode.className = 'webots3DView';
    this.view3D.appendChild(this.x3dNode);
    var param = document.createElement('param');
    param.name = 'showProgress';
    param.value = false;
    this.x3dNode.appendChild(param);
    this.x3dScene = document.createElement('Scene');
    this.x3dNode.appendChild(this.x3dScene);
  }
  if (this.url === undefined) {
    this.url = url;
    initX3Dom();
  } else {
    this.url = url;
    initWorld();
  }
  this.isWebSocketProtocol = that.url.startsWith('ws://') || that.url.startsWith('wss://');
  @others
};

</t>
<t tx="leo.20210414181027.140">webots.Console.prototype.stdout = function(message) {
  this.log(message, 0);
};

</t>
<t tx="leo.20210414181027.141">webots.Console.prototype.stderr = function(message) {
  this.log(message, 1);
};

</t>
<t tx="leo.20210414181027.142">webots.Console.prototype.info = function(message) {
  this.log(message, 2);
};

</t>
<t tx="leo.20210414181027.143">webots.Console.prototype.error = function(message) {
  this.log(message, 3);
};

</t>
<t tx="leo.20210414181027.144">webots.HelpWindow = function(parent, webotsDocUrl, mobile) {
  @others
};

</t>
<t tx="leo.20210414181027.145">function closeConsole() {
  $('#helpButton').removeClass('toolBarButtonActive');
}
</t>
<t tx="leo.20210414181027.146">function finalize() {
  $('#webotsHelpTabs').tabs('refresh');
  $('#webotsHelpTabs').tabs('option', 'active', 0);
  $(that.panel).dialog('open');
}
var that = this;
this.name = name;
this.panel = document.createElement('div');
this.panel.id = 'webotsHelp';
that.panel.style.overflow = 'hidden';
this.panel.className += 'webotsTabContainer';
this.tabs = document.createElement('div');
this.tabs.id = 'webotsHelpTabs';
this.tabs.className += 'webotsTabs';
this.tabsHeader = document.createElement('ul');
this.tabs.appendChild(this.tabsHeader);
this.panel.appendChild(this.tabs);
parent.appendChild(this.panel);
var clampedSize = webotsClampDialogSize({left: 5, top: 5, width: 600, height: 600});
var params = {
  title: 'Help',
  resizeStart: webotsDisablePointerEvents,
  resizeStop: webotsEnablePointerEvents,
  dragStart: webotsDisablePointerEvents,
  dragStop: webotsEnablePointerEvents,
  autoOpen: false,
  appendTo: parent,
  close: closeConsole,
  open: webotsOpenDialog,
  position: {at: 'right-5 top+5', my: 'right top', of: parent},
  width: clampedSize.width,
  height: clampedSize.height
};
if (mobile)
  webotsAddMobileDialogAttributes(params, this.panel);
$(this.panel).dialog(params).dialogExtend({maximizable: mobile});

if (webotsDocUrl) {
  var header = document.createElement('li');
  header.innerHTML = '&lt;a href="#webotsHelpReference"&gt;Webots Reference Manual&lt;/a&gt;';
  that.tabsHeader.appendChild(header);
  var page = document.createElement('div');
  page.id = 'webotsHelpReference';
  page.innerHTML = '&lt;iframe src="' + webotsDocUrl + '"&gt;&lt;/iframe&gt;';
  that.tabs.appendChild(page);
  $('#webotsHelpTabs').tabs();
}

$.ajax({
  url: webots.currentScriptPath() + 'help.php',
  success: function(data) {
    // we need to fix the img src relative URLs
    var html = data.replace(/ src="images/g, ' src="' + webots.currentScriptPath() + '/images');
    var header = document.createElement('li');
    header.innerHTML = '&lt;a href="#webotsHelpGuide"&gt;User Guide&lt;/a&gt;';
    $(that.tabsHeader).prepend(header);
    var page = document.createElement('div');
    page.id = 'webotsHelpGuide';
    page.innerHTML = html;
    if (document.getElementById('webotsHelpReference'))
      $('#webotsHelpReference').before(page);
    else {
      that.tabs.appendChild(page);
      $('#webotsHelpTabs').tabs();
    }
    finalize();
  },
  error: function() {
    finalize();
  }
});
</t>
<t tx="leo.20210414181027.147">webots.RobotWindow = function(parent, name, mobile) {
  this.name = name;
  this.panel = document.createElement('div');
  this.panel.id = name;
  this.panel.className = 'webotsTabContainer';
  parent.appendChild(this.panel);
  var clampedSize = webotsClampDialogSize({left: 5, top: 5, width: 400, height: 400});
  var params = {
    title: 'Robot Window',
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    autoOpen: false,
    appendTo: parent,
    open: webotsOpenDialog,
    position: {at: 'left+5 top+5', my: 'left top', of: parent},
    width: clampedSize.width,
    height: clampedSize.height
  };
  if (mobile)
    webotsAddMobileDialogAttributes(params, this.panel);
  $(this.panel).dialog(params).dialogExtend({maximizable: !mobile});
};

</t>
<t tx="leo.20210414181027.148">webots.RobotWindow.prototype.setProperties = function(properties) {
  $(this.panel).dialog(properties);
};

</t>
<t tx="leo.20210414181027.149">webots.RobotWindow.prototype.geometry = function() {
  var webotsTabs = this.panel.getElementsByClassName('webotsTabs');
  var activeTabIndex = -1;
  if (webotsTabs.length &gt; 0)
    activeTabIndex = $(webotsTabs[0]).tabs('option', 'active');
  return {
    width: $(this.panel).dialog('option', 'width'),
    height: $(this.panel).dialog('option', 'height'),
    position: $(this.panel).dialog('option', 'position'),
    activeTabIndex: activeTabIndex,
    open: this.isOpen()
  };
};

</t>
<t tx="leo.20210414181027.15">function requestQuit() {
  if (that.unloggedFileModified || that.editor.hasUnsavedChanges()) {
    var text;
    if (that.unloggedFileModified || !webots.User1Id)
      text = 'Your changes to the robot controller will be lost because you are not logged in.';
    else
      text = 'Your unsaved changes to the robot controller will be lost.';
    var quitDialog = document.getElementById('quitDialog');
    if (!quitDialog) {
      quitDialog = document.createElement('div');
      quitDialog.id = 'quitDialog';
      $(quitDialog).html(text);
      that.view3D.appendChild(quitDialog);
      $(quitDialog).dialog({
        title: 'Quit the simulation?',
        modal: true,
        resizable: false,
        appendTo: that.view3D,
        open: webotsOpenDialog,
        buttons: {
          'Cancel': function() {
            $(this).dialog('close');
          },
          'Quit': function() {
            $(this).dialog('close');
            quit();
          }
        }
      });
    } else
      $(quitDialog).dialog('open');
    return;
  }
  quit();
}
</t>
<t tx="leo.20210414181027.150">webots.RobotWindow.prototype.restoreGeometry = function(data) {
  $(this.panel).dialog({
    width: data.width,
    height: data.height,
    position: data.position
  });
  var webotsTabs = this.panel.getElementsByClassName('webotsTabs');
  if (data.activeTabIndex &gt;= 0 &amp;&amp; webotsTabs.length &gt; 0)
    $(webotsTabs[0]).tabs('option', 'active', data.activeTabIndex);
};

</t>
<t tx="leo.20210414181027.151">webots.RobotWindow.prototype.destroy = function() {
  this.close();
  this.panel.parentNode.removeChild(this.panel);
  this.panel = null;
};

</t>
<t tx="leo.20210414181027.152">webots.RobotWindow.prototype.setContent = function(content) {
  $(this.panel).html(content);
};

</t>
<t tx="leo.20210414181027.153">webots.RobotWindow.prototype.open = function() {
  $(this.panel).dialog('open');
};

</t>
<t tx="leo.20210414181027.154">webots.RobotWindow.prototype.isOpen = function() {
  return $(this.panel).dialog('isOpen');
};

</t>
<t tx="leo.20210414181027.155">webots.RobotWindow.prototype.close = function() {
  $(this.panel).dialog('close');
};

</t>
<t tx="leo.20210414181027.156">webots.RobotWindow.prototype.send = function(message, robot) {
  webots.currentView.stream.socket.send('robot:' + robot + ':' + message);
  if (webots.currentView.real_timeButton.style.display === 'inline') // if paused, make a simulation step
    webots.currentView.stream.socket.send('step'); // so that the robot controller handles the message
  // FIXME: there seems to be a bug here: after that step, the current time is not incremented in the web interface,
  // this is because the next 'application/json:' is not received, probably because it gets overwritten by the
  // answer to the robot message...
};

</t>
<t tx="leo.20210414181027.157">webots.RobotWindow.prototype.receive = function(message, robot) { // to be overriden
  console.log("Robot window '" + this.name + "' received message from Robot '" + robot + "': " + message);
};

</t>
<t tx="leo.20210414181027.158">webots.window = function(name) {
  var win = webots.currentView.robotWindows[name];
  if (!win)
    console.log("Robot window '" + name + "' not found.");
  return win;
};

</t>
<t tx="leo.20210414181027.159">webots.alert = function(title, message, callback) {
  webots.currentView.ondialogwindow(true);
  var parent = webots.currentView.view3D;
  var panel = document.createElement('div');
  panel.id = 'webotsAlert';
  panel.innerHTML = message;
  parent.appendChild(panel);
  $('#webotsAlert').dialog({
    title: title,
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    appendTo: parent,
    open: webotsOpenDialog,
    modal: true,
    width: 400, // enough room to display the social network buttons in a line
    buttons: {Ok: function() { $(this).dialog('close'); }},
    close: function() {
      if (callback !== undefined)
        callback();
      $(this).dialog('destroy').remove();
      webots.currentView.ondialogwindow(false);
    }
  });
};

</t>
<t tx="leo.20210414181027.16">function quit() {
  if (that.broadcast)
    return;
  $('#webotsProgressMessage').html('Bye bye...');
  $('#webotsProgress').show();
  that.quitting = true;
  that.onquit();
}
</t>
<t tx="leo.20210414181027.160">webots.confirm = function(title, message, callback) {
  webots.currentView.ondialogwindow(true);
  var parent = webots.currentView.view3D;
  var panel = document.createElement('div');
  panel.id = 'webotsConfirm';
  panel.innerHTML = message;
  parent.appendChild(panel);
  $('#webotsConfirm').dialog({
    title: title,
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    appendTo: parent,
    open: webotsOpenDialog,
    modal: true,
    width: 400, // enough room to display the social network buttons in a line
    buttons: {Ok: function() { $(this).dialog('close'); callback(); }, Cancel: function() { $(this).dialog('close'); }},
    close: function() { $(this).dialog('destroy').remove(); webots.currentView.ondialogwindow(false); }});
};

</t>
<t tx="leo.20210414181027.161">webots.parseMillisecondsIntoReadableTime = function(milliseconds) {
  var hours = (milliseconds + 0.9) / (1000 * 60 * 60);
  var absoluteHours = Math.floor(hours);
  var h = absoluteHours &gt; 9 ? absoluteHours : '0' + absoluteHours;
  var minutes = (hours - absoluteHours) * 60;
  var absoluteMinutes = Math.floor(minutes);
  var m = absoluteMinutes &gt; 9 ? absoluteMinutes : '0' + absoluteMinutes;
  var seconds = (minutes - absoluteMinutes) * 60;
  var absoluteSeconds = Math.floor(seconds);
  var s = absoluteSeconds &gt; 9 ? absoluteSeconds : '0' + absoluteSeconds;
  var ms = Math.floor((seconds - absoluteSeconds) * 1000);
  if (ms &lt; 10)
    ms = '00' + ms;
  else if (ms &lt; 100)
    ms = '0' + ms;
  return h + ':' + m + ':' + s + ':' + ms;
};

// get the directory path to the currently executing script file
</t>
<t tx="leo.20210414181027.162">// for example: https://cyberbotics.com/wwi/8.6/
webots.currentScriptPath = function() {
  var scripts = document.querySelectorAll('script[src]');
  for (var i = 0; i &lt; scripts.length; i++) {
    var src = scripts[i].src;
    var index = src.indexOf('?');
    if (index &gt; 0)
      src = src.substring(0, index); // remove query string
    if (!src.endsWith('webots.js'))
      continue;
    index = src.lastIndexOf('/');
    return src.substring(0, index + 1);
  }
  return '';
};

// add startsWith() and endsWith() functions to the String prototype
if (typeof String.prototype.startsWith !== 'function') {
</t>
<t tx="leo.20210414181027.163">  String.prototype.startsWith = function(prefix) {
    return this.slice(0, prefix.length) === prefix;
  };
}

if (typeof String.prototype.endsWith !== 'function') {
</t>
<t tx="leo.20210414181027.164">  String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };
}
</t>
<t tx="leo.20210414181027.17">function reset() {
  if (that.broadcast)
    return;
  that.time = 0; // reset time to correctly compute the initial deadline
  $('#webotsProgressMessage').html('Restarting simulation...');
  $('#webotsProgress').show();
  that.runOnLoad = that.pauseButton.style.display === 'inline';
  pause();
  for (var i = 0; i &lt; that.editor.filenames.length; i++) {
    that.editor.save(i);
    if (that.editor.needToUploadFiles[i])
      that.editor.upload(i);
  }
  that.onrobotwindowsdestroy();
  if (that.timeout &gt;= 0) {
    that.deadline = that.timeout;
    $('#webotsTimeout').html(webots.parseMillisecondsIntoReadableTime(that.deadline));
  }
  enableToolBarButtons(false);
  that.stream.socket.send('reset');
}
</t>
<t tx="leo.20210414181027.18">function pause() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display', 'none');
  that.stream.socket.send('pause');
}
</t>
<t tx="leo.20210414181027.19">function realTime() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display', 'none');
  that.stream.socket.send('real-time:' + that.timeout);
  that.pauseButton.style.display = 'inline';
  that.real_timeButton.style.display = 'none';
}
</t>
<t tx="leo.20210414181027.2">this.onerror = function(text) {
  console.log('%c' + text, 'color:black');
  that.onrobotwindowsdestroy();
};
</t>
<t tx="leo.20210414181027.20">function step() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display', 'none');
  that.pauseButton.style.display = 'none';
  that.real_timeButton.style.display = 'inline';
  that.stream.socket.send('step');
}
</t>
<t tx="leo.20210414181027.21">function requestFullscreen() {
  $('#contextMenu').css('display', 'none');
  var elem = that.view3D;
  if (elem.requestFullscreen)
    elem.requestFullscreen();
  else if (elem.msRequestFullscreen)
    elem.msRequestFullscreen();
  else if (elem.mozRequestFullScreen)
    elem.mozRequestFullScreen();
  else if (elem.webkitRequestFullscreen)
    elem.webkitRequestFullscreen();
}
</t>
<t tx="leo.20210414181027.22">function exitFullscreen() {
  $('#contextMenu').css('display', 'none');
  if (document.exitFullscreen)
    document.exitFullscreen();
  else if (document.msExitFullscreen)
    document.msExitFullscreen();
  else if (document.mozCancelFullScreen)
    document.mozCancelFullScreen();
  else if (document.webkitExitFullscreen)
    document.webkitExitFullscreen();
}
</t>
<t tx="leo.20210414181027.23">function fullscreenchange(event) {
  var element = document.fullScreenElement || document.mozFullScreenElement || document.webkitFullScreenElement || document.msFullScreenElement || document.webkitCurrentFullScreenElement;
  if (element != null) {
    that.fullscreenButton.style.display = 'none';
    that.exit_fullscreenButton.style.display = 'inline';
  } else {
    that.fullscreenButton.style.display = 'inline';
    that.exit_fullscreenButton.style.display = 'none';
  }
}
</t>
<t tx="leo.20210414181027.24">function toolBarButton(name, tooltip) {
  var buttonName = name + 'Button';
  that[buttonName] = document.createElement('button');
  that[buttonName].id = buttonName;
  that[buttonName].className = 'toolBarButton';
  that[buttonName].title = tooltip;
  that[buttonName].style.backgroundImage = 'url(' + webots.WwiUrl + 'images/' + name + '.png)';
  return that[buttonName];
}
</t>
<t tx="leo.20210414181027.25">function toggleConsole() {
  $('#contextMenu').css('display', 'none');
  if ($('#webotsConsole').is(':visible')) {
    $('#webotsConsole').dialog('close');
    that.consoleButton.classList.remove('toolBarButtonActive');
  } else {
    $('#webotsConsole').dialog('open');
    that.consoleButton.classList.add('toolBarButtonActive');
  }
}
</t>
<t tx="leo.20210414181027.26">function toggleHelp() {
  $('#contextMenu').css('display', 'none');
  if (!that.helpWindow) {
    if (!that.broadcast &amp;&amp; that.webotsDocUrl)
      var webotsDocUrl = that.webotsDocUrl;
    that.helpWindow = new webots.HelpWindow(that.view3D, webotsDocUrl, that.mobileDevice);
    that.helpButton.classList.add('toolBarButtonActive');
  } else if ($('#webotsHelp').is(':visible')) {
    $('#webotsHelp').dialog('close');
    that.helpButton.classList.remove('toolBarButtonActive');
  } else {
    $('#webotsHelp').dialog('open');
    that.helpButton.classList.add('toolBarButtonActive');
  }
}
</t>
<t tx="leo.20210414181027.27">function enableToolBarButtons(enabled) {
  var buttons = [that.infoButton, that.resetButton, that.stepButton, that.real_timeButton, that.pauseButton, that.consoleButton];
  for (var i in buttons) {
    if (buttons[i]) {
      if ((!that.broadcast || buttons[i] === that.consoleButton) &amp;&amp; enabled) {
        buttons[i].disabled = false;
        buttons[i].classList.remove('toolBarButtonDisabled');
      } else {
        buttons[i].disabled = true;
        buttons[i].classList.add('toolBarButtonDisabled');
      }
    }
  }
}
</t>
<t tx="leo.20210414181027.28">function initWorld() {
  // override the original x3dom function to workaround a bug with USE/DEF nodes
  @others
}

</t>
<t tx="leo.20210414181027.29">x3dom.Texture.prototype.update = function() {
  if (x3dom.isa(this.node, x3dom.nodeTypes.Text))
    this.updateText();
  else
    this.updateTexture();
  // x3dom bug: do not call validateGLObject because it somehow prevents USE Apperance update (bug #5117)
  // this.node.validateGLObject();
};

// redirect the X3Dom log entirely to the JS console
if (that.mode === 'x3dom') {
  if (this.debug) {
</t>
<t tx="leo.20210414181027.3">this.onstdout = function(text) {
  console.log('%c' + text, 'color:blue');
};
</t>
<t tx="leo.20210414181027.30">    x3dom.debug.doLog = function(msg, type) {
      console.log(type + ': ' + msg);
    };
  }
  x3dom.runtime.ready = addX3domMouseNavigation;
}
if (that.isWebSocketProtocol) {
  that.progress = document.createElement('div');
  that.progress.id = 'webotsProgress';
  that.progress.innerHTML = "&lt;div&gt;&lt;img src='" + webots.WwiUrl + "images/load_animation.gif'&gt;" +
                            "&lt;/div&gt;&lt;div id='webotsProgressMessage'&gt;Initializing...&lt;/div&gt;";
  that.view3D.appendChild(that.progress);
  that.toolBar = document.createElement('div');
  that.toolBar.id = 'toolBar';
  that.toolBar.left = document.createElement('div');
  that.toolBar.left.className = 'toolBarLeft';
  that.toolBar.left.appendChild(toolBarButton('quit', 'Quit the simulation'));
  that.quitButton.onclick = requestQuit;
  that.toolBar.left.appendChild(toolBarButton('info', 'Open the information window'));
  that.infoButton.onclick = toggleInfo;
  that.toolBar.left.appendChild(toolBarButton('reset', 'Save controllers and reset the simulation'));
  that.resetButton.onclick = reset;
  that.toolBar.left.appendChild(toolBarButton('step', 'Perform one simulation step'));
  that.stepButton.onclick = step;
  that.toolBar.left.appendChild(toolBarButton('real_time', 'Run the simulation in real time'));
  that.real_timeButton.onclick = realTime;
  that.toolBar.left.appendChild(toolBarButton('pause', 'Pause the simulation'));
  that.pauseButton.onclick = pause;
  that.pauseButton.style.display = 'none';
  var div = document.createElement('div');
  div.className = 'webotsTime';
  var clock = document.createElement('span');
  clock.id = 'webotsClock';
  clock.title = 'Current simulation time';
  clock.innerHTML = webots.parseMillisecondsIntoReadableTime(0);
  var timeout = document.createElement('span');
  timeout.id = 'webotsTimeout';
  timeout.title = 'Simulation time out';
  timeout.innerHTML = webots.parseMillisecondsIntoReadableTime(that.deadline);
  div.appendChild(clock);
  div.appendChild(document.createElement('br'));
  div.appendChild(timeout);
  that.toolBar.left.appendChild(div);
  that.toolBar.left.appendChild(toolBarButton('console', 'Open the console window'));
  that.consoleButton.onclick = toggleConsole;
  that.toolBar.right = document.createElement('div');
  that.toolBar.right.className = 'toolBarRight';
  that.toolBar.right.appendChild(toolBarButton('help', 'Get help on the simulator'));
  that.helpButton.onclick = toggleHelp;
  if (that.fullscreenEnabled) {
    that.toolBar.right.appendChild(toolBarButton('exit_fullscreen', 'Exit fullscreen'));
    that.exit_fullscreenButton.onclick = exitFullscreen;
    that.exit_fullscreenButton.style.display = 'none';
    that.toolBar.right.appendChild(toolBarButton('fullscreen', 'Enter fullscreen'));
    that.fullscreenButton.onclick = requestFullscreen;
  }
  that.toolBar.appendChild(that.toolBar.left);
  that.toolBar.appendChild(that.toolBar.right);
  that.view3D.appendChild(that.toolBar);
  enableToolBarButtons(false);
  if (that.broadcast) {
    that.quitButton.disabled = true;
    that.quitButton.classList.add('toolBarButtonDisabled');
    $('#contextMenuRobotWindowDiv').addClass('ui-state-disabled');
    $('#contextMenuEditControllerDiv').addClass('ui-state-disabled');
  }
  document.addEventListener('fullscreenchange', fullscreenchange);
  document.addEventListener('webkitfullscreenchange', fullscreenchange);
  document.addEventListener('mozfullscreenchange', fullscreenchange);
  document.addEventListener('MSFullscreenChange', fullscreenchange);
  if (that.url.endsWith('.wbt')) { // url expected form: "ws://localhost:80/simple/worlds/simple.wbt"
    var callback;
    if (that.mode === 'video')
      callback = videoFinalize;
    else
      callback = x3domFinalize;
    that.server = new webots.Server(that.url, that, callback);
  } else // url expected form: "ws://cyberbotics2.cyberbotics.com:80"
    that.stream = new webots.Stream(that.url, that, x3domFinalize);
} else // assuming it's an URL to a .x3d file
  initX3dFile();
</t>
<t tx="leo.20210414181027.31">function toggleInfo() {
  that.toggleInfo();
}

</t>
<t tx="leo.20210414181027.32">function initX3Dom() { // load x3dom.css, x3dom-full.js and calls initWorld
  var head = document.getElementsByTagName('head')[0];
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = 'https://www.cyberbotics.com/x3dom/dev_13062018/x3dom.css';
  link.media = 'all';
  head.appendChild(link);
  // source http://stackoverflow.com/questions/950087/include-a-javascript-file-in-another-javascript-file
  var script = document.createElement('script');
  script.src = 'https://www.cyberbotics.com/x3dom/dev_13062018/x3dom-full.js';
  script.onload = initWorld;
  script.onerror = function() {
    that.onerror('Error when loading the X3DOM library');
  };
  head.appendChild(script); // fire the loading
}

</t>
<t tx="leo.20210414181027.33"></t>
<t tx="leo.20210414181027.34">function initX3dFile() {
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.open('GET', that.url, true);
  xmlhttp.overrideMimeType('text/xml');
  xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200) {
      var scene = xmlhttp.responseText.substring(xmlhttp.responseText.indexOf('&lt;Scene&gt;') + 8, xmlhttp.responseText.lastIndexOf('&lt;/Scene&gt;'));
      $(that.x3dScene).append(scene);
      x3domFinalize();
    }
  };
  xmlhttp.send();
}

</t>
<t tx="leo.20210414181027.35"></t>
<t tx="leo.20210414181027.36">function x3domFinalize() {
  $('#webotsProgressMessage').html('Loading HTML and Javascript files...');
  if (that.followedObject == null || that.broadcast) {
    var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
    that.initialViewpointPosition = viewpoint.getAttribute('position');
    that.initialViewpointOrientation = viewpoint.getAttribute('orientation');
    var viewpointFollowSmoothness = viewpoint.getAttribute('followSmoothness');
    if (viewpointFollowSmoothness !== null)
      that.setViewpointMass(viewpointFollowSmoothness);
    var viewpointFollowedId = viewpoint.getAttribute('followedId');
    if (viewpointFollowedId != null) {
      that.followedObject = viewpointFollowedId;
      that.follow(viewpointFollowedId);
    } else
      that.followedObject = 'none';
  } else
    // reset follow parameters
    that.follow(that.followedObject);

  if (!that.isWebSocketProtocol) { // skip robot windows initialization
    if (that.animation != null)
      that.animation.init(loadFinalize);
    else
      loadFinalize();
    that.onresize();
    return;
  }

  function loadRobotWindow(node) {
    var windowName = node.getAttribute('window');
    that.robotWindowNames[node.getAttribute('name')] = windowName;
    var win = new webots.RobotWindow(that.view3D, windowName, that.mobileDevice);
    that.robotWindows[windowName] = win;
    // init robot windows dialogs
    @others
  }

  var worldInfo = that.x3dScene.getElementsByTagName('WorldInfo')[0];
  var infoWindowName = worldInfo.getAttribute('window');
  var pendingRequestsCount = 1; // start from 1 so that it can be 0 only after the loop is completed and all the nodes are checked
  var nodes = that.x3dScene.childNodes;
  for (var i = 0; i &lt; nodes.length; i++) {
    if (nodes[i].nodeType !== 1 || nodes[i].nodeName.toUpperCase() !== 'TRANSFORM' || !nodes[i].hasAttribute('window') || !nodes[i].hasAttribute('name'))
      continue;
    loadRobotWindow(nodes[i]);
  }
  pendingRequestsCount--; // notify that loop is completed
  if (pendingRequestsCount === 0)
    // if no pending requests execute loadFinalize
    // otherwise it will be executed when the last request will be handled
    loadFinalize();
}

</t>
<t tx="leo.20210414181027.37"></t>
<t tx="leo.20210414181027.38">function closeInfoWindow() {
  $('#infoButton').removeClass('toolBarButtonActive');
}
if (windowName === infoWindowName) {
  var user;
  if (webots.User1Id) {
    user = ' [' + webots.User1Name;
    if (webots.User2Id)
      user += '/' + webots.User2Name;
    user += ']';
  } else
    user = '';
  win.setProperties({title: worldInfo.getAttribute('title') + user, close: closeInfoWindow});
  that.infoWindow = win;
} else
  win.setProperties({title: 'Robot: ' + node.getAttribute('name')});
pendingRequestsCount++;
</t>
<t tx="leo.20210414181027.39">$.get('window/' + windowName + '/' + windowName + '.html', function(data) {
  // we need to fix the img src relative URLs
  var d = data.replace(/ src='/g, ' src=\'window/' + windowName + '/').replace(/ src="/g, ' src="window/' + windowName + '/');
  win.setContent(d);
  MathJax.Hub.Queue(['Typeset', MathJax.Hub, win[0]]);
  $.get('window/' + windowName + '/' + windowName + '.js', function(data) {
    eval(data);
    pendingRequestsCount--;
    if (pendingRequestsCount === 0)
      loadFinalize();
  }).fail(function() {
    pendingRequestsCount--;
    if (pendingRequestsCount === 0)
      loadFinalize();
  });
}).fail(function() {
  pendingRequestsCount--;
  if (pendingRequestsCount === 0)
    loadFinalize();
});
</t>
<t tx="leo.20210414181027.4">this.onstderr = function(text) {
  console.log('%c' + text, 'color:red');
};
</t>
<t tx="leo.20210414181027.40"></t>
<t tx="leo.20210414181027.41">function loadFinalize() {
  $('#webotsProgress').hide();
  enableToolBarButtons(true);

  if (that.onready)
    that.onready();

  // restore robot windows
  if (that.robotWindowsGeometries) { // on reset
    for (var win in that.robotWindows) {
      if (win in that.robotWindowsGeometries) {
        that.robotWindows[win].restoreGeometry(that.robotWindowsGeometries[win]);
        if (that.robotWindowsGeometries[win].open) {
          if (that.robotWindows[win] === that.infoWindow)
            that.toggleInfo();
          else
            that.robotWindows[win].open();
        }
      }
    }
  } else if (that.infoWindow &amp;&amp; !that.broadcast) // at first load
    that.toggleInfo();
  that.viewpointLastUpdate = undefined;

  if (that.runOnLoad)
    realTime();
}

</t>
<t tx="leo.20210414181027.42">function rotateViewpoint(viewpoint, params) {
  var halfYawAngle = -0.005 * params.dx;
  var halfPitchAngle = -0.005 * params.dy;
  if (that.mouseState.pickPosition == null) {
    halfYawAngle /= -8;
    halfPitchAngle /= -8;
  }
  var sinusYaw = Math.sin(halfYawAngle);
  var sinusPitch = Math.sin(halfPitchAngle);
  var tx = (1 - params.c) * params.vo.x;
  var pitch = new x3dom.fields.SFVec3f(tx * params.vo.x + params.c, tx * params.vo.y + params.s * params.vo.z, tx * params.vo.z - params.s * params.vo.y);
  var pitchRotation = new x3dom.fields.Quaternion(sinusPitch * pitch.x, sinusPitch * pitch.y, sinusPitch * pitch.z, Math.cos(halfPitchAngle));
  var worldUp = new x3dom.fields.SFVec3f(0, 1, 0);
  var yawRotation = new x3dom.fields.Quaternion(sinusYaw * worldUp.x, sinusYaw * worldUp.y, sinusYaw * worldUp.z, Math.cos(halfYawAngle));
  var deltaRotation = yawRotation.multiply(pitchRotation);
  if (that.mouseState.pickPosition) {
    var currentPosition = deltaRotation.toMatrix().multMatrixVec(params.vp.subtract(that.mouseState.pickPosition)).add(that.mouseState.pickPosition);
    viewpoint.setAttribute('position', currentPosition.toString());
  }
  var voq = x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(params.vo.x, params.vo.y, params.vo.z), params.vo.w);
  var currentOrientation = deltaRotation.multiply(voq);
  var aa = currentOrientation.toAxisAngle();
  viewpoint.setAttribute('orientation', aa[0].toString() + ' ' + aa[1]);
}

</t>
<t tx="leo.20210414181027.43">function translateViewpoint(viewpoint, params) {
  var targetRight = -params.distanceToPickPosition * params.scaleFactor * params.dx;
  var targetUp = params.distanceToPickPosition * params.scaleFactor * params.dy;
  var tx = (1 - params.c) * params.vo.x;
  var pitch = new x3dom.fields.SFVec3f(tx * params.vo.x + params.c, tx * params.vo.y + params.s * params.vo.z, tx * params.vo.z - params.s * params.vo.y);
  var ty = (1 - params.c) * params.vo.y;
  var yaw = new x3dom.fields.SFVec3f(ty * params.vo.x - params.s * params.vo.z, ty * params.vo.y + params.c, ty * params.vo.z + params.s * params.vo.x);
  var target = params.vp.add(pitch.multiply(targetRight).add(yaw.multiply(targetUp)));
  viewpoint.setAttribute('position', target.toString());
}

</t>
<t tx="leo.20210414181027.44">function zoomAndTiltViewpoint(viewpoint, params) {
  var tz = (1 - params.c) * params.vo.z;
  var roll = new x3dom.fields.SFVec3f(tz * params.vo.x + params.s * params.vo.y, tz * params.vo.y - params.s * params.vo.x, tz * params.vo.z + params.c);
  var target = params.vp.add(roll.multiply(params.zoomScale));
  viewpoint.setAttribute('position', target.toString());
  var zRotation = x3dom.fields.Quaternion.axisAngle(roll, params.tiltAngle);
  var voq = x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(params.vo.x, params.vo.y, params.vo.z), params.vo.w);
  var aa = zRotation.multiply(voq).toAxisAngle();
  viewpoint.setAttribute('orientation', aa[0].toString() + ' ' + aa[1]);
}

</t>
<t tx="leo.20210414181027.45">function initMouseMove(event) {
  that.mouseState.x = event.clientX;
  that.mouseState.y = event.clientY;
  that.mouseState.initialX = null;
  that.mouseState.initialY = null;
  that.mouseState.moved = false;
  that.mouseState.initialTimeStamp = Date.now();
  that.mouseState.longClick = false;
  var mousePosition = that.x3dNode.runtime.mousePosition(event);
  var shootRay = that.x3dNode.runtime.shootRay(mousePosition[0], mousePosition[1]);
  that.mouseState.pickPosition = shootRay.pickPosition;
  if ($('#contextMenu').css('display') === 'block') {
    $('#contextMenu').css('display', 'none');
    that.contextMenu = true;
  } else
    that.contextMenu = false;
}

</t>
<t tx="leo.20210414181027.46">function clearMouseMove() {
  if (that.mouseState.mobileDevice)
    that.mouseState.longClick = Date.now() - that.mouseState.initialTimeStamp &gt;= 100;
  else
    that.mouseState.longClick = Date.now() - that.mouseState.initialTimeStamp &gt;= 1000;
  if (that.mouseState.moved === false) {
    that.previousSelection = that.selection;
    unselect();
  } else
    that.previousSelection = null;
  that.mouseState.previousMouseDown = that.mouseState.mouseDown;
  that.mouseState.mouseDown = 0;
  that.mouseState.initialTimeStamp = null;
  that.mouseState.initialX = null;
  that.mouseState.initialY = null;
}

</t>
<t tx="leo.20210414181027.47">function addX3domMouseNavigation() {
  if (that.mobileDevice) {
    @others
}
</t>
<t tx="leo.20210414181027.48">that.x3dNode.addEventListener('touchmove', function(event) {
  if (!that.enableNavigation || event.targetTouches.length === 0 || event.targetTouches.length &gt; 2)
    return;
  if (that.mouseState.initialTimeStamp === null)
    // prevent applying mouse move action before drag initialization in mousedrag event
    return;
  if ((that.mouseState.mouseDown !== 2) !== (event.targetTouches.length &gt; 1))
    // gesture single/multi touch changed after initialization
    return;

  var touch = event.targetTouches['0'];

  var params = {};
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  params.vp = x3dom.fields.SFVec3f.parse(viewpoint.getAttribute('position'));
  params.vo = x3dom.fields.SFVec4f.parse(viewpoint.getAttribute('orientation'));
  params.c = Math.cos(params.vo.w);
  params.s = Math.sin(params.vo.w);
  params.scaleFactor = 1.90 * Math.tan(that.viewpointFieldOfView / 2);
  var viewHeight = parseFloat($(that.x3dNode).css('height').slice(0, -2));
  var viewWidth = parseFloat($(that.x3dNode).css('width').slice(0, -2));
  params.scaleFactor /= Math.max(viewHeight, viewWidth);

  if (that.mouseState.pickPosition == null)
    params.distanceToPickPosition = params.vp.length();
  else
    params.distanceToPickPosition = params.vp.subtract(that.mouseState.pickPosition).length() - 0.05; // FIXME this is different from webots.
  if (params.distanceToPickPosition &lt; 0.001) // 1 mm
    params.distanceToPickPosition = 0.001;
  var x = Math.round(touch.clientX); // discard decimal values returned on android
  var y = Math.round(touch.clientY);

  if (that.mouseState.mouseDown === 2) { // translation
    params.dx = x - that.mouseState.x;
    params.dy = y - that.mouseState.y;
    translateViewpoint(viewpoint, params);

    // on small phone screens (Android) this is needed to correctly detect clicks and longClicks
    if (that.mouseState.initialX == null &amp;&amp; that.mouseState.initialY == null) {
      that.mouseState.initialX = Math.round(that.mouseState.x);
      that.mouseState.initialY = Math.round(that.mouseState.y);
    }
    if (Math.abs(params.dx) &lt; 2 &amp;&amp; Math.abs(params.dy) &lt; 2 &amp;&amp;
        Math.abs(that.mouseState.initialX - x) &lt; 5 &amp;&amp; Math.abs(that.mouseState.initialY - y) &lt; 5)
      that.mouseState.moved = false;
    else
      that.mouseState.moved = true;
  } else {
    var touch1 = event.targetTouches['1'];
    var x1 = Math.round(touch1.clientX);
    var y1 = Math.round(touch1.clientY);
    var distanceX = x - x1;
    var distanceY = y - y1;
    var newTouchDistance = distanceX * distanceX + distanceY * distanceY;
    var pinchSize = that.mouseState.touchDistance - newTouchDistance;

    var moveX1 = x - that.mouseState.x;
    var moveX2 = x1 - that.mouseState.x1;
    var moveY1 = y - that.mouseState.y;
    var moveY2 = y1 - that.mouseState.y1;
    var ratio = window.devicePixelRatio || 1;

    if (Math.abs(pinchSize) &gt; 500 * ratio) { // zoom and tilt
      var d;
      if (Math.abs(moveX2) &lt; Math.abs(moveX1))
        d = moveX1;
      else
        d = moveX2;
      params.tiltAngle = 0.0004 * d;
      params.zoomScale = params.scaleFactor * 0.015 * pinchSize;
      zoomAndTiltViewpoint(viewpoint, params);
    } else if (Math.abs(moveY2 - moveY1) &lt; 3 * ratio &amp;&amp; Math.abs(moveX2 - moveX1) &lt; 3 * ratio) { // rotation (pitch and yaw)
      params.dx = moveX1 * 0.8;
      params.dy = moveY1 * 0.5;
      rotateViewpoint(viewpoint, params);
    }

    that.mouseState.touchDistance = newTouchDistance;
    that.mouseState.moved = true;
  }

  that.mouseState.x = x;
  that.mouseState.y = y;
  that.mouseState.x1 = x1;
  that.mouseState.y1 = y1;
  if (that.ontouchmove)
    that.ontouchmove(event);
}, true);
</t>
<t tx="leo.20210414181027.49">that.x3dNode.addEventListener('touchstart', function(event) {
  initMouseMove(event.targetTouches['0']);
  if (event.targetTouches.length === 2) {
    var touch1 = event.targetTouches['1'];
    that.mouseState.x1 = touch1.clientX;
    that.mouseState.y1 = touch1.clientY;
    var distanceX = that.mouseState.x - that.mouseState.x1;
    var distanceY = that.mouseState.y - that.mouseState.y1;
    that.mouseState.touchDistance = distanceX * distanceX + distanceY * distanceY;
    that.mouseState.touchOrientation = Math.atan2(that.mouseState.y1 - that.mouseState.y, that.mouseState.x1 - that.mouseState.x);
    that.mouseState.mouseDown = 3; // two fingers: rotation, tilt, zoom
  } else
    that.mouseState.mouseDown = 2; // 1 finger: translation or single click
}, true);
</t>
<t tx="leo.20210414181027.5">this.onrobotmessage = function(robot, message) {
  if (that.robotWindowNames[robot] === undefined) {
    console.log("Robot '" + robot + "' has no associated robot window");
    return;
  }
  that.robotWindows[that.robotWindowNames[robot]].receive(message, robot);
};
</t>
<t tx="leo.20210414181027.50">  that.x3dNode.addEventListener('touchend', function(event) {
    clearMouseMove();
    if (that.ontouchend)
      that.ontouchend(event);
  }, true);
} else {
</t>
<t tx="leo.20210414181027.51">that.x3dNode.addEventListener('wheel', function(event) {
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var vp = x3dom.fields.SFVec3f.parse(viewpoint.getAttribute('position'));
  var vo = x3dom.fields.SFVec4f.parse(viewpoint.getAttribute('orientation'));
  var mousePosition = that.x3dNode.runtime.mousePosition(event);
  var shootRay = that.x3dNode.runtime.shootRay(mousePosition[0], mousePosition[1]);
  var distanceToPickPosition;
  that.mouseState.pickPosition = shootRay.pickPosition;
  if (that.mouseState.pickPosition == null)
    distanceToPickPosition = vp.length();
  else
    distanceToPickPosition = vp.subtract(that.mouseState.pickPosition).length();
  if (distanceToPickPosition &lt; 0.001) // 1 mm
    distanceToPickPosition = 0.001;
  if (!that.enableNavigation || that.mouseState.wheelFocus === false) {
    var offset = event.deltaY;
    if (event.deltaMode === 1)
      offset *= 40; // standard line height in pixel
    window.scroll(0, window.pageYOffset + offset);
    if (that.mouseState.wheelTimeout) { // you have to rest at least 1.5 seconds over the x3d canvas
      clearTimeout(that.mouseState.wheelTimeout); // so that the wheel focus will get enabled and
      that.mouseState.wheelTimeout = setTimeout(wheelTimeoutCallback, 1500); // allow you to zoom in/out.
    }
    return;
  }
  var scaleFactor = 0.02 * distanceToPickPosition * ((event.deltaY &lt; 0) ? -1 : 1);
  var c = Math.cos(vo.w);
  var s = Math.sin(vo.w);
  var tz = (1 - c) * vo.z;
  var roll = new x3dom.fields.SFVec3f(tz * vo.x + s * vo.y, tz * vo.y - s * vo.x, tz * vo.z + c);
  var target = vp.add(roll.multiply(scaleFactor));
  viewpoint.setAttribute('position', target.toString());
  if (that.onmousewheel)
    that.onmousewheel(event);
}, true);
</t>
<t tx="leo.20210414181027.52">that.x3dNode.addEventListener('mousemove', function(event) {
  if (!that.enableNavigation &amp;&amp; event.button === 0)
    return;
  if (that.mouseState.x === undefined)
    // mousedown event has not been called yet
    // this could happen for example when another application has focus while loading the scene
    return;
  if ('buttons' in event)
    that.mouseState.mouseDown = event.buttons;
  else if ('which' in event) { // Safari only
    switch (event.which) {
      case 0: that.mouseState.mouseDown = 0; break;
      case 1: that.mouseState.mouseDown = 1; break;
      case 2: that.mouseState.pressedButton = 4; break;
      case 3: that.mouseState.pressedButton = 2; break;
      default: that.mouseState.pressedButton = 0; break;
    }
  }
  if (that.mouseState.mouseDown === 0) {
    if (that.animation &amp;&amp; that.animation.playSlider &amp;&amp; that.animation.sliding) {
      var w = event.target.clientWidth - 66; // size of the borders of the slider
      var x = event.clientX - event.target.getBoundingClientRect().left - 48; // size of the left border (including play button) of the slider
      var value = 100 * x / w;
      if (value &lt; 0)
        value = 0;
      else if (value &gt;= 100)
        value = 99.999;
      that.animation.playSlider.slider('value', value);
      // setting the value should trigger the change event, unfortunately, doesn't seem to work reliably,
      // therefore, we need to trigger this event manually:
      var ui = {};
      ui.value = value;
      that.animation.playSlider.slider('option', 'change').call(that.animation.playSlider, event, ui);
    }
    return;
  }
  if (that.mouseState.initialTimeStamp === null)
    // prevent applying mouse move action before drag initialization in mousedrag event
    return;

  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var params = {};
  params.dx = event.clientX - that.mouseState.x;
  params.dy = event.clientY - that.mouseState.y;
  params.vp = x3dom.fields.SFVec3f.parse(viewpoint.getAttribute('position'));
  params.vo = x3dom.fields.SFVec4f.parse(viewpoint.getAttribute('orientation'));
  params.c = Math.cos(params.vo.w);
  params.s = Math.sin(params.vo.w);

  if (that.mouseState.pickPosition == null)
    params.distanceToPickPosition = params.vp.length();
  else
    params.distanceToPickPosition = params.vp.subtract(that.mouseState.pickPosition).length() - 0.05; // FIXME this is different from webots.
  if (params.distanceToPickPosition &lt; 0.001) // 1 mm
    params.distanceToPickPosition = 0.001;

  // FIXME this is different from webots. We need to understand why the same formula doesn't work.
  params.scaleFactor = 1.90 * Math.tan(that.viewpointFieldOfView / 2);
  var viewHeight = parseFloat($(that.x3dNode).css('height').slice(0, -2));
  var viewWidth = parseFloat($(that.x3dNode).css('width').slice(0, -2));
  params.scaleFactor /= Math.max(viewHeight, viewWidth);

  if (that.mouseState.mouseDown === 1) { // left mouse button to rotate viewpoint
    params.distanceToPickPosition = 0;
    rotateViewpoint(viewpoint, params);
  } else if (that.mouseState.mouseDown === 2) // right mouse button to translate viewpoint {}
    translateViewpoint(viewpoint, params);
  else if (that.mouseState.mouseDown === 3 || that.mouseState.mouseDown === 4) { // both left and right button or middle button to zoom
    params.tiltAngle = 0.01 * params.dx;
    params.zoomScale = params.distanceToPickPosition * params.scaleFactor * 10 * params.dy; // FIXME this is different from webots.
    zoomAndTiltViewpoint(viewpoint, params, true);
  }
  that.mouseState.moved = event.clientX !== that.mouseState.x || event.clientY !== that.mouseState.y;
  that.mouseState.x = event.clientX;
  that.mouseState.y = event.clientY;
  if (that.onmousedrag)
    that.onmousedrag(event);
}, true);
</t>
<t tx="leo.20210414181027.53">that.x3dNode.addEventListener('mousedown', function(event) {
  that.mouseState.wheelFocus = true;
  if (event.button === 0)
    that.mouseState.mouseDown |= 1;
  else if (event.button === 1)
    that.mouseState.mouseDown |= 4;
  else if (event.button === 2)
    that.mouseState.mouseDown |= 2;
  initMouseMove(event);
}, true);
that.x3dNode.addEventListener('mouseup', clearMouseMove, true);
</t>
<t tx="leo.20210414181027.54">that.x3dNode.addEventListener('mouseover', function(event) {
  that.mouseState.wheelTimeout = setTimeout(wheelTimeoutCallback, 1500);
}, true);
</t>
<t tx="leo.20210414181027.55">  that.x3dNode.addEventListener('mouseleave', function(event) {
    if (that.mouseState.wheelTimeout != null) {
      clearTimeout(that.mouseState.wheelTimeout);
      that.mouseState.wheelTimeout = null;
    }
    that.mouseState.wheelFocus = false;
  }, true);
}

</t>
<t tx="leo.20210414181027.56">that.x3dScene.addEventListener('mouseup', function(event) {
  if (that.mouseState.moved === false &amp;&amp; (!that.mouseState.longClick || that.mobileDevice)) {
    var s = getTopX3dElement(event.target);
    if (that.previousSelection == null || that.previousSelection.id !== s.id || (that.mouseState.previousMouseDown === 2 &amp;&amp; (!that.mobileDevice || that.mouseState.longClick)))
      select(s);
    if (((that.mobileDevice &amp;&amp; that.mouseState.longClick) || (!that.mobileDevice &amp;&amp; that.mouseState.previousMouseDown === 2)) &amp;&amp;
        that.contextMenu === false &amp;&amp; that.isWebSocketProtocol) {
      // right click: show popup menu
      $(function() {
        var title = that.selection.getAttribute('name');
        if (title == null || title === '') {
          title = that.selection.getAttribute('DEF');
          if (title == null || title === '')
            title = 'Object';
        }
        $('#contextMenuTitle').html(title);
        var controller = that.selection.getAttribute('controller');
        if (controller) { // the current selection is a robot
          $('#contextMenuEditController').css('display', 'inline');
          if (controller === 'void' || controller.length === 0 || (webots.User1Id &amp;&amp; !webots.User1Authentication))
            $('#contextMenuEditController').children().addClass('ui-state-disabled');
          var robotName = that.selection.getAttribute('name');
          if (that.robotWindows[that.robotWindowNames[robotName]])
            $('#contextMenuRobotWindow').css('display', 'inline');
          else
            $('#contextMenuRobotWindow').css('display', 'none');
        } else {
          $('#contextMenuEditController').css('display', 'none');
          $('#contextMenuRobotWindow').css('display', 'none');
        }
        if (that.followedObject != null &amp;&amp; (that.selection.id === that.followedObject || that.selection.getAttribute('DEF') === that.followedObject)) {
          $('#contextMenuFollow').css('display', 'none');
          $('#contextMenuUnfollow').css('display', 'inline');
        } else {
          $('#contextMenuFollow').css('display', 'inline');
          $('#contextMenuUnfollow').css('display', 'none');
        }
        // ensure that the context menu is completely visible
        var w = $('#contextMenu').width();
        var h = $('#contextMenu').height();
        var maxWidth = $('#playerDiv').width();
        var maxHeight = $('#playerDiv').height();
        var left;
        var top;
        if (maxWidth != null &amp;&amp; (w + that.mouseState.x) &gt; maxWidth)
          left = maxWidth - w;
        else
          left = that.mouseState.x;
        if (maxHeight != null &amp;&amp; (h + that.mouseState.y) &gt; maxHeight)
          top = maxHeight - h - $('#toolBar').height();
        else
          top = that.mouseState.y;
        $('#contextMenu').css('left', left + 'px');
        $('#contextMenu').css('top', top + 'px');
        $('#contextMenu').css('display', 'block');
      });
    }
  }
  if (that.onmouseup)
    that.onmouseup(event);
}, false);
</t>
<t tx="leo.20210414181027.57"></t>
<t tx="leo.20210414181027.58">function wheelTimeoutCallback(event) {
  that.mouseState.wheelTimeout = null;
  that.mouseState.wheelFocus = true;
}
</t>
<t tx="leo.20210414181027.59">function getTopX3dElement(el) {
  // If it exists, return the upmost Solid, otherwise the top node
  var upmostSolid = null;
  while (el) {
    if (el.getAttribute('solid'))
      upmostSolid = el;
    if (el.parentNode === that.x3dScene)
      break;
    el = el.parentNode;
  }
  if (upmostSolid)
    return upmostSolid;
  return el;
}

</t>
<t tx="leo.20210414181027.6">this.onrobotwindowsdestroy = function() {
  that.robotWindowsGeometries = {};
  for (var win in that.robotWindows) {
    that.robotWindowsGeometries[win] = that.robotWindows[win].geometry();
    that.robotWindows[win].destroy();
  }
  that.infoWindow = null;
  that.robotWindows = {}; // delete robot windows
  that.robotWindowNames = {};
};
</t>
<t tx="leo.20210414181027.60">function unselect() {
  if (that.selection) {
    var selectors = that.selection.getElementsByClassName('selector');
    for (var i = 0; i &lt; selectors.length; i++) {
      var selector = selectors[i];
      selector.setAttribute('whichChoice', '-1');
    }
    that.selection = null;
  }
}

</t>
<t tx="leo.20210414181027.61">function select(el) {
  var selectors = el.getElementsByClassName('selector');
  for (var i = 0; i &lt; selectors.length; i++) {
    var selector = selectors[i];
    selector.setAttribute('whichChoice', '0');
  }
  that.selection = el;
}

</t>
<t tx="leo.20210414181027.62">function videoFinalize() {
  console.log('video finalize');
  addVideoMouseNavigation();
  if (that.onready)
    that.onready();
}

</t>
<t tx="leo.20210414181027.63">function sendVideoMouseEvent(type, event, wheel) {
  var socket = that.stream.socket;
  if (!socket || socket.readyState !== 1)
    return;
  var modifier = (event.shiftKey ? 1 : 0) + (event.ctrlKey ? 2 : 0) + (event.altKey ? 4 : 0);
  socket.send('mouse ' + type + ' ' + event.button + ' ' + that.mouseState.mouseDown + ' ' +
              event.offsetX + ' ' + event.offsetY + ' ' + modifier + ' ' + wheel);
}

</t>
<t tx="leo.20210414181027.64">function onVideoMouseDown(event) {
  event.target.addEventListener('mousemove', onVideoMouseMove, false);
  sendVideoMouseEvent(-1, event, 0);
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414181027.65">function onVideoMouseMove(event) {
  if (that.mouseState.mouseDown === 0) {
    event.target.removeEventListener('mousemove', onVideoMouseMove, false);
    return false;
  }
  sendVideoMouseEvent(0, event, 0);
  return false;
}

</t>
<t tx="leo.20210414181027.66">function onVideoMouseUp(event) {
  event.target.removeEventListener('mousemove', onVideoMouseMove, false);
  sendVideoMouseEvent(1, event, 0);
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414181027.67">function onVideoWheel(event) {
  sendVideoMouseEvent(2, event, Math.sign(event.deltaY));
  return false;
}

</t>
<t tx="leo.20210414181027.68">function onVideoContextMenu(event) {
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414181027.69">function addVideoMouseNavigation() {
  that.video.addEventListener('mousedown', onVideoMouseDown, false);
  that.video.addEventListener('mouseup', onVideoMouseUp, false);
  that.video.addEventListener('wheel', onVideoWheel, false);
  that.video.addEventListener('contextmenu', onVideoContextMenu, false);
}
</t>
<t tx="leo.20210414181027.7">this.onquit = function() {
  // If the simulation page URL is this https://mydomain.com/mydir/mysimulation.html, the quit action redirects to the
  // folder level, e.g., https://mydomain.com/mydir/
  // If the simulation page is https://mydomain.com/mydir/mysimulation/, the quit action redirects to the upper level:
  // https://mydomain.com/mydir/
  // You can change this behavior by overriding this onquit() method
  var currentLocation = window.location.href;
  // remove filename or last directory name from url and keep the final slash
  var quitDestination = currentLocation.substring(0, currentLocation.lastIndexOf('/', currentLocation.length - 2) + 1);
  window.location = quitDestination;
};
</t>
<t tx="leo.20210414181027.70">webots.View.prototype.toggleInfo = function() {
  $('#contextMenu').css('display', 'none');
  if (!this.infoWindow)
    return;
  if (this.infoWindow.isOpen()) {
    this.infoWindow.close();
    this.infoButton.classList.remove('toolBarButtonActive');
  } else {
    this.infoWindow.open();
    this.infoButton.classList.add('toolBarButtonActive');
  }
};

</t>
<t tx="leo.20210414181027.71">webots.View.prototype.follow = function(id) {
  this.followedObject = id;
  this.viewpointForce = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
  this.viewpointVelocity = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
};

</t>
<t tx="leo.20210414181027.72">webots.View.prototype.setViewpointMass = function(mass) {
  this.viewpointMass = mass;
  if (this.viewpointMass &lt;= 0.05)
    this.viewpointMass = 0.0;
  else {
    if (this.viewpointMass &gt; 1.0)
      this.viewpointMass = 1.0;
    this.friction = 0.05 / this.viewpointMass;
  }
};

</t>
<t tx="leo.20210414181027.73">webots.View.prototype.updateViewpointPosition = function(forcePosition) {
  if (this.time === undefined)
    return;
  if (this.viewpointLastUpdate === undefined)
    this.viewpointLastUpdate = this.time;

  var timeInterval = Math.abs(this.time - this.viewpointLastUpdate) / 1000;
  var viewpoints = this.x3dScene.getElementsByTagName('Viewpoint');

  if (timeInterval &gt; 0 &amp;&amp; viewpoints[0]) {
    this.viewpointLastUpdate = this.time;
    var viewpointPosition = x3dom.fields.SFVec3f.parse(viewpoints[0].getAttribute('position'));
    var viewpointDeltaPosition;
    if (this.followedObjectDeltaPosition != null)
      this.viewpointForce = this.viewpointForce.add(this.followedObjectDeltaPosition);

    // Special case: if the mass is 0 we simply move the viewpoint to its equilibrium position.
    // If timeInterval is too large (longer than 1/10 of a second), the progression won't be smooth either way,
    // so in this case we simply move the viewpoint to the equilibrium position as well.
    if (forcePosition || this.viewpointMass === 0 || (timeInterval &gt; 0.1 &amp;&amp; this.animation == null)) {
      viewpointDeltaPosition = this.viewpointForce;
      this.viewpointVelocity = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
    } else {
      var acceleration = this.viewpointForce.divide(this.viewpointMass);
      this.viewpointVelocity = this.viewpointVelocity.add(acceleration.multiply(timeInterval));
      var scalarVelocity = this.viewpointVelocity.length();

      // Velocity of the object projected onto the velocity of the viewpoint.
      var scalarObjectVelocityProjection;
      if (this.followedObjectDeltaPosition != null) {
        var objectVelocity = this.followedObjectDeltaPosition.divide(timeInterval);
        scalarObjectVelocityProjection = objectVelocity.dot(this.viewpointVelocity) / scalarVelocity;
      } else
        scalarObjectVelocityProjection = 0;

      // The viewpoint is going "faster" than the object, to prevent oscillations we apply a slowing force.
      if (this.viewpointFriction &gt; 0 &amp;&amp; scalarVelocity &gt; scalarObjectVelocityProjection) {
        // We apply a friction based on the extra velocity.
        var velocityFactor = (scalarVelocity - (scalarVelocity - scalarObjectVelocityProjection) * this.viewpointFriction) / scalarVelocity;
        this.viewpointVelocity = this.viewpointVelocity.multiply(velocityFactor);
      }
      viewpointDeltaPosition = this.viewpointVelocity.multiply(timeInterval);
    }
    var viewpointNewPosition = viewpointPosition.add(viewpointDeltaPosition);
    this.viewpointForce = this.viewpointForce.subtract(viewpointDeltaPosition);
    viewpoints[0].setAttribute('position', viewpointNewPosition.toString());
    this.followedObjectDeltaPosition = null;
  }
};

</t>
<t tx="leo.20210414181027.74">webots.View.prototype.close = function() {
  if (this.server)
    this.server.socket.close();
  if (this.stream)
    this.stream.close();
};

</t>
<t tx="leo.20210414181027.75">webots.View.prototype.sendRobotMessage = function(robot, message) {
  this.stream.socket.send('robot:' + robot + ':' + message);
};

</t>
<t tx="leo.20210414181027.76">webots.View.prototype.resize = function(width, height) {
  if (this.mode !== 'video')
    return;
  this.video.width = width;
  this.video.height = height;
  this.stream.socket.send('resize: ' + width + 'x' + height);
};

</t>
<t tx="leo.20210414181027.77">webots.View.prototype.getControllerUrl = function(name) {
  if (!this.server)
    return;
  var port = 0;
  for (var i = 0; i &lt; this.server.controllers.length; i++) {
    if (this.server.controllers[i].name === name) {
      port = this.server.controllers[i].port;
      break;
    }
  }
  if (port === 0)
    return;
  return this.url.substring(0, this.url.indexOf(':', 6) + 1) + port;
};

</t>
<t tx="leo.20210414181027.78">webots.View.prototype.setAnimation = function(url, gui, loop) {
  if (gui === undefined)
    gui = 'play';
  if (loop === undefined)
    loop = true;
  this.animation = new webots.Animation(url, this, gui, loop);
};

</t>
<t tx="leo.20210414181027.79">webots.View.prototype.applyPose = function(pose) {
  var id = pose.id;
  var el = document.getElementById('n' + id);
  if (el &amp;&amp; !el.getAttribute('blockWebotsUpdate')) {
    for (var key in pose) {
      if (key !== 'id') {
        var value = pose[key];
        if (key === 'translation' &amp;&amp; this.followedObject &amp;&amp;
            (id === this.followedObject || // animation case
             el.id === this.followedObject || // streaming case
             el.getAttribute('DEF') === this.followedObject)) {
          var objectPosition = x3dom.fields.SFVec3f.parse(el.getAttribute('translation'));
          el.setAttribute(key, value);
          // If this is the followed object, we save a vector with the translation applied
          // to the object to compute the new position of the viewpoint.
          var objectNewPosition = x3dom.fields.SFVec3f.parse(value);
          this.followedObjectDeltaPosition = objectNewPosition.subtract(objectPosition);
        } else
          el.setAttribute(key, value);
      }
    }
  }
};

</t>
<t tx="leo.20210414181027.8">this.onresize = function() {
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var viewHeight = parseFloat($(that.x3dNode).css('height').slice(0, -2));
  var viewWidth = parseFloat($(that.x3dNode).css('width').slice(0, -2));
  if (that.viewpointFieldOfView == null) {
    var fieldOfView = viewpoint.getAttribute('fieldOfView');
    // Sometimes the page is not fully loaded by that point and the field of view is not yet available.
    // In that case we add a callback at the end of the queue to try again when all other callbacks are finished.
    if (fieldOfView == null) {
      setTimeout(that.onresize, 0);
      return;
    }
    that.viewpointFieldOfView = fieldOfView;
  }

  var fieldOfViewY = that.viewpointFieldOfView;
  if (viewWidth &gt; viewHeight) {
    var tanHalfFieldOfViewY = Math.tan(0.5 * that.viewpointFieldOfView) * viewHeight / viewWidth;
    fieldOfViewY = 2.0 * Math.atan(tanHalfFieldOfViewY);
  }

  viewpoint.setAttribute('fieldOfView', fieldOfViewY);
};
</t>
<t tx="leo.20210414181027.80">webots.Animation = function(url, view, gui, loop) { // gui may be either "play" or "pause"
  this.url = url;
  this.view = view;
  this.gui = gui;
  this.loop = loop;
  this.sliding = false;
  this.onready = null;
};

</t>
<t tx="leo.20210414181027.81">webots.Animation.prototype.init = function(onready) {
  var that = this;
  this.onready = onready;
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.open('GET', this.url, true);
  xmlhttp.overrideMimeType('application/json');
  @others
};

</t>
<t tx="leo.20210414181027.82">xmlhttp.onreadystatechange = function() {
  if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200)
    setup(JSON.parse(xmlhttp.responseText));
};
xmlhttp.send();
</t>
<t tx="leo.20210414181027.83">function setup(data) {
  that.data = data;
  var div = document.createElement('div');
  div.id = 'playBar';
  that.view.view3D.appendChild(div);
  that.button = document.createElement('button');
  that.button.id = 'playPauseButton';
  var action = (that.gui === 'play') ? 'pause' : 'play';
  that.button.style.backgroundImage = 'url(' + webots.WwiUrl + action + '.png)';
  that.button.style.padding = '0';
  that.button.onclick = triggerPlayPauseButton;
  div.appendChild(that.button);
  var slider = document.createElement('div');
  slider.id = 'playSlider';
  div.appendChild(slider);
  that.playSlider = $('#playSlider').slider({
    change: function(e, ui) { updateSlider(ui.value); },
    slide: function(e, ui) { updateSlider(ui.value); },
    start: function(e, ui) { that.sliding = true; },
    stop: function(e, ui) { that.sliding = false; }
  });
  that.start = new Date().getTime();
  that.step = 0;
  that.previousStep = 0;
  updateAnimation();
  if (that.onready)
    that.onready();
}

</t>
<t tx="leo.20210414181027.84">function elapsedTime() {
  var end = new Date().getTime();
  return end - that.start;
}

</t>
<t tx="leo.20210414181027.85">function triggerPlayPauseButton() {
  that.button.style.backgroundImage = 'url(' + webots.WwiUrl + that.gui + '.png)';
  if (that.gui === 'play') {
    that.gui = 'pause';
    if (that.step &lt; 0 || that.step &gt;= that.data.frames.length) {
      that.start = new Date().getTime();
      updateAnimationState(true);
    } else
      that.start = new Date().getTime() - that.data.basicTimeStep * that.step;
  } else {
    that.gui = 'play';
    that.start = new Date().getTime() - that.data.basicTimeStep * that.step;
    requestAnimationFrame(updateAnimation);
  }
}

</t>
<t tx="leo.20210414181027.86">function connectSliderEvents() {
  that.playSlider = that.playSlider.slider({
    change: function(e, ui) { updateSlider(ui.value); },
    slide: function(e, ui) { updateSlider(ui.value); },
    start: function(e, ui) { that.sliding = true; },
    stop: function(e, ui) { that.sliding = false; }
  });
}

</t>
<t tx="leo.20210414181027.87">function disconnectSliderEvents() {
  that.playSlider.slider({change: null, slide: null});
}

</t>
<t tx="leo.20210414181027.88">function updateSlider(value) {
  that.step = Math.floor(that.data.frames.length * value / 100);
  that.start = (new Date().getTime()) - Math.floor(that.data.basicTimeStep * that.step);
  updateAnimationState(false);
}

</t>
<t tx="leo.20210414181027.89">function updateAnimationState(moveSlider) {
  if (moveSlider) {
    that.step = Math.floor(elapsedTime() / that.data.basicTimeStep);
    if (that.step &lt; 0 || that.step &gt;= that.data.frames.length) {
      if (that.loop) {
        if (that.step &gt; that.data.frames.length) {
          that.step = 0;
          that.previousStep = 0;
          that.start = new Date().getTime();
        } else
          return;
      } else if (that.gui === 'play') {
        triggerPlayPauseButton();
        return;
      } else
        return;
    }
  }
  var p;
  var appliedIds = [];
  if (that.data.frames[that.step].hasOwnProperty('poses')) {
    var poses = that.data.frames[that.step].poses;
    for (p = 0; p &lt; poses.length; p++) {
      that.view.applyPose(poses[p]);
      appliedIds[appliedIds.length] = poses[p].id;
    }
  }
  // lookback mechanism: search in history
  if (that.step !== that.previousStep + 1) {
    var previousPoseStep;
    if (that.step &gt; that.previousStep)
      // in forward animation check only the changes since last pose
      previousPoseStep = that.previousStep;
    else
      previousPoseStep = 0;
    var allIds = that.data.ids.split(';');
    for (var i = 0; i &lt; allIds.length; i++) {
      var id = parseInt(allIds[i]);
      if (appliedIds.indexOf(id) === -1) {
        outer:
        for (var f = that.step - 1; f &gt;= previousPoseStep; f--) {
          if (that.data.frames[f].poses) {
            for (p = 0; p &lt; that.data.frames[f].poses.length; p++) {
              if (that.data.frames[f].poses[p].id === id) {
                that.view.applyPose(that.data.frames[f].poses[p]);
                break outer;
              }
            }
          }
        }
      }
    }
  }
  if (moveSlider) {
    disconnectSliderEvents();
    that.playSlider.slider('option', 'value', 100 * that.step / that.data.frames.length);
    connectSliderEvents();
  }
  that.previousStep = that.step;
  that.view.time = that.data.frames[that.step].time;
  if (that.view.followedObject != null &amp;&amp; that.view.followedObject !== 'none')
    that.view.updateViewpointPosition(!moveSlider | that.step === 0);
}

</t>
<t tx="leo.20210414181027.9">this.ondialogwindow = function(opening) {
  // Pause the simulation if needed when a pop-up dialog window is open
  // and restart running the simulation when it is closed
  if (opening &amp;&amp; that.isAutomaticallyPaused === undefined) {
    that.isAutomaticallyPaused = webots.currentView.pauseButton.style.display === 'inline';
    that.pauseButton.click();
  } else if (!opening &amp;&amp; that.isAutomaticallyPaused) {
    that.real_timeButton.click();
    that.isAutomaticallyPaused = undefined;
  }
};
window.onresize = this.onresize;
this.robotWindowNames = {}; // map robot name to robot window name used as key in robotWindows lists
this.robotWindows = {};
this.followedObject = null; // after initialization contains the id of the followed node or -1 if no object is followed
// If the followed object has moved since the last time we updated the viewpoint position, this field will contain a
// vector with the translation applied to the object.
this.followedObjectDeltaPosition = null;
this.viewpointMass = 1.0; // Mass of the viewpoint used during the object following algorithm.
this.viewpointFriction = 0.05; // Friction applied to the viewpoint whenever it is going faster than the followed object.
this.viewpointForce = null; // Vector with the force that will be applied to the viewpoint for the next delta T.
this.viewpointVelocity = null; // Current velocity of the viewpoint.
this.viewpointLastUpdate = undefined; // Last time we updated the position of the viewpoint.
this.onmousedown = null;
this.onworldloaded = null;
this.view3D = view3D;
this.viewpointFieldOfView = null;
if (mobile === undefined)
  this.mobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
else
  this.mobileDevice = mobile;
this.fullscreenEnabled = !/iPhone|iPad|iPop/i.test(navigator.userAgent);
if (!this.fullscreenEnabled)
  // add tag needed to run standalone web page in fullscreen on iOS
  $('head').append('&lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;');

// prevent the backspace key to quit the simulation page
var rx = /INPUT|SELECT|TEXTAREA/i;
</t>
<t tx="leo.20210414181027.90">function updateAnimation() {
  if (that.gui === 'play') {
    updateAnimationState(true);
    requestAnimationFrame(updateAnimation);
  }
}
</t>
<t tx="leo.20210414181027.91">webots.Server = function(url, view, onready) {
  var that = this;
  this.view = view;
  this.onready = onready;
  // url has the following form: "ws(s)://cyberbotics2.cyberbotics.com:80/simple/worlds/simple.wbt"
  var n = url.indexOf('/', 6);
  var m = url.lastIndexOf('/');
  this.url = 'http' + url.substring(2, n); // e.g., "http(s)://cyberbotics2.cyberbotics.com:80"
  this.project = url.substring(n + 1, m - 7); // e.g., "simple"
  this.worldFile = url.substring(m + 1); // e.g., "simple.wbt"
  this.controllers = [];
  var xhr = new XMLHttpRequest();
  xhr.open('GET', this.url + '/session', true);
  $('#webotsProgressMessage').html('Connecting to session server...');
  xhr.onreadystatechange = function(e) {
    if (xhr.readyState !== 4)
      return;
    if (xhr.status !== 200)
      return;
    var data = xhr.responseText;
    if (data.startsWith('Error:')) {
      $('#webotsProgress').hide();
      var errorMessage = data.substring(6).trim();
      errorMessage = errorMessage.charAt(0).toUpperCase() + errorMessage.substring(1);
      webots.alert('Session server error', errorMessage);
      return;
    }
    that.socket = new WebSocket(data + '/client');
    @others
  };
  xhr.send();
};

</t>
<t tx="leo.20210414181027.92"></t>
<t tx="leo.20210414181027.93">that.socket.onopen = function(event) {
  var host = location.protocol + '//' + location.host.replace(/^www./, ''); // remove 'www' prefix
  if (typeof webots.User1Id === 'undefined')
    webots.User1Id = '';
  if (typeof webots.User1Name === 'undefined')
    webots.User1Name = '';
  if (typeof webots.User1Authentication === 'undefined')
    webots.User1Authentication = '';
  if (typeof webots.User2Id === 'undefined')
    webots.User2Id = '';
  if (typeof webots.User2Name === 'undefined')
    webots.User2Name = '';
  if (typeof webots.CustomData === 'undefined')
    webots.CustomData = '';
  this.send('{ "init" : [ "' + host + '", "' + that.project + '", "' + that.worldFile + '", "' +
            webots.User1Id + '", "' + webots.User1Name + '", "' + webots.User1Authentication + '", "' +
            webots.User2Id + '", "' + webots.User2Name + '", "' + webots.CustomData + '" ] }');
  $('#webotsProgressMessage').html('Starting simulation...');
};
</t>
<t tx="leo.20210414181027.94">that.socket.onclose = function(event) {
  view.console.info('Disconnected to the Webots server.');
};
</t>
<t tx="leo.20210414181027.95">that.socket.onmessage = function(event) {
  var message = event.data;
  if (message.indexOf('webots:ws://') === 0 || message.indexOf('webots:wss://') === 0)
    view.stream = new webots.Stream(message.substring(7), view, that.onready);
  else if (message.indexOf('controller:') === 0) {
    var n = message.indexOf(':', 11);
    var controller = {};
    controller.name = message.substring(11, n);
    controller.port = message.substring(n + 1);
    view.console.info('Using controller ' + controller.name + ' on port ' + controller.port);
    that.controllers.push(controller);
  } else if (message.indexOf('queue:') === 0)
    view.console.error('The server is saturated. Queue to wait: ' + message.substring(6) + ' client(s).');
  else if (message === '.') { // received every 5 seconds when Webots is running
    // nothing to do
  } else if (message.indexOf('reset controller:') === 0)
    view.stream.socket.send('sync controller:' + message.substring(18).trim());
  else
    console.log('Received an unknown message from the Webots server socket: "' + message + '"');
};
</t>
<t tx="leo.20210414181027.96">that.socket.onerror = function(event) {
  view.console.error('Cannot connect to the simulation server');
};
</t>
<t tx="leo.20210414181027.97">webots.Server.prototype.resetController = function(filename) {
  this.socket.send('{ "reset controller" : "' + filename + '" }');
};

</t>
<t tx="leo.20210414181027.98">webots.Stream = function(url, view, onready) {
  var that = this;
  this.view = view;
  this.onready = onready;

  this.socket = new WebSocket(url);
  $('#webotsProgressMessage').html('Connecting to Webots instance...');
  @others
};

</t>
<t tx="leo.20210414181027.99">this.socket.onopen = function() {
  var mode = that.view.mode;
  if (mode === 'video')
    mode += ': ' + that.view.video.width + 'x' + that.view.video.height;
  else if (that.view.broadcast)
    mode += ';broadcast';
  that.socket.send(mode);
};
</t>
<t tx="leo.20210414181031.1"></t>
<t tx="leo.20210414181045.1">/*
 * Injects a Webots 3D view inside a HTML tag.
 * @class
 * @classdesc
 *   The Webots view object displays a 3D view on a web page.
 *   This view represents a Webots simulation world that may be
 *   connected to a webots instance running on a remote server.
 *   This library depends on the x3dom-full.js library
 * @example
 *   // Example: Initialize from a Webots streaming server
 *   var view = new webots.View(document.getElementById("myDiv"));
 *   view.open("ws://localhost:80/simple/worlds/simple.wbt");
 *   // or view.open("ws://localhost:80");
 *   // or view.open("file.x3d");
 *   view.onready = function() {
 *       // the initialization is done
 *   }
 *   view.onclose = function() {
 *       view = null;
 *   }
 */

/* global x3dom: false */
/* global ace: false */
/* global MathJax: false */
/* eslint no-extend-native: ["error", { "exceptions": ["String"] }] */
/* eslint no-eval: "off" */

/* The following member variables should be set by the application:

webots.User1Id             // ID of the main user (integer value &gt; 0). If 0 or unset, the user is not logged in.
webots.User1Name           // user name of the main user.
webots.User1Authentication // password or authentication for the main user (empty or unset if user not authenticated).
webots.User2Id             // ID of the secondary user (in case of a soccer match between two different users). 0 or unset if not used.
webots.User2Name           // user name of the secondary user.
webots.CustomData          // application specific data to be passed to the simulation server

*/

var webots = window.webots || {};

var scripts = document.getElementsByTagName('script');
webots.WwiUrl = scripts[scripts.length - 1].src;
webots.WwiUrl = webots.WwiUrl.substr(0, webots.WwiUrl.lastIndexOf('/') + 1); // remove "webots.js"

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20210414181059.1">webots.View = function(view3D, mobile) {
  webots.currentView = this;
  var that = this;
  @others
};

</t>
<t tx="leo.20210414181059.10">$(document).bind('keydown keypress', function(e) {
  if (e.which === 8) { // backspace key
    if (!rx.test(e.target.tagName) || e.target.disabled || e.target.readOnly)
      e.preventDefault();
  }
});
this.view3D.className = view3D.className + ' webotsView';
$(this.view3D).append(
  "&lt;ul id='contextMenu'&gt;" +
  "&lt;li class='ui-widget-header'&gt;&lt;div id='contextMenuTitle'&gt;Object&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuFollow'&gt;&lt;div&gt;Follow&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuUnfollow'&gt;&lt;div&gt;Unfollow&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Zoom&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuRobotWindow'&gt;&lt;div id='contextMenuRobotWindowDiv'&gt;Robot window&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li id='contextMenuEditController'&gt;&lt;div id='contextMenuEditControllerDiv'&gt;Edit controller&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Delete&lt;/div&gt;&lt;/li&gt;" +
  "&lt;li&gt;&lt;div class='ui-state-disabled'&gt;Properties&lt;/div&gt;&lt;/li&gt;" +
  '&lt;/ul&gt;');
$('#contextMenu').menu({items: '&gt; :not(.ui-widget-header)'});
$('#contextMenu').css('position', 'absolute');
$('#contextMenu').css('z-index', 1);
$('#contextMenu').css('display', 'none');
</t>
<t tx="leo.20210414181059.100">this.socket.onclose = function(event) {
  view.onerror('Disconnected from ' + url + ' (' + event.code + ')');
  if ((event.code &gt; 1001 &amp;&amp; event.code &lt; 1016) || (event.code === 1001 &amp;&amp; view.quitting === false)) { // https://tools.ietf.org/html/rfc6455#section-7.4.1
    webots.alert('Streaming server error',
      'Connection closed abnormally.&lt;br&gt;(Error code: ' + event.code + ')&lt;br&gt;&lt;br&gt;' +
      'Please reset the simulation by clicking ' +
      '&lt;a href="' + window.location.href + '"&gt;here&lt;/a&gt;.');
  }
  destroyWorld();
  if (view.onclose)
    view.onclose();
};
</t>
<t tx="leo.20210414181059.101">this.socket.onmessage = function(event) {
  var lines, i;
  var data = event.data;
  if (data.startsWith('robot:') ||
      data.startsWith('stdout:') ||
      data.startsWith('stderr:')) {
    lines = data.split('\n'); // in that case, we support one message per line
    for (i = 0; i &lt; lines.length; i++) {
      var line = lines[i];
      if (line === '') // FIXME: should not happen
        continue;
      if (line.startsWith('stdout:'))
        view.console.stdout(line.substring(7));
      else if (line.startsWith('stderr:'))
        view.console.stderr(line.substring(7));
      else if (line.startsWith('robot:')) {
        var secondColonIndex = line.indexOf(':', 6);
        var robot = line.substring(6, secondColonIndex);
        var message = line.substring(secondColonIndex + 1);
        that.view.onrobotmessage(robot, message);
      }
    }
  } else if (data.startsWith('application/json:')) {
    if (that.view.time !== undefined) { // otherwise ignore late updates until the scene loading is completed
      data = data.substring(data.indexOf(':') + 1);
      var frame = JSON.parse(data);
      that.view.time = frame.time;
      $('#webotsClock').html(webots.parseMillisecondsIntoReadableTime(frame.time));
      if (frame.hasOwnProperty('poses')) {
        for (i = 0; i &lt; frame.poses.length; i++)
          that.view.applyPose(frame.poses[i]);
      }
      if (that.view.followedObject != null &amp;&amp; that.view.followedObject !== 'none')
        that.view.updateViewpointPosition();
    }
  } else if (data.startsWith('node:')) {
    data = data.substring(data.indexOf(':') + 1);
    var parentId = data.split(':')[0];
    data = data.substring(data.indexOf(':') + 1);
    var parser = new DOMParser();
    var x3d = parser.parseFromString(data, 'text/xml').children[0];
    if (parentId === '0')
      that.view.x3dScene.appendChild(x3d);
    else
      document.getElementById('n' + parentId).appendChild(x3d);
  } else if (data.startsWith('delete:')) {
    data = data.substring(data.indexOf(':') + 1).trim();
    var itemToDelete = document.getElementById('n' + data);
    if (itemToDelete) {
      if (that.selection === itemToDelete)
        that.selection = null;
      itemToDelete.parentElement.removeChild(itemToDelete);
    }
  } else if (data.startsWith('model:')) {
    $('#webotsProgressMessage').html('Loading 3D scene...');
    destroyWorld();
    data = data.substring(data.indexOf(':') + 1).trim();
    if (!data) // received an empty model case: just destroy the view
      return;
    var scene = data.substring(data.indexOf('&lt;Scene&gt;') + 8, data.lastIndexOf('&lt;/Scene&gt;'));
    $(that.view.x3dScene).append(scene);
    that.view.onresize();
  } else if (data.startsWith('image')) {
    var textureUrl = data.substring(data.indexOf('[') + 1, data.indexOf(']'));
    data = data.substring(data.indexOf(':') + 1);
    // replace in ImageTexture nodes
    var textures = that.view.x3dScene.getElementsByTagName('ImageTexture');
    for (i = 0; i &lt; textures.length; i++) {
      var texture = textures[i];
      if (that.compareTextureUrl(texture.getAttribute('url'), textureUrl))
        texture.setAttribute('url', data);
    }
    // replace in Background nodes
    var backgrounds = that.view.x3dScene.getElementsByTagName('Background');
    var backgroundUrlFieldNames = ['frontUrl', 'backUrl', 'leftUrl', 'rightUrl', 'topUrl', 'bottomUrl'];
    for (i = 0; i &lt; backgrounds.length; i++) {
      var background = backgrounds[i];
      for (var j = 0; j &lt; backgroundUrlFieldNames.length; j++) {
        var backgroundUrlFieldName = backgroundUrlFieldNames[j];
        if (that.compareTextureUrl(background.getAttribute(backgroundUrlFieldName), textureUrl))
          background.setAttribute(backgroundUrlFieldName, data);
      }
    }
  } else if (data.startsWith('video: ')) {
    console.log('Received data = ' + data);
    var list = data.split(' ');
    var url = list[1];
    var streamId = list[2];
    console.log('Received video message on ' + url + ' stream = ' + streamId);
    that.VideoStream = new webots.VideoStream(url, view.video, document.getElementById('BitrateViewer'), streamId);
    if (that.onready)
      that.onready();
  } else if (data.startsWith('set controller:')) {
    var slash = data.indexOf('/', 15);
    var dirname = data.substring(15, slash);
    var filename = data.substring(slash + 1, data.indexOf(':', slash + 1));
    if (that.view.editor.dirname === dirname)
      that.view.editor.addFile(filename, data.substring(data.indexOf('\n') + 1)); // remove the first line
    else
      console.log('Warning: ' + filename + ' not in controller directory: ' + dirname + ' != ' + that.view.editor.dirname);
  } else if (data === 'pause') {
    that.view.pauseButton.style.display = 'none';
    that.view.real_timeButton.style.display = 'inline';
    if (that.view.timeout &gt; 0 &amp;&amp; !that.view.isAutomaticallyPaused) {
      that.view.deadline = that.view.timeout;
      if (that.view.time !== undefined)
        that.view.deadline += that.view.time;
      $('#webotsTimeout').html(webots.parseMillisecondsIntoReadableTime(that.view.deadline));
    }
  } else if (data === 'real-time' || data === 'run' || data === 'fast') {
    that.view.pauseButton.style.display = 'inline';
    that.view.real_timeButton.style.display = 'none';
    if (that.view.timeout &gt;= 0)
      that.view.stream.socket.send('timeout:' + that.view.timeout);
  } else if (data === 'scene load completed') {
    that.view.time = 0;
    $('#webotsClock').html(webots.parseMillisecondsIntoReadableTime(0));
    if (that.onready)
      that.onready();
  } else if (data === 'reset finished') {
    // remove labels
    var labels = document.getElementsByClassName('webotsLabel');
    for (i = labels.length - 1; i &gt;= 0; i--) {
      var element = labels.item(i);
      element.parentNode.removeChild(element);
    }
    $('#webotsClock').html(webots.parseMillisecondsIntoReadableTime(0));
    if (that.onready)
      that.onready();
    that.view.deadline = that.view.timeout;
    $('#webotsTimeout').html(webots.parseMillisecondsIntoReadableTime(that.view.deadline));
    // restore viewpoint
    var viewpoint = that.view.x3dScene.getElementsByTagName('Viewpoint')[0];
    viewpoint.setAttribute('position', that.view.initialViewpointPosition);
    viewpoint.setAttribute('orientation', that.view.initialViewpointOrientation);
    that.view.updateViewpointPosition(true);
  } else if (data.startsWith('label')) {
    var semiColon = data.indexOf(';');
    var id = data.substring(data.indexOf(':'), semiColon);
    var previousSemiColon;
    var labelProperties = []; // ['font', 'color', 'size', 'x', 'y', 'text']
    for (i = 0; i &lt; 5; i++) {
      previousSemiColon = semiColon + 1;
      semiColon = data.indexOf(';', previousSemiColon);
      labelProperties.push(data.substring(previousSemiColon, semiColon));
    }
    var text = data.substring(semiColon + 1, data.length);
    var labelElement = document.getElementById('label' + id);
    if (labelElement == null) {
      labelElement = document.createElement('div');
      labelElement.id = 'label' + id;
      labelElement.className = 'webotsLabel';
      that.view.x3dNode.appendChild(labelElement);
    }
    labelElement.style.fontFamily = labelProperties[0];
    labelElement.style.color = labelProperties[1];
    labelElement.style.fontSize = $(that.view.x3dNode).height() * labelProperties[2] / 2.25 + 'px'; // 2.25 is an empirical value to match with Webots appearance
    labelElement.style.left = $(that.view.x3dNode).width() * labelProperties[3] + 'px';
    labelElement.style.top = $(that.view.x3dNode).height() * labelProperties[4] + 'px';
    labelElement.innerHTML = text;
  } else
    console.log('WebSocket error: Unknown message received: "' + data + '"');
};
</t>
<t tx="leo.20210414181059.102">this.socket.onerror = function(event) {
  destroyWorld();
  view.onerror('WebSocket error: ' + event.data);
};
</t>
<t tx="leo.20210414181059.103">function destroyWorld() {
  that.view.selection = null;
  if (that.view.x3dScene) {
    while (that.view.x3dScene.hasChildNodes())
      // remove from last to avoid issues with USE/DEF nodes
      that.view.x3dScene.removeChild(that.view.x3dScene.lastChild);
  }

  // remove labels
  var labels = document.getElementsByClassName('webotsLabel');
  for (var i = labels.length - 1; i &gt;= 0; i--) {
    var element = labels.item(i);
    element.parentNode.removeChild(element);
  }
}
</t>
<t tx="leo.20210414181059.104">webots.Stream.prototype.compareTextureUrl = function(attributeUrl, textureUrl) {
  if (!attributeUrl || !textureUrl)
    return false;
  if (typeof attributeUrl === 'object')
    // Default url attribute is an Array instance (x3dom.field.MFString) of length 0
    return false;

  var value = attributeUrl.trim();
  if (!(value.startsWith('"') &amp;&amp; value.endsWith('"')))
    // single texture without list quotes
    return attributeUrl === textureUrl;

  // Simple algorithm supporting multiple textures with some limitations:
  // 1. the url attribute priority order is not respected: the first texture received by Webots is used
  // 2. escaped double quotes in url are not supported: for example "textures/my_\"texture\".jpeg"
  var start = 1;
  var end = value.indexOf('"', start);
  while (end &gt;= 0) {
    var url = value.slice(start, end);
    if (url === textureUrl)
      return true;
    start = value.indexOf('"', end + 1) + 1;
    if (start &lt;= 0)
      break;
    end = value.indexOf('"', start);
  }
  return false;
};

</t>
<t tx="leo.20210414181059.105">webots.Stream.prototype.close = function() {
  if (this.socket)
    this.socket.close();
  if (this.videoStream)
    this.videoStream.close();
};

</t>
<t tx="leo.20210414181059.106">function webotsClampDialogSize(preferredGeometry) {
  if ($('#playerDiv').height === undefined || $('#playerDiv').width === undefined)
    return preferredGeometry;

  var maxHeight = $('#playerDiv').height() - preferredGeometry.top - $('#toolBar').height() - 20; // 20 is chosen arbitrarily
  var maxWidth = $('#playerDiv').width() - preferredGeometry.left - 20; // 20 is chosen arbitrarily
  var height = preferredGeometry.height;
  var width = preferredGeometry.width;
  if (maxHeight &lt; height)
    height = maxHeight;
  if (maxWidth &lt; width)
    width = maxWidth;
  return {width: width, height: height};
}

</t>
<t tx="leo.20210414181059.107">function webotsResizeDialogOnOpen(dialog) {
  var w = $(dialog).parent().width();
  var h = $(dialog).parent().height();
  var clampedSize = webotsClampDialogSize({left: 0, top: 0, width: w, height: h});
  if (clampedSize.width &lt; w)
    $(dialog).dialog('option', 'width', clampedSize.width);
  if (clampedSize.height &lt; h)
    $(dialog).dialog('option', 'height', clampedSize.height);
}

</t>
<t tx="leo.20210414181059.108">function webotsOpenDialog() {
  webotsResizeDialogOnOpen(this);
  $(this).parent().css('opacity', 0.9);
  $(this).parent().hover(function() {
    $(this).css('opacity', 0.99);
  }, function(event) {
    $(this).css('opacity', 0.9);
  });
}

</t>
<t tx="leo.20210414181059.109"></t>
<t tx="leo.20210414181059.11">$('#contextMenu').on('menuselect', function(event, ui) {
  if (ui.item.children().hasClass('ui-state-disabled'))
    return;
  var id = ui.item.attr('id');
  if (id === 'contextMenuFollow')
    that.follow(that.selection.id);
  else if (id === 'contextMenuUnfollow')
    that.follow('none');
  else if (id === 'contextMenuEditController') {
    var controller = that.selection.getAttribute('controller');
    $('#webotsEditor').dialog('open');
    $('#webotsEditor').dialog('option', 'title', 'Controller: ' + controller);
    if (that.editor.dirname !== controller) {
      that.editor.closeAllTabs();
      that.editor.dirname = controller;
      that.stream.socket.send('get controller:' + controller);
    }
  } else if (id === 'contextMenuRobotWindow') {
    var robotName = that.selection.getAttribute('name');
    var win = that.robotWindows[that.robotWindowNames[robotName]];
    if (win) {
      if (win === that.infoWindow) {
        if (!that.infoWindow.isOpen())
          that.toggleInfo();
      } else
        win.open();
    } else
      console.log('No valid robot window for robot: ' + that.selection.getAttribute('name'));
  } else
    console.log('Unknown menu item: ' + id);
  $('#contextMenu').css('display', 'none');
});
this.console = new webots.Console(view3D, this.mobileDevice);
this.editor = new webots.Editor(view3D, this);
this.infoWindow = null;
this.selection = null;
this.x3dScene = null;
this.x3dNode = null;
this.initialViewpointPosition = null;
this.initialViewpointOrientation = null;
this.mouseState = {
  'initialized': false,
  'mouseDown': 0,
  'moved': false,
  'pickPosition': null,
  'wheelFocus': false,
  'wheelTimeout': null
};
this.animation = null;
this.enableNavigation = true;
this.debug = false;
this.timeout = 60 * 1000; // default to one minute
this.time = undefined;
this.deadline = this.timeout;
this.runOnLoad = false;
this.quitting = false;
</t>
<t tx="leo.20210414181059.110">function webotsMobileCreateDialog() {
  // mobile only setup
  var closeButton = $('button:contains("WbClose")');
  closeButton.html('');
  closeButton.removeClass('ui-button-text-only');
  closeButton.addClass('mobile-dialog-close-button');
  closeButton.addClass('ui-button-icon-primary');
  closeButton.prepend('&lt;span class="ui-icon ui-icon-closethick"&gt;&lt;/span&gt;');
}

</t>
<t tx="leo.20210414181059.111">function webotsAddMobileDialogAttributes(params, panel) {
  params.dialogClass = 'mobile-no-default-buttons';
  params.create = webotsMobileCreateDialog;
  params.buttons = { 'WbClose': function() { $(panel).dialog('close'); } };
}

// the following two functions are used to make the resize and drag of the dialog
</t>
<t tx="leo.20210414181059.112">// steady (i.e., not loose the grab while resizing/dragging the dialog quickly)
function webotsDisablePointerEvents() {
  document.body.style['pointer-events'] = 'none';
}
</t>
<t tx="leo.20210414181059.113">function webotsEnablePointerEvents() {
  document.body.style['pointer-events'] = 'auto';
}

</t>
<t tx="leo.20210414181059.114">webots.Editor = function(parent, view) {
  var that = this;
  @others
};

</t>
<t tx="leo.20210414181059.115">function webotsEditorResize() {
  var padding = $('#webotsEditorTab').outerHeight() - $('#webotsEditorTab').height();
  $('#webotsEditorTab').height(that.tabs.clientHeight - that.tabsHeader.scrollHeight - padding);
  that.editor.resize();
}
</t>
<t tx="leo.20210414181059.116">function hideMenu() {
  if ($('#webotsEditorMenu').hasClass('pressed'))
    $('#webotsEditorMenu').removeClass('pressed');
}
</t>
<t tx="leo.20210414181059.117">function openResetConfirmDialog(allFiles) {
  that.resetAllFiles = allFiles;
  var titleText, message;
  message = 'Permanently reset ';
  if (allFiles) {
    message += 'all the files';
    titleText = 'Reset files?';
  } else {
    message += 'this file';
    titleText = 'Reset file?';
  }
  message += ' to the original version?';
  message += '&lt;br/&gt;&lt;br/&gt;Your modifications will be lost.';
  var confirmDialog = document.createElement('div');
  that.panel.appendChild(confirmDialog);
  $(confirmDialog).html(message);
  $(confirmDialog).dialog({
    title: titleText,
    modal: true,
    autoOpen: true,
    resizable: false,
    dialogClass: 'alert',
    open: webotsOpenDialog,
    appendTo: that.parent,
    buttons: {
      'Cancel': function() {
        $(this).dialog('close');
        $('#webotsEditorConfirmDialog').remove();
      },
      'Reset': function() {
        $(this).dialog('close');
        $('#webotsEditorConfirmDialog').remove();
        if (that.resetAllFiles) {
          for (var i = 0; i &lt; that.filenames.length; i++)
            that.view.server.resetController(that.dirname + '/' + that.filenames[i]);
        } else
          that.view.server.resetController(that.dirname + '/' + that.filenames[that.currentSession]);
      }
    }
  });
  hideMenu();
}
this.view = view;
this.filenames = [];
this.needToUploadFiles = [];
this.sessions = [];
this.panel = document.createElement('div');
this.panel.id = 'webotsEditor';
this.panel.className = 'webotsTabContainer';
that.parent = parent;
parent.appendChild(this.panel);
var clampedSize = webotsClampDialogSize({left: 0, top: 0, width: 800, height: 600});
var params = {
  title: 'Editor',
  resize: webotsEditorResize,
  resizeStart: webotsDisablePointerEvents,
  resizeStop: webotsEnablePointerEvents,
  dragStart: webotsDisablePointerEvents,
  dragStop: webotsEnablePointerEvents,
  width: clampedSize.width,
  height: clampedSize.height,
  autoOpen: false,
  appendTo: parent,
  open: function() {
    webotsResizeDialogOnOpen(that.panel);
  }
};
if (this.view.mobileDevice)
  webotsAddMobileDialogAttributes(params, this.panel);
$(this.panel).dialog(params).dialogExtend({maximizable: !this.view.mobileDevice});
var edit = document.createElement('div');
edit.id = 'webotsEditorTab';
edit.className = 'webotsTab';
this.editor = ace.edit(edit);
this.sessions[0] = this.editor.getSession();
this.currentSession = 0;
this.tabs = document.createElement('div');
this.tabs.id = 'webotsEditorTabs';
this.tabs.className = 'webotsTabs';
this.tabsHeader = document.createElement('ul');
this.tabs.appendChild(this.tabsHeader);
this.tabs.appendChild(edit);
$(this.tabs).tabs({activate: function(event, ui) {
  that.currentSession = parseInt(ui.newTab.attr('id').substr(5)); // skip 'file-'
  that.editor.setSession(that.sessions[that.currentSession]);
}});
this.panel.appendChild(this.tabs);
this.menu = document.createElement('div');
this.menu.id = 'webotsEditorMenu';
var saveShortcut;
if (navigator.appVersion.indexOf('Mac') === -1)
  saveShortcut = 'Ctrl-S';
else // macOS
  saveShortcut = 'Cmd-S';
this.menu.innerHTML = '&lt;input type="image" id="webotsEditorMenuImage" width="17px" src="' + webots.WwiUrl + '/images/menu.png"&gt;' +
                      '&lt;div id="webotsEditorMenuContent"&gt;' +
                      '&lt;div id="webotsEditorSaveAction" class="webotsEditorMenuContentItem" title="Save current file"&gt;Save&lt;span style="float:right"&gt;&lt;i&gt;&lt;small&gt;' + saveShortcut + '&lt;/small&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;' +
                      '&lt;div id="webotsEditorSaveAllAction" class="webotsEditorMenuContentItem" title="Save all the files"&gt;Save All&lt;/div&gt;' +
                      '&lt;div id="webotsEditorResetAction" class="webotsEditorMenuContentItem" title="Reset current file to the original version"&gt;Reset&lt;/div&gt;' +
                      '&lt;div id="webotsEditorResetAllAction" class="webotsEditorMenuContentItem" title="Reset all the files to the original version"&gt;Reset All&lt;/div&gt;' +
                      '&lt;/div&gt;';
this.panel.appendChild(this.menu);
this.editor.commands.addCommand({
  name: 'save',
  bindKey: {win: 'Ctrl-S', mac: 'Cmd-S'},
  exec: function(editor) {
    that.save(that.currentSession);
  }
});
</t>
<t tx="leo.20210414181059.118">$('#webotsEditorSaveAction').click(function() {
  that.save(that.currentSession);
  hideMenu();
});
</t>
<t tx="leo.20210414181059.119">$('#webotsEditorSaveAllAction').click(function() {
  for (var i = 0; i &lt; that.filenames.length; i++)
    that.save(i);
  hideMenu();
});
</t>
<t tx="leo.20210414181059.12">webots.View.prototype.setTimeout = function(timeout) { // expressed in seconds
  if (timeout &lt; 0) {
    this.timeout = timeout;
    this.deadline = 0;
    return;
  }

  this.timeout = timeout * 1000; // convert to millisecons
  this.deadline = this.timeout;
  if (this.time !== undefined)
    this.deadline += this.time;
};

</t>
<t tx="leo.20210414181059.120">$('#webotsEditorResetAction').click(function() {
  openResetConfirmDialog(false);
});
</t>
<t tx="leo.20210414181059.121">$('#webotsEditorResetAllAction').click(function() {
  openResetConfirmDialog(true);
});
</t>
<t tx="leo.20210414181059.122">$('#webotsEditorMenuImage').click(function() {
  if ($('#webotsEditorMenu').hasClass('pressed'))
    $('#webotsEditorMenu').removeClass('pressed');
  else
    $('#webotsEditorMenu').addClass('pressed');
});
</t>
<t tx="leo.20210414181059.123">$('#webotsEditorMenu').focusout(function() {
  // let the time to handle the menu actions if needed
  window.setTimeout(function() {
    if ($('.webotsEditorMenuContentItem:hover').length &gt; 0)
      return;
    if ($('#webotsEditorMenu').hasClass('pressed'))
      $('#webotsEditorMenu').removeClass('pressed');
  }, 100);
});
</t>
<t tx="leo.20210414181059.124"></t>
<t tx="leo.20210414181059.125">webots.Editor.prototype.hasUnsavedChanges = function() {
  for (var i = 0; i &lt; this.filenames.length; i++) {
    if ($('#filename-' + i).html().endsWith('*'))
      return true;
  }
  return false;
};

</t>
<t tx="leo.20210414181059.126">webots.Editor.prototype.storeUserFile = function(i) {
  var formData = new FormData();
  formData.append('dirname', this.view.server.project + '/controllers/' + this.dirname);
  formData.append('filename', this.filenames[i]);
  formData.append('content', this.sessions[i].getValue());
  $.ajax({
    url: '/ajax/upload-file.php',
    type: 'POST',
    data: formData,
    processData: false,
    contentType: false,
    success: function(data) {
      if (data !== 'OK')
        webots.alert('File saving error', data);
    }
  });
};

</t>
<t tx="leo.20210414181059.127">webots.Editor.prototype.upload = function(i) { // upload to the simulation server
  this.view.stream.socket.send('set controller:' +
    this.dirname + '/' +
    this.filenames[i] + ':' +
    this.sessions[i].getLength() + '\n' +
    this.sessions[i].getValue());
  this.needToUploadFiles[i] = false;
};

</t>
<t tx="leo.20210414181059.128">webots.Editor.prototype.save = function(i) { // save to the web site
  if ($('#filename-' + i).html().endsWith('*')) { // file was modified
    $('#filename-' + i).html(this.filenames[i]);
    this.needToUploadFiles[i] = true;
    if (webots.User1Id &amp;&amp; webots.User1Authentication) // user logged in
      this.storeUserFile(i);
    else
      this.view.unloggedFileModified = true;

    if (this.view.time === 0)
      this.upload(i);
    else {
      if (!this.statusMessage) {
        this.statusMessage = document.createElement('div');
        this.statusMessage.id = 'webotsEditorStatusMessage';
        this.statusMessage.className = 'webotsEditorStatusMessage';
        this.statusMessage.innerHTML = '&lt;font size="2"&gt;Reset the simulation to apply the changes.&lt;/font&gt;';
      }
      this.panel.appendChild(this.statusMessage);
      setTimeout(this.hideResetMessage, 1500);
    }
  }
};

</t>
<t tx="leo.20210414181059.129">webots.Editor.prototype.hideResetMessage = function() {
  $('#webotsEditorStatusMessage').remove();
};

</t>
<t tx="leo.20210414181059.13">webots.View.prototype.setWebotsDocUrl = function(url) {
  this.webotsDocUrl = url;
};

</t>
<t tx="leo.20210414181059.130">webots.Editor.prototype.textChange = function(index) {
  if (!$('#filename-' + index).html().endsWith('*') &amp;&amp; this.editor.curOp &amp;&amp; this.editor.curOp.command.name) { // user change
    $('#filename-' + index).html(this.filenames[index] + '*');
  }
};

</t>
<t tx="leo.20210414181059.131">webots.Editor.prototype.aceMode = function(filename) {
  if (filename.toLowerCase() === 'makefile')
    return 'ace/mode/makefile';
  var extension = filename.split('.').pop().toLowerCase();
  if (extension === 'py')
    return 'ace/mode/python';
  if (extension === 'c' || extension === 'cpp' || extension === 'c++' || extension === 'cxx' || extension === 'cc' ||
      extension === 'h' || extension === 'hpp' || extension === 'h++' || extension === 'hxx' || extension === 'hh')
    return 'ace/mode/c_cpp';
  if (extension === 'java')
    return 'ace/mode/java';
  if (extension === 'm')
    return 'ace/mode/matlab';
  if (extension === 'json')
    return 'ace/mode/json';
  if (extension === 'xml')
    return 'ace/mode/xml';
  if (extension === 'yaml')
    return 'ace/mode/yaml';
  if (extension === 'ini')
    return 'ace/mode/ini';
  if (extension === 'html')
    return 'ace/mode/html';
  if (extension === 'js')
    return 'ace/mode/javascript';
  if (extension === 'css')
    return 'ace/mode/css';
  return 'ace/mode/text';
};

</t>
<t tx="leo.20210414181059.132">webots.Editor.prototype.addFile = function(filename, content) {
  var index = this.filenames.indexOf(filename);
  if (index &gt;= 0) {
    this.needToUploadFiles[index] = false; // just received from the simulation server
    this.sessions[index].setValue(content);
    if ($('#filename-' + index).html().endsWith('*'))
      $('#filename-' + index).html(filename);
    if (webots.User1Authentication &amp;&amp; webots.User1Id)
      this.storeUserFile(index);
    return;
  }

  index = this.filenames.length;
  this.filenames.push(filename);
  this.needToUploadFiles[index] = false;
  if (index === 0) {
    this.sessions[index].setMode(this.aceMode(filename));
    this.sessions[index].setValue(content);
    $('#webotsEditorMenu').show();
    $('#webotsEditorTabs').show();
  } else
    this.sessions.push(ace.createEditSession(content, this.aceMode(filename)));
  var that = this;
  this.sessions[index].on('change', function(e) { that.textChange(index); });
  $('div#webotsEditorTabs ul').append('&lt;li id="file-' + index + '"&gt;&lt;a href="#webotsEditorTab" id="filename-' + index + '"&gt;' + filename + '&lt;/a&gt;&lt;/li&gt;');
  $('div#webotsEditorTabs').tabs('refresh');
  if (index === 0)
    $('div#webotsEditorTabs').tabs('option', 'active', index);
};

</t>
<t tx="leo.20210414181059.133">webots.Editor.prototype.closeAllTabs = function() {
  this.editor.setSession(ace.createEditSession('', ''));
  this.filenames = [];
  this.needToUploadFiles = [];
  this.sessions = [];
  this.sessions[0] = this.editor.getSession();
  this.currentSession = 0;
  $('div#webotsEditorTabs ul').empty();
  $('#webotsEditorMenu').hide();
  $('#webotsEditorTabs').hide();
};

</t>
<t tx="leo.20210414181059.134">webots.Console = function(parent, mobile) {
  function closeConsole() {
    $('#consoleButton').removeClass('toolBarButtonActive');
  }
  this.panel = document.createElement('div');
  this.panel.id = 'webotsConsole';
  this.panel.className = 'webotsConsole';
  parent.appendChild(this.panel);
  var clampedSize = webotsClampDialogSize({left: 0, top: 0, width: 600, height: 400});
  var params = {
    title: 'Console',
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    width: clampedSize.width,
    height: clampedSize.height,
    autoOpen: false,
    appendTo: parent,
    close: closeConsole,
    open: webotsOpenDialog
  };
  if (mobile)
    webotsAddMobileDialogAttributes(params, this.panel);
  $(this.panel).dialog(params).dialogExtend({maximizable: mobile});
};

</t>
<t tx="leo.20210414181059.135"></t>
<t tx="leo.20210414181059.136">webots.Console.prototype.scrollDown = function() {
  if (this.panel)
    this.panel.scrollTop = this.panel.scrollHeight;
};

</t>
<t tx="leo.20210414181059.137">webots.Console.prototype.clear = function() {
  if (this.panel) {
    while (this.panel.firstChild)
      this.panel.removeChild(this.panel.firstChild);
  } else
    console.clear();
};

</t>
<t tx="leo.20210414181059.138">webots.Console.prototype.log = function(message, type) {
  var para = document.createElement('p');
  var style = 'margin:0;';
  var title = '';
  switch (type) {
    case 0:
      style += 'color:Blue;';
      title = 'Webots stdout';
      break;
    case 1:
      style += 'color:Red;';
      title = 'Webots stderr';
      break;
    case 2:
      style += 'color:Gray;';
      title = 'info';
      break;
    case 3:
      style += 'color:Salmon;';
      title = 'error';
      break;
  }
  if (this.panel) {
    para.style.cssText = style;
    para.title = title + ' (' + hourString() + ')';
    var t = document.createTextNode(message);
    para.appendChild(t);
    this.panel.appendChild(para);
    this.scrollDown();
  } else
    console.log('%c' + message, style);
  function hourString() {
    var d = new Date();
    return d.getHours() + ':' +
         ((d.getMinutes() &lt; 10) ? '0' : '') + d.getMinutes() + ':' +
         ((d.getSeconds() &lt; 10) ? '0' : '') + d.getSeconds();
  }
};

</t>
<t tx="leo.20210414181059.139"></t>
<t tx="leo.20210414181059.14">webots.View.prototype.open = function(url, mode) {
  if (mode === undefined)
    mode = 'x3dom';
  var that = this;
  this.mode = mode;
  this.videoStream = null;
  if (mode === 'video') {
    this.url = url;
    this.video = document.createElement('video');
    this.video.style.background = 'grey';
    this.video.id = 'remoteVideo';
    this.video.class = 'rounded centered';
    this.video.autoplay = 'true';
    this.video.width = 800;
    this.video.height = 600;
    this.view3D.appendChild(this.video);
    initWorld();
    return;
  }
  if (mode !== 'x3dom') {
    console.log('Error: webots.View.open: wrong mode argument: ' + mode);
    return;
  }
  if (this.broadcast)
    this.setTimeout(-1);
  if (!this.x3dScene) {
    this.x3dNode = document.createElement('x3d');
    this.x3dNode.className = 'webots3DView';
    this.view3D.appendChild(this.x3dNode);
    var param = document.createElement('param');
    param.name = 'showProgress';
    param.value = false;
    this.x3dNode.appendChild(param);
    this.x3dScene = document.createElement('Scene');
    this.x3dNode.appendChild(this.x3dScene);
  }
  if (this.url === undefined) {
    this.url = url;
    initX3Dom();
  } else {
    this.url = url;
    initWorld();
  }
  this.isWebSocketProtocol = that.url.startsWith('ws://') || that.url.startsWith('wss://');
  @others
};

</t>
<t tx="leo.20210414181059.140">webots.Console.prototype.stdout = function(message) {
  this.log(message, 0);
};

</t>
<t tx="leo.20210414181059.141">webots.Console.prototype.stderr = function(message) {
  this.log(message, 1);
};

</t>
<t tx="leo.20210414181059.142">webots.Console.prototype.info = function(message) {
  this.log(message, 2);
};

</t>
<t tx="leo.20210414181059.143">webots.Console.prototype.error = function(message) {
  this.log(message, 3);
};

</t>
<t tx="leo.20210414181059.144">webots.HelpWindow = function(parent, webotsDocUrl, mobile) {
  @others
};

</t>
<t tx="leo.20210414181059.145">function closeConsole() {
  $('#helpButton').removeClass('toolBarButtonActive');
}
</t>
<t tx="leo.20210414181059.146">function finalize() {
  $('#webotsHelpTabs').tabs('refresh');
  $('#webotsHelpTabs').tabs('option', 'active', 0);
  $(that.panel).dialog('open');
}
var that = this;
this.name = name;
this.panel = document.createElement('div');
this.panel.id = 'webotsHelp';
that.panel.style.overflow = 'hidden';
this.panel.className += 'webotsTabContainer';
this.tabs = document.createElement('div');
this.tabs.id = 'webotsHelpTabs';
this.tabs.className += 'webotsTabs';
this.tabsHeader = document.createElement('ul');
this.tabs.appendChild(this.tabsHeader);
this.panel.appendChild(this.tabs);
parent.appendChild(this.panel);
var clampedSize = webotsClampDialogSize({left: 5, top: 5, width: 600, height: 600});
var params = {
  title: 'Help',
  resizeStart: webotsDisablePointerEvents,
  resizeStop: webotsEnablePointerEvents,
  dragStart: webotsDisablePointerEvents,
  dragStop: webotsEnablePointerEvents,
  autoOpen: false,
  appendTo: parent,
  close: closeConsole,
  open: webotsOpenDialog,
  position: {at: 'right-5 top+5', my: 'right top', of: parent},
  width: clampedSize.width,
  height: clampedSize.height
};
if (mobile)
  webotsAddMobileDialogAttributes(params, this.panel);
$(this.panel).dialog(params).dialogExtend({maximizable: mobile});

if (webotsDocUrl) {
  var header = document.createElement('li');
  header.innerHTML = '&lt;a href="#webotsHelpReference"&gt;Webots Reference Manual&lt;/a&gt;';
  that.tabsHeader.appendChild(header);
  var page = document.createElement('div');
  page.id = 'webotsHelpReference';
  page.innerHTML = '&lt;iframe src="' + webotsDocUrl + '"&gt;&lt;/iframe&gt;';
  that.tabs.appendChild(page);
  $('#webotsHelpTabs').tabs();
}

$.ajax({
  url: webots.currentScriptPath() + 'help.php',
  success: function(data) {
    // we need to fix the img src relative URLs
    var html = data.replace(/ src="images/g, ' src="' + webots.currentScriptPath() + '/images');
    var header = document.createElement('li');
    header.innerHTML = '&lt;a href="#webotsHelpGuide"&gt;User Guide&lt;/a&gt;';
    $(that.tabsHeader).prepend(header);
    var page = document.createElement('div');
    page.id = 'webotsHelpGuide';
    page.innerHTML = html;
    if (document.getElementById('webotsHelpReference'))
      $('#webotsHelpReference').before(page);
    else {
      that.tabs.appendChild(page);
      $('#webotsHelpTabs').tabs();
    }
    finalize();
  },
  error: function() {
    finalize();
  }
});
</t>
<t tx="leo.20210414181059.147">webots.RobotWindow = function(parent, name, mobile) {
  this.name = name;
  this.panel = document.createElement('div');
  this.panel.id = name;
  this.panel.className = 'webotsTabContainer';
  parent.appendChild(this.panel);
  var clampedSize = webotsClampDialogSize({left: 5, top: 5, width: 400, height: 400});
  var params = {
    title: 'Robot Window',
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    autoOpen: false,
    appendTo: parent,
    open: webotsOpenDialog,
    position: {at: 'left+5 top+5', my: 'left top', of: parent},
    width: clampedSize.width,
    height: clampedSize.height
  };
  if (mobile)
    webotsAddMobileDialogAttributes(params, this.panel);
  $(this.panel).dialog(params).dialogExtend({maximizable: !mobile});
};

</t>
<t tx="leo.20210414181059.148">webots.RobotWindow.prototype.setProperties = function(properties) {
  $(this.panel).dialog(properties);
};

</t>
<t tx="leo.20210414181059.149">webots.RobotWindow.prototype.geometry = function() {
  var webotsTabs = this.panel.getElementsByClassName('webotsTabs');
  var activeTabIndex = -1;
  if (webotsTabs.length &gt; 0)
    activeTabIndex = $(webotsTabs[0]).tabs('option', 'active');
  return {
    width: $(this.panel).dialog('option', 'width'),
    height: $(this.panel).dialog('option', 'height'),
    position: $(this.panel).dialog('option', 'position'),
    activeTabIndex: activeTabIndex,
    open: this.isOpen()
  };
};

</t>
<t tx="leo.20210414181059.15">function requestQuit() {
  if (that.unloggedFileModified || that.editor.hasUnsavedChanges()) {
    var text;
    if (that.unloggedFileModified || !webots.User1Id)
      text = 'Your changes to the robot controller will be lost because you are not logged in.';
    else
      text = 'Your unsaved changes to the robot controller will be lost.';
    var quitDialog = document.getElementById('quitDialog');
    if (!quitDialog) {
      quitDialog = document.createElement('div');
      quitDialog.id = 'quitDialog';
      $(quitDialog).html(text);
      that.view3D.appendChild(quitDialog);
      $(quitDialog).dialog({
        title: 'Quit the simulation?',
        modal: true,
        resizable: false,
        appendTo: that.view3D,
        open: webotsOpenDialog,
        buttons: {
          'Cancel': function() {
            $(this).dialog('close');
          },
          'Quit': function() {
            $(this).dialog('close');
            quit();
          }
        }
      });
    } else
      $(quitDialog).dialog('open');
    return;
  }
  quit();
}
</t>
<t tx="leo.20210414181059.150">webots.RobotWindow.prototype.restoreGeometry = function(data) {
  $(this.panel).dialog({
    width: data.width,
    height: data.height,
    position: data.position
  });
  var webotsTabs = this.panel.getElementsByClassName('webotsTabs');
  if (data.activeTabIndex &gt;= 0 &amp;&amp; webotsTabs.length &gt; 0)
    $(webotsTabs[0]).tabs('option', 'active', data.activeTabIndex);
};

</t>
<t tx="leo.20210414181059.151">webots.RobotWindow.prototype.destroy = function() {
  this.close();
  this.panel.parentNode.removeChild(this.panel);
  this.panel = null;
};

</t>
<t tx="leo.20210414181059.152">webots.RobotWindow.prototype.setContent = function(content) {
  $(this.panel).html(content);
};

</t>
<t tx="leo.20210414181059.153">webots.RobotWindow.prototype.open = function() {
  $(this.panel).dialog('open');
};

</t>
<t tx="leo.20210414181059.154">webots.RobotWindow.prototype.isOpen = function() {
  return $(this.panel).dialog('isOpen');
};

</t>
<t tx="leo.20210414181059.155">webots.RobotWindow.prototype.close = function() {
  $(this.panel).dialog('close');
};

</t>
<t tx="leo.20210414181059.156">webots.RobotWindow.prototype.send = function(message, robot) {
  webots.currentView.stream.socket.send('robot:' + robot + ':' + message);
  if (webots.currentView.real_timeButton.style.display === 'inline') // if paused, make a simulation step
    webots.currentView.stream.socket.send('step'); // so that the robot controller handles the message
  // FIXME: there seems to be a bug here: after that step, the current time is not incremented in the web interface,
  // this is because the next 'application/json:' is not received, probably because it gets overwritten by the
  // answer to the robot message...
};

</t>
<t tx="leo.20210414181059.157">webots.RobotWindow.prototype.receive = function(message, robot) { // to be overriden
  console.log("Robot window '" + this.name + "' received message from Robot '" + robot + "': " + message);
};

</t>
<t tx="leo.20210414181059.158">webots.window = function(name) {
  var win = webots.currentView.robotWindows[name];
  if (!win)
    console.log("Robot window '" + name + "' not found.");
  return win;
};

</t>
<t tx="leo.20210414181059.159">webots.alert = function(title, message, callback) {
  webots.currentView.ondialogwindow(true);
  var parent = webots.currentView.view3D;
  var panel = document.createElement('div');
  panel.id = 'webotsAlert';
  panel.innerHTML = message;
  parent.appendChild(panel);
  $('#webotsAlert').dialog({
    title: title,
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    appendTo: parent,
    open: webotsOpenDialog,
    modal: true,
    width: 400, // enough room to display the social network buttons in a line
    buttons: {Ok: function() { $(this).dialog('close'); }},
    close: function() {
      if (callback !== undefined)
        callback();
      $(this).dialog('destroy').remove();
      webots.currentView.ondialogwindow(false);
    }
  });
};

</t>
<t tx="leo.20210414181059.16">function quit() {
  if (that.broadcast)
    return;
  $('#webotsProgressMessage').html('Bye bye...');
  $('#webotsProgress').show();
  that.quitting = true;
  that.onquit();
}
</t>
<t tx="leo.20210414181059.160">webots.confirm = function(title, message, callback) {
  webots.currentView.ondialogwindow(true);
  var parent = webots.currentView.view3D;
  var panel = document.createElement('div');
  panel.id = 'webotsConfirm';
  panel.innerHTML = message;
  parent.appendChild(panel);
  $('#webotsConfirm').dialog({
    title: title,
    resizeStart: webotsDisablePointerEvents,
    resizeStop: webotsEnablePointerEvents,
    dragStart: webotsDisablePointerEvents,
    dragStop: webotsEnablePointerEvents,
    appendTo: parent,
    open: webotsOpenDialog,
    modal: true,
    width: 400, // enough room to display the social network buttons in a line
    buttons: {Ok: function() { $(this).dialog('close'); callback(); }, Cancel: function() { $(this).dialog('close'); }},
    close: function() { $(this).dialog('destroy').remove(); webots.currentView.ondialogwindow(false); }});
};

</t>
<t tx="leo.20210414181059.161">webots.parseMillisecondsIntoReadableTime = function(milliseconds) {
  var hours = (milliseconds + 0.9) / (1000 * 60 * 60);
  var absoluteHours = Math.floor(hours);
  var h = absoluteHours &gt; 9 ? absoluteHours : '0' + absoluteHours;
  var minutes = (hours - absoluteHours) * 60;
  var absoluteMinutes = Math.floor(minutes);
  var m = absoluteMinutes &gt; 9 ? absoluteMinutes : '0' + absoluteMinutes;
  var seconds = (minutes - absoluteMinutes) * 60;
  var absoluteSeconds = Math.floor(seconds);
  var s = absoluteSeconds &gt; 9 ? absoluteSeconds : '0' + absoluteSeconds;
  var ms = Math.floor((seconds - absoluteSeconds) * 1000);
  if (ms &lt; 10)
    ms = '00' + ms;
  else if (ms &lt; 100)
    ms = '0' + ms;
  return h + ':' + m + ':' + s + ':' + ms;
};

// get the directory path to the currently executing script file
</t>
<t tx="leo.20210414181059.162">// for example: https://cyberbotics.com/wwi/8.6/
webots.currentScriptPath = function() {
  var scripts = document.querySelectorAll('script[src]');
  for (var i = 0; i &lt; scripts.length; i++) {
    var src = scripts[i].src;
    var index = src.indexOf('?');
    if (index &gt; 0)
      src = src.substring(0, index); // remove query string
    if (!src.endsWith('webots.js'))
      continue;
    index = src.lastIndexOf('/');
    return src.substring(0, index + 1);
  }
  return '';
};

// add startsWith() and endsWith() functions to the String prototype
if (typeof String.prototype.startsWith !== 'function') {
</t>
<t tx="leo.20210414181059.163">  String.prototype.startsWith = function(prefix) {
    return this.slice(0, prefix.length) === prefix;
  };
}

if (typeof String.prototype.endsWith !== 'function') {
</t>
<t tx="leo.20210414181059.164">  String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };
}
</t>
<t tx="leo.20210414181059.17">function reset() {
  if (that.broadcast)
    return;
  that.time = 0; // reset time to correctly compute the initial deadline
  $('#webotsProgressMessage').html('Restarting simulation...');
  $('#webotsProgress').show();
  that.runOnLoad = that.pauseButton.style.display === 'inline';
  pause();
  for (var i = 0; i &lt; that.editor.filenames.length; i++) {
    that.editor.save(i);
    if (that.editor.needToUploadFiles[i])
      that.editor.upload(i);
  }
  that.onrobotwindowsdestroy();
  if (that.timeout &gt;= 0) {
    that.deadline = that.timeout;
    $('#webotsTimeout').html(webots.parseMillisecondsIntoReadableTime(that.deadline));
  }
  enableToolBarButtons(false);
  that.stream.socket.send('reset');
}
</t>
<t tx="leo.20210414181059.18">function pause() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display', 'none');
  that.stream.socket.send('pause');
}
</t>
<t tx="leo.20210414181059.19">function realTime() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display', 'none');
  that.stream.socket.send('real-time:' + that.timeout);
  that.pauseButton.style.display = 'inline';
  that.real_timeButton.style.display = 'none';
}
</t>
<t tx="leo.20210414181059.2">this.onerror = function(text) {
  console.log('%c' + text, 'color:black');
  that.onrobotwindowsdestroy();
};
</t>
<t tx="leo.20210414181059.20">function step() {
  if (that.broadcast)
    return;
  $('#contextMenu').css('display', 'none');
  that.pauseButton.style.display = 'none';
  that.real_timeButton.style.display = 'inline';
  that.stream.socket.send('step');
}
</t>
<t tx="leo.20210414181059.21">function requestFullscreen() {
  $('#contextMenu').css('display', 'none');
  var elem = that.view3D;
  if (elem.requestFullscreen)
    elem.requestFullscreen();
  else if (elem.msRequestFullscreen)
    elem.msRequestFullscreen();
  else if (elem.mozRequestFullScreen)
    elem.mozRequestFullScreen();
  else if (elem.webkitRequestFullscreen)
    elem.webkitRequestFullscreen();
}
</t>
<t tx="leo.20210414181059.22">function exitFullscreen() {
  $('#contextMenu').css('display', 'none');
  if (document.exitFullscreen)
    document.exitFullscreen();
  else if (document.msExitFullscreen)
    document.msExitFullscreen();
  else if (document.mozCancelFullScreen)
    document.mozCancelFullScreen();
  else if (document.webkitExitFullscreen)
    document.webkitExitFullscreen();
}
</t>
<t tx="leo.20210414181059.23">function fullscreenchange(event) {
  var element = document.fullScreenElement || document.mozFullScreenElement || document.webkitFullScreenElement || document.msFullScreenElement || document.webkitCurrentFullScreenElement;
  if (element != null) {
    that.fullscreenButton.style.display = 'none';
    that.exit_fullscreenButton.style.display = 'inline';
  } else {
    that.fullscreenButton.style.display = 'inline';
    that.exit_fullscreenButton.style.display = 'none';
  }
}
</t>
<t tx="leo.20210414181059.24">function toolBarButton(name, tooltip) {
  var buttonName = name + 'Button';
  that[buttonName] = document.createElement('button');
  that[buttonName].id = buttonName;
  that[buttonName].className = 'toolBarButton';
  that[buttonName].title = tooltip;
  that[buttonName].style.backgroundImage = 'url(' + webots.WwiUrl + 'images/' + name + '.png)';
  return that[buttonName];
}
</t>
<t tx="leo.20210414181059.25">function toggleConsole() {
  $('#contextMenu').css('display', 'none');
  if ($('#webotsConsole').is(':visible')) {
    $('#webotsConsole').dialog('close');
    that.consoleButton.classList.remove('toolBarButtonActive');
  } else {
    $('#webotsConsole').dialog('open');
    that.consoleButton.classList.add('toolBarButtonActive');
  }
}
</t>
<t tx="leo.20210414181059.26">function toggleHelp() {
  $('#contextMenu').css('display', 'none');
  if (!that.helpWindow) {
    if (!that.broadcast &amp;&amp; that.webotsDocUrl)
      var webotsDocUrl = that.webotsDocUrl;
    that.helpWindow = new webots.HelpWindow(that.view3D, webotsDocUrl, that.mobileDevice);
    that.helpButton.classList.add('toolBarButtonActive');
  } else if ($('#webotsHelp').is(':visible')) {
    $('#webotsHelp').dialog('close');
    that.helpButton.classList.remove('toolBarButtonActive');
  } else {
    $('#webotsHelp').dialog('open');
    that.helpButton.classList.add('toolBarButtonActive');
  }
}
</t>
<t tx="leo.20210414181059.27">function enableToolBarButtons(enabled) {
  var buttons = [that.infoButton, that.resetButton, that.stepButton, that.real_timeButton, that.pauseButton, that.consoleButton];
  for (var i in buttons) {
    if (buttons[i]) {
      if ((!that.broadcast || buttons[i] === that.consoleButton) &amp;&amp; enabled) {
        buttons[i].disabled = false;
        buttons[i].classList.remove('toolBarButtonDisabled');
      } else {
        buttons[i].disabled = true;
        buttons[i].classList.add('toolBarButtonDisabled');
      }
    }
  }
}
</t>
<t tx="leo.20210414181059.28">function initWorld() {
  // override the original x3dom function to workaround a bug with USE/DEF nodes
  @others
}

</t>
<t tx="leo.20210414181059.29">x3dom.Texture.prototype.update = function() {
  if (x3dom.isa(this.node, x3dom.nodeTypes.Text))
    this.updateText();
  else
    this.updateTexture();
  // x3dom bug: do not call validateGLObject because it somehow prevents USE Apperance update (bug #5117)
  // this.node.validateGLObject();
};

// redirect the X3Dom log entirely to the JS console
if (that.mode === 'x3dom') {
  if (this.debug) {
</t>
<t tx="leo.20210414181059.3">this.onstdout = function(text) {
  console.log('%c' + text, 'color:blue');
};
</t>
<t tx="leo.20210414181059.30">    x3dom.debug.doLog = function(msg, type) {
      console.log(type + ': ' + msg);
    };
  }
  x3dom.runtime.ready = addX3domMouseNavigation;
}
if (that.isWebSocketProtocol) {
  that.progress = document.createElement('div');
  that.progress.id = 'webotsProgress';
  that.progress.innerHTML = "&lt;div&gt;&lt;img src='" + webots.WwiUrl + "images/load_animation.gif'&gt;" +
                            "&lt;/div&gt;&lt;div id='webotsProgressMessage'&gt;Initializing...&lt;/div&gt;";
  that.view3D.appendChild(that.progress);
  that.toolBar = document.createElement('div');
  that.toolBar.id = 'toolBar';
  that.toolBar.left = document.createElement('div');
  that.toolBar.left.className = 'toolBarLeft';
  that.toolBar.left.appendChild(toolBarButton('quit', 'Quit the simulation'));
  that.quitButton.onclick = requestQuit;
  that.toolBar.left.appendChild(toolBarButton('info', 'Open the information window'));
  that.infoButton.onclick = toggleInfo;
  that.toolBar.left.appendChild(toolBarButton('reset', 'Save controllers and reset the simulation'));
  that.resetButton.onclick = reset;
  that.toolBar.left.appendChild(toolBarButton('step', 'Perform one simulation step'));
  that.stepButton.onclick = step;
  that.toolBar.left.appendChild(toolBarButton('real_time', 'Run the simulation in real time'));
  that.real_timeButton.onclick = realTime;
  that.toolBar.left.appendChild(toolBarButton('pause', 'Pause the simulation'));
  that.pauseButton.onclick = pause;
  that.pauseButton.style.display = 'none';
  var div = document.createElement('div');
  div.className = 'webotsTime';
  var clock = document.createElement('span');
  clock.id = 'webotsClock';
  clock.title = 'Current simulation time';
  clock.innerHTML = webots.parseMillisecondsIntoReadableTime(0);
  var timeout = document.createElement('span');
  timeout.id = 'webotsTimeout';
  timeout.title = 'Simulation time out';
  timeout.innerHTML = webots.parseMillisecondsIntoReadableTime(that.deadline);
  div.appendChild(clock);
  div.appendChild(document.createElement('br'));
  div.appendChild(timeout);
  that.toolBar.left.appendChild(div);
  that.toolBar.left.appendChild(toolBarButton('console', 'Open the console window'));
  that.consoleButton.onclick = toggleConsole;
  that.toolBar.right = document.createElement('div');
  that.toolBar.right.className = 'toolBarRight';
  that.toolBar.right.appendChild(toolBarButton('help', 'Get help on the simulator'));
  that.helpButton.onclick = toggleHelp;
  if (that.fullscreenEnabled) {
    that.toolBar.right.appendChild(toolBarButton('exit_fullscreen', 'Exit fullscreen'));
    that.exit_fullscreenButton.onclick = exitFullscreen;
    that.exit_fullscreenButton.style.display = 'none';
    that.toolBar.right.appendChild(toolBarButton('fullscreen', 'Enter fullscreen'));
    that.fullscreenButton.onclick = requestFullscreen;
  }
  that.toolBar.appendChild(that.toolBar.left);
  that.toolBar.appendChild(that.toolBar.right);
  that.view3D.appendChild(that.toolBar);
  enableToolBarButtons(false);
  if (that.broadcast) {
    that.quitButton.disabled = true;
    that.quitButton.classList.add('toolBarButtonDisabled');
    $('#contextMenuRobotWindowDiv').addClass('ui-state-disabled');
    $('#contextMenuEditControllerDiv').addClass('ui-state-disabled');
  }
  document.addEventListener('fullscreenchange', fullscreenchange);
  document.addEventListener('webkitfullscreenchange', fullscreenchange);
  document.addEventListener('mozfullscreenchange', fullscreenchange);
  document.addEventListener('MSFullscreenChange', fullscreenchange);
  if (that.url.endsWith('.wbt')) { // url expected form: "ws://localhost:80/simple/worlds/simple.wbt"
    var callback;
    if (that.mode === 'video')
      callback = videoFinalize;
    else
      callback = x3domFinalize;
    that.server = new webots.Server(that.url, that, callback);
  } else // url expected form: "ws://cyberbotics2.cyberbotics.com:80"
    that.stream = new webots.Stream(that.url, that, x3domFinalize);
} else // assuming it's an URL to a .x3d file
  initX3dFile();
</t>
<t tx="leo.20210414181059.31">function toggleInfo() {
  that.toggleInfo();
}

</t>
<t tx="leo.20210414181059.32">function initX3Dom() { // load x3dom.css, x3dom-full.js and calls initWorld
  var head = document.getElementsByTagName('head')[0];
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = 'https://www.cyberbotics.com/x3dom/dev_13062018/x3dom.css';
  link.media = 'all';
  head.appendChild(link);
  // source http://stackoverflow.com/questions/950087/include-a-javascript-file-in-another-javascript-file
  var script = document.createElement('script');
  script.src = 'https://www.cyberbotics.com/x3dom/dev_13062018/x3dom-full.js';
  script.onload = initWorld;
  script.onerror = function() {
    that.onerror('Error when loading the X3DOM library');
  };
  head.appendChild(script); // fire the loading
}

</t>
<t tx="leo.20210414181059.33"></t>
<t tx="leo.20210414181059.34">function initX3dFile() {
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.open('GET', that.url, true);
  xmlhttp.overrideMimeType('text/xml');
  xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200) {
      var scene = xmlhttp.responseText.substring(xmlhttp.responseText.indexOf('&lt;Scene&gt;') + 8, xmlhttp.responseText.lastIndexOf('&lt;/Scene&gt;'));
      $(that.x3dScene).append(scene);
      x3domFinalize();
    }
  };
  xmlhttp.send();
}

</t>
<t tx="leo.20210414181059.35"></t>
<t tx="leo.20210414181059.36">function x3domFinalize() {
  $('#webotsProgressMessage').html('Loading HTML and Javascript files...');
  if (that.followedObject == null || that.broadcast) {
    var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
    that.initialViewpointPosition = viewpoint.getAttribute('position');
    that.initialViewpointOrientation = viewpoint.getAttribute('orientation');
    var viewpointFollowSmoothness = viewpoint.getAttribute('followSmoothness');
    if (viewpointFollowSmoothness !== null)
      that.setViewpointMass(viewpointFollowSmoothness);
    var viewpointFollowedId = viewpoint.getAttribute('followedId');
    if (viewpointFollowedId != null) {
      that.followedObject = viewpointFollowedId;
      that.follow(viewpointFollowedId);
    } else
      that.followedObject = 'none';
  } else
    // reset follow parameters
    that.follow(that.followedObject);

  if (!that.isWebSocketProtocol) { // skip robot windows initialization
    if (that.animation != null)
      that.animation.init(loadFinalize);
    else
      loadFinalize();
    that.onresize();
    return;
  }

  function loadRobotWindow(node) {
    var windowName = node.getAttribute('window');
    that.robotWindowNames[node.getAttribute('name')] = windowName;
    var win = new webots.RobotWindow(that.view3D, windowName, that.mobileDevice);
    that.robotWindows[windowName] = win;
    // init robot windows dialogs
    @others
  }

  var worldInfo = that.x3dScene.getElementsByTagName('WorldInfo')[0];
  var infoWindowName = worldInfo.getAttribute('window');
  var pendingRequestsCount = 1; // start from 1 so that it can be 0 only after the loop is completed and all the nodes are checked
  var nodes = that.x3dScene.childNodes;
  for (var i = 0; i &lt; nodes.length; i++) {
    if (nodes[i].nodeType !== 1 || nodes[i].nodeName.toUpperCase() !== 'TRANSFORM' || !nodes[i].hasAttribute('window') || !nodes[i].hasAttribute('name'))
      continue;
    loadRobotWindow(nodes[i]);
  }
  pendingRequestsCount--; // notify that loop is completed
  if (pendingRequestsCount === 0)
    // if no pending requests execute loadFinalize
    // otherwise it will be executed when the last request will be handled
    loadFinalize();
}

</t>
<t tx="leo.20210414181059.37"></t>
<t tx="leo.20210414181059.38">function closeInfoWindow() {
  $('#infoButton').removeClass('toolBarButtonActive');
}
if (windowName === infoWindowName) {
  var user;
  if (webots.User1Id) {
    user = ' [' + webots.User1Name;
    if (webots.User2Id)
      user += '/' + webots.User2Name;
    user += ']';
  } else
    user = '';
  win.setProperties({title: worldInfo.getAttribute('title') + user, close: closeInfoWindow});
  that.infoWindow = win;
} else
  win.setProperties({title: 'Robot: ' + node.getAttribute('name')});
pendingRequestsCount++;
</t>
<t tx="leo.20210414181059.39">$.get('window/' + windowName + '/' + windowName + '.html', function(data) {
  // we need to fix the img src relative URLs
  var d = data.replace(/ src='/g, ' src=\'window/' + windowName + '/').replace(/ src="/g, ' src="window/' + windowName + '/');
  win.setContent(d);
  MathJax.Hub.Queue(['Typeset', MathJax.Hub, win[0]]);
  $.get('window/' + windowName + '/' + windowName + '.js', function(data) {
    eval(data);
    pendingRequestsCount--;
    if (pendingRequestsCount === 0)
      loadFinalize();
  }).fail(function() {
    pendingRequestsCount--;
    if (pendingRequestsCount === 0)
      loadFinalize();
  });
}).fail(function() {
  pendingRequestsCount--;
  if (pendingRequestsCount === 0)
    loadFinalize();
});
</t>
<t tx="leo.20210414181059.4">this.onstderr = function(text) {
  console.log('%c' + text, 'color:red');
};
</t>
<t tx="leo.20210414181059.40"></t>
<t tx="leo.20210414181059.41">function loadFinalize() {
  $('#webotsProgress').hide();
  enableToolBarButtons(true);

  if (that.onready)
    that.onready();

  // restore robot windows
  if (that.robotWindowsGeometries) { // on reset
    for (var win in that.robotWindows) {
      if (win in that.robotWindowsGeometries) {
        that.robotWindows[win].restoreGeometry(that.robotWindowsGeometries[win]);
        if (that.robotWindowsGeometries[win].open) {
          if (that.robotWindows[win] === that.infoWindow)
            that.toggleInfo();
          else
            that.robotWindows[win].open();
        }
      }
    }
  } else if (that.infoWindow &amp;&amp; !that.broadcast) // at first load
    that.toggleInfo();
  that.viewpointLastUpdate = undefined;

  if (that.runOnLoad)
    realTime();
}

</t>
<t tx="leo.20210414181059.42">function rotateViewpoint(viewpoint, params) {
  var halfYawAngle = -0.005 * params.dx;
  var halfPitchAngle = -0.005 * params.dy;
  if (that.mouseState.pickPosition == null) {
    halfYawAngle /= -8;
    halfPitchAngle /= -8;
  }
  var sinusYaw = Math.sin(halfYawAngle);
  var sinusPitch = Math.sin(halfPitchAngle);
  var tx = (1 - params.c) * params.vo.x;
  var pitch = new x3dom.fields.SFVec3f(tx * params.vo.x + params.c, tx * params.vo.y + params.s * params.vo.z, tx * params.vo.z - params.s * params.vo.y);
  var pitchRotation = new x3dom.fields.Quaternion(sinusPitch * pitch.x, sinusPitch * pitch.y, sinusPitch * pitch.z, Math.cos(halfPitchAngle));
  var worldUp = new x3dom.fields.SFVec3f(0, 1, 0);
  var yawRotation = new x3dom.fields.Quaternion(sinusYaw * worldUp.x, sinusYaw * worldUp.y, sinusYaw * worldUp.z, Math.cos(halfYawAngle));
  var deltaRotation = yawRotation.multiply(pitchRotation);
  if (that.mouseState.pickPosition) {
    var currentPosition = deltaRotation.toMatrix().multMatrixVec(params.vp.subtract(that.mouseState.pickPosition)).add(that.mouseState.pickPosition);
    viewpoint.setAttribute('position', currentPosition.toString());
  }
  var voq = x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(params.vo.x, params.vo.y, params.vo.z), params.vo.w);
  var currentOrientation = deltaRotation.multiply(voq);
  var aa = currentOrientation.toAxisAngle();
  viewpoint.setAttribute('orientation', aa[0].toString() + ' ' + aa[1]);
}

</t>
<t tx="leo.20210414181059.43">function translateViewpoint(viewpoint, params) {
  var targetRight = -params.distanceToPickPosition * params.scaleFactor * params.dx;
  var targetUp = params.distanceToPickPosition * params.scaleFactor * params.dy;
  var tx = (1 - params.c) * params.vo.x;
  var pitch = new x3dom.fields.SFVec3f(tx * params.vo.x + params.c, tx * params.vo.y + params.s * params.vo.z, tx * params.vo.z - params.s * params.vo.y);
  var ty = (1 - params.c) * params.vo.y;
  var yaw = new x3dom.fields.SFVec3f(ty * params.vo.x - params.s * params.vo.z, ty * params.vo.y + params.c, ty * params.vo.z + params.s * params.vo.x);
  var target = params.vp.add(pitch.multiply(targetRight).add(yaw.multiply(targetUp)));
  viewpoint.setAttribute('position', target.toString());
}

</t>
<t tx="leo.20210414181059.44">function zoomAndTiltViewpoint(viewpoint, params) {
  var tz = (1 - params.c) * params.vo.z;
  var roll = new x3dom.fields.SFVec3f(tz * params.vo.x + params.s * params.vo.y, tz * params.vo.y - params.s * params.vo.x, tz * params.vo.z + params.c);
  var target = params.vp.add(roll.multiply(params.zoomScale));
  viewpoint.setAttribute('position', target.toString());
  var zRotation = x3dom.fields.Quaternion.axisAngle(roll, params.tiltAngle);
  var voq = x3dom.fields.Quaternion.axisAngle(new x3dom.fields.SFVec3f(params.vo.x, params.vo.y, params.vo.z), params.vo.w);
  var aa = zRotation.multiply(voq).toAxisAngle();
  viewpoint.setAttribute('orientation', aa[0].toString() + ' ' + aa[1]);
}

</t>
<t tx="leo.20210414181059.45">function initMouseMove(event) {
  that.mouseState.x = event.clientX;
  that.mouseState.y = event.clientY;
  that.mouseState.initialX = null;
  that.mouseState.initialY = null;
  that.mouseState.moved = false;
  that.mouseState.initialTimeStamp = Date.now();
  that.mouseState.longClick = false;
  var mousePosition = that.x3dNode.runtime.mousePosition(event);
  var shootRay = that.x3dNode.runtime.shootRay(mousePosition[0], mousePosition[1]);
  that.mouseState.pickPosition = shootRay.pickPosition;
  if ($('#contextMenu').css('display') === 'block') {
    $('#contextMenu').css('display', 'none');
    that.contextMenu = true;
  } else
    that.contextMenu = false;
}

</t>
<t tx="leo.20210414181059.46">function clearMouseMove() {
  if (that.mouseState.mobileDevice)
    that.mouseState.longClick = Date.now() - that.mouseState.initialTimeStamp &gt;= 100;
  else
    that.mouseState.longClick = Date.now() - that.mouseState.initialTimeStamp &gt;= 1000;
  if (that.mouseState.moved === false) {
    that.previousSelection = that.selection;
    unselect();
  } else
    that.previousSelection = null;
  that.mouseState.previousMouseDown = that.mouseState.mouseDown;
  that.mouseState.mouseDown = 0;
  that.mouseState.initialTimeStamp = null;
  that.mouseState.initialX = null;
  that.mouseState.initialY = null;
}

</t>
<t tx="leo.20210414181059.47">function addX3domMouseNavigation() {
  if (that.mobileDevice) {
    @others
}
</t>
<t tx="leo.20210414181059.48">that.x3dNode.addEventListener('touchmove', function(event) {
  if (!that.enableNavigation || event.targetTouches.length === 0 || event.targetTouches.length &gt; 2)
    return;
  if (that.mouseState.initialTimeStamp === null)
    // prevent applying mouse move action before drag initialization in mousedrag event
    return;
  if ((that.mouseState.mouseDown !== 2) !== (event.targetTouches.length &gt; 1))
    // gesture single/multi touch changed after initialization
    return;

  var touch = event.targetTouches['0'];

  var params = {};
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  params.vp = x3dom.fields.SFVec3f.parse(viewpoint.getAttribute('position'));
  params.vo = x3dom.fields.SFVec4f.parse(viewpoint.getAttribute('orientation'));
  params.c = Math.cos(params.vo.w);
  params.s = Math.sin(params.vo.w);
  params.scaleFactor = 1.90 * Math.tan(that.viewpointFieldOfView / 2);
  var viewHeight = parseFloat($(that.x3dNode).css('height').slice(0, -2));
  var viewWidth = parseFloat($(that.x3dNode).css('width').slice(0, -2));
  params.scaleFactor /= Math.max(viewHeight, viewWidth);

  if (that.mouseState.pickPosition == null)
    params.distanceToPickPosition = params.vp.length();
  else
    params.distanceToPickPosition = params.vp.subtract(that.mouseState.pickPosition).length() - 0.05; // FIXME this is different from webots.
  if (params.distanceToPickPosition &lt; 0.001) // 1 mm
    params.distanceToPickPosition = 0.001;
  var x = Math.round(touch.clientX); // discard decimal values returned on android
  var y = Math.round(touch.clientY);

  if (that.mouseState.mouseDown === 2) { // translation
    params.dx = x - that.mouseState.x;
    params.dy = y - that.mouseState.y;
    translateViewpoint(viewpoint, params);

    // on small phone screens (Android) this is needed to correctly detect clicks and longClicks
    if (that.mouseState.initialX == null &amp;&amp; that.mouseState.initialY == null) {
      that.mouseState.initialX = Math.round(that.mouseState.x);
      that.mouseState.initialY = Math.round(that.mouseState.y);
    }
    if (Math.abs(params.dx) &lt; 2 &amp;&amp; Math.abs(params.dy) &lt; 2 &amp;&amp;
        Math.abs(that.mouseState.initialX - x) &lt; 5 &amp;&amp; Math.abs(that.mouseState.initialY - y) &lt; 5)
      that.mouseState.moved = false;
    else
      that.mouseState.moved = true;
  } else {
    var touch1 = event.targetTouches['1'];
    var x1 = Math.round(touch1.clientX);
    var y1 = Math.round(touch1.clientY);
    var distanceX = x - x1;
    var distanceY = y - y1;
    var newTouchDistance = distanceX * distanceX + distanceY * distanceY;
    var pinchSize = that.mouseState.touchDistance - newTouchDistance;

    var moveX1 = x - that.mouseState.x;
    var moveX2 = x1 - that.mouseState.x1;
    var moveY1 = y - that.mouseState.y;
    var moveY2 = y1 - that.mouseState.y1;
    var ratio = window.devicePixelRatio || 1;

    if (Math.abs(pinchSize) &gt; 500 * ratio) { // zoom and tilt
      var d;
      if (Math.abs(moveX2) &lt; Math.abs(moveX1))
        d = moveX1;
      else
        d = moveX2;
      params.tiltAngle = 0.0004 * d;
      params.zoomScale = params.scaleFactor * 0.015 * pinchSize;
      zoomAndTiltViewpoint(viewpoint, params);
    } else if (Math.abs(moveY2 - moveY1) &lt; 3 * ratio &amp;&amp; Math.abs(moveX2 - moveX1) &lt; 3 * ratio) { // rotation (pitch and yaw)
      params.dx = moveX1 * 0.8;
      params.dy = moveY1 * 0.5;
      rotateViewpoint(viewpoint, params);
    }

    that.mouseState.touchDistance = newTouchDistance;
    that.mouseState.moved = true;
  }

  that.mouseState.x = x;
  that.mouseState.y = y;
  that.mouseState.x1 = x1;
  that.mouseState.y1 = y1;
  if (that.ontouchmove)
    that.ontouchmove(event);
}, true);
</t>
<t tx="leo.20210414181059.49">that.x3dNode.addEventListener('touchstart', function(event) {
  initMouseMove(event.targetTouches['0']);
  if (event.targetTouches.length === 2) {
    var touch1 = event.targetTouches['1'];
    that.mouseState.x1 = touch1.clientX;
    that.mouseState.y1 = touch1.clientY;
    var distanceX = that.mouseState.x - that.mouseState.x1;
    var distanceY = that.mouseState.y - that.mouseState.y1;
    that.mouseState.touchDistance = distanceX * distanceX + distanceY * distanceY;
    that.mouseState.touchOrientation = Math.atan2(that.mouseState.y1 - that.mouseState.y, that.mouseState.x1 - that.mouseState.x);
    that.mouseState.mouseDown = 3; // two fingers: rotation, tilt, zoom
  } else
    that.mouseState.mouseDown = 2; // 1 finger: translation or single click
}, true);
</t>
<t tx="leo.20210414181059.5">this.onrobotmessage = function(robot, message) {
  if (that.robotWindowNames[robot] === undefined) {
    console.log("Robot '" + robot + "' has no associated robot window");
    return;
  }
  that.robotWindows[that.robotWindowNames[robot]].receive(message, robot);
};
</t>
<t tx="leo.20210414181059.50">  that.x3dNode.addEventListener('touchend', function(event) {
    clearMouseMove();
    if (that.ontouchend)
      that.ontouchend(event);
  }, true);
} else {
</t>
<t tx="leo.20210414181059.51">that.x3dNode.addEventListener('wheel', function(event) {
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var vp = x3dom.fields.SFVec3f.parse(viewpoint.getAttribute('position'));
  var vo = x3dom.fields.SFVec4f.parse(viewpoint.getAttribute('orientation'));
  var mousePosition = that.x3dNode.runtime.mousePosition(event);
  var shootRay = that.x3dNode.runtime.shootRay(mousePosition[0], mousePosition[1]);
  var distanceToPickPosition;
  that.mouseState.pickPosition = shootRay.pickPosition;
  if (that.mouseState.pickPosition == null)
    distanceToPickPosition = vp.length();
  else
    distanceToPickPosition = vp.subtract(that.mouseState.pickPosition).length();
  if (distanceToPickPosition &lt; 0.001) // 1 mm
    distanceToPickPosition = 0.001;
  if (!that.enableNavigation || that.mouseState.wheelFocus === false) {
    var offset = event.deltaY;
    if (event.deltaMode === 1)
      offset *= 40; // standard line height in pixel
    window.scroll(0, window.pageYOffset + offset);
    if (that.mouseState.wheelTimeout) { // you have to rest at least 1.5 seconds over the x3d canvas
      clearTimeout(that.mouseState.wheelTimeout); // so that the wheel focus will get enabled and
      that.mouseState.wheelTimeout = setTimeout(wheelTimeoutCallback, 1500); // allow you to zoom in/out.
    }
    return;
  }
  var scaleFactor = 0.02 * distanceToPickPosition * ((event.deltaY &lt; 0) ? -1 : 1);
  var c = Math.cos(vo.w);
  var s = Math.sin(vo.w);
  var tz = (1 - c) * vo.z;
  var roll = new x3dom.fields.SFVec3f(tz * vo.x + s * vo.y, tz * vo.y - s * vo.x, tz * vo.z + c);
  var target = vp.add(roll.multiply(scaleFactor));
  viewpoint.setAttribute('position', target.toString());
  if (that.onmousewheel)
    that.onmousewheel(event);
}, true);
</t>
<t tx="leo.20210414181059.52">that.x3dNode.addEventListener('mousemove', function(event) {
  if (!that.enableNavigation &amp;&amp; event.button === 0)
    return;
  if (that.mouseState.x === undefined)
    // mousedown event has not been called yet
    // this could happen for example when another application has focus while loading the scene
    return;
  if ('buttons' in event)
    that.mouseState.mouseDown = event.buttons;
  else if ('which' in event) { // Safari only
    switch (event.which) {
      case 0: that.mouseState.mouseDown = 0; break;
      case 1: that.mouseState.mouseDown = 1; break;
      case 2: that.mouseState.pressedButton = 4; break;
      case 3: that.mouseState.pressedButton = 2; break;
      default: that.mouseState.pressedButton = 0; break;
    }
  }
  if (that.mouseState.mouseDown === 0) {
    if (that.animation &amp;&amp; that.animation.playSlider &amp;&amp; that.animation.sliding) {
      var w = event.target.clientWidth - 66; // size of the borders of the slider
      var x = event.clientX - event.target.getBoundingClientRect().left - 48; // size of the left border (including play button) of the slider
      var value = 100 * x / w;
      if (value &lt; 0)
        value = 0;
      else if (value &gt;= 100)
        value = 99.999;
      that.animation.playSlider.slider('value', value);
      // setting the value should trigger the change event, unfortunately, doesn't seem to work reliably,
      // therefore, we need to trigger this event manually:
      var ui = {};
      ui.value = value;
      that.animation.playSlider.slider('option', 'change').call(that.animation.playSlider, event, ui);
    }
    return;
  }
  if (that.mouseState.initialTimeStamp === null)
    // prevent applying mouse move action before drag initialization in mousedrag event
    return;

  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var params = {};
  params.dx = event.clientX - that.mouseState.x;
  params.dy = event.clientY - that.mouseState.y;
  params.vp = x3dom.fields.SFVec3f.parse(viewpoint.getAttribute('position'));
  params.vo = x3dom.fields.SFVec4f.parse(viewpoint.getAttribute('orientation'));
  params.c = Math.cos(params.vo.w);
  params.s = Math.sin(params.vo.w);

  if (that.mouseState.pickPosition == null)
    params.distanceToPickPosition = params.vp.length();
  else
    params.distanceToPickPosition = params.vp.subtract(that.mouseState.pickPosition).length() - 0.05; // FIXME this is different from webots.
  if (params.distanceToPickPosition &lt; 0.001) // 1 mm
    params.distanceToPickPosition = 0.001;

  // FIXME this is different from webots. We need to understand why the same formula doesn't work.
  params.scaleFactor = 1.90 * Math.tan(that.viewpointFieldOfView / 2);
  var viewHeight = parseFloat($(that.x3dNode).css('height').slice(0, -2));
  var viewWidth = parseFloat($(that.x3dNode).css('width').slice(0, -2));
  params.scaleFactor /= Math.max(viewHeight, viewWidth);

  if (that.mouseState.mouseDown === 1) { // left mouse button to rotate viewpoint
    params.distanceToPickPosition = 0;
    rotateViewpoint(viewpoint, params);
  } else if (that.mouseState.mouseDown === 2) // right mouse button to translate viewpoint {}
    translateViewpoint(viewpoint, params);
  else if (that.mouseState.mouseDown === 3 || that.mouseState.mouseDown === 4) { // both left and right button or middle button to zoom
    params.tiltAngle = 0.01 * params.dx;
    params.zoomScale = params.distanceToPickPosition * params.scaleFactor * 10 * params.dy; // FIXME this is different from webots.
    zoomAndTiltViewpoint(viewpoint, params, true);
  }
  that.mouseState.moved = event.clientX !== that.mouseState.x || event.clientY !== that.mouseState.y;
  that.mouseState.x = event.clientX;
  that.mouseState.y = event.clientY;
  if (that.onmousedrag)
    that.onmousedrag(event);
}, true);
</t>
<t tx="leo.20210414181059.53">that.x3dNode.addEventListener('mousedown', function(event) {
  that.mouseState.wheelFocus = true;
  if (event.button === 0)
    that.mouseState.mouseDown |= 1;
  else if (event.button === 1)
    that.mouseState.mouseDown |= 4;
  else if (event.button === 2)
    that.mouseState.mouseDown |= 2;
  initMouseMove(event);
}, true);
that.x3dNode.addEventListener('mouseup', clearMouseMove, true);
</t>
<t tx="leo.20210414181059.54">that.x3dNode.addEventListener('mouseover', function(event) {
  that.mouseState.wheelTimeout = setTimeout(wheelTimeoutCallback, 1500);
}, true);
</t>
<t tx="leo.20210414181059.55">  that.x3dNode.addEventListener('mouseleave', function(event) {
    if (that.mouseState.wheelTimeout != null) {
      clearTimeout(that.mouseState.wheelTimeout);
      that.mouseState.wheelTimeout = null;
    }
    that.mouseState.wheelFocus = false;
  }, true);
}

</t>
<t tx="leo.20210414181059.56">that.x3dScene.addEventListener('mouseup', function(event) {
  if (that.mouseState.moved === false &amp;&amp; (!that.mouseState.longClick || that.mobileDevice)) {
    var s = getTopX3dElement(event.target);
    if (that.previousSelection == null || that.previousSelection.id !== s.id || (that.mouseState.previousMouseDown === 2 &amp;&amp; (!that.mobileDevice || that.mouseState.longClick)))
      select(s);
    if (((that.mobileDevice &amp;&amp; that.mouseState.longClick) || (!that.mobileDevice &amp;&amp; that.mouseState.previousMouseDown === 2)) &amp;&amp;
        that.contextMenu === false &amp;&amp; that.isWebSocketProtocol) {
      // right click: show popup menu
      $(function() {
        var title = that.selection.getAttribute('name');
        if (title == null || title === '') {
          title = that.selection.getAttribute('DEF');
          if (title == null || title === '')
            title = 'Object';
        }
        $('#contextMenuTitle').html(title);
        var controller = that.selection.getAttribute('controller');
        if (controller) { // the current selection is a robot
          $('#contextMenuEditController').css('display', 'inline');
          if (controller === 'void' || controller.length === 0 || (webots.User1Id &amp;&amp; !webots.User1Authentication))
            $('#contextMenuEditController').children().addClass('ui-state-disabled');
          var robotName = that.selection.getAttribute('name');
          if (that.robotWindows[that.robotWindowNames[robotName]])
            $('#contextMenuRobotWindow').css('display', 'inline');
          else
            $('#contextMenuRobotWindow').css('display', 'none');
        } else {
          $('#contextMenuEditController').css('display', 'none');
          $('#contextMenuRobotWindow').css('display', 'none');
        }
        if (that.followedObject != null &amp;&amp; (that.selection.id === that.followedObject || that.selection.getAttribute('DEF') === that.followedObject)) {
          $('#contextMenuFollow').css('display', 'none');
          $('#contextMenuUnfollow').css('display', 'inline');
        } else {
          $('#contextMenuFollow').css('display', 'inline');
          $('#contextMenuUnfollow').css('display', 'none');
        }
        // ensure that the context menu is completely visible
        var w = $('#contextMenu').width();
        var h = $('#contextMenu').height();
        var maxWidth = $('#playerDiv').width();
        var maxHeight = $('#playerDiv').height();
        var left;
        var top;
        if (maxWidth != null &amp;&amp; (w + that.mouseState.x) &gt; maxWidth)
          left = maxWidth - w;
        else
          left = that.mouseState.x;
        if (maxHeight != null &amp;&amp; (h + that.mouseState.y) &gt; maxHeight)
          top = maxHeight - h - $('#toolBar').height();
        else
          top = that.mouseState.y;
        $('#contextMenu').css('left', left + 'px');
        $('#contextMenu').css('top', top + 'px');
        $('#contextMenu').css('display', 'block');
      });
    }
  }
  if (that.onmouseup)
    that.onmouseup(event);
}, false);
</t>
<t tx="leo.20210414181059.57"></t>
<t tx="leo.20210414181059.58">function wheelTimeoutCallback(event) {
  that.mouseState.wheelTimeout = null;
  that.mouseState.wheelFocus = true;
}
</t>
<t tx="leo.20210414181059.59">function getTopX3dElement(el) {
  // If it exists, return the upmost Solid, otherwise the top node
  var upmostSolid = null;
  while (el) {
    if (el.getAttribute('solid'))
      upmostSolid = el;
    if (el.parentNode === that.x3dScene)
      break;
    el = el.parentNode;
  }
  if (upmostSolid)
    return upmostSolid;
  return el;
}

</t>
<t tx="leo.20210414181059.6">this.onrobotwindowsdestroy = function() {
  that.robotWindowsGeometries = {};
  for (var win in that.robotWindows) {
    that.robotWindowsGeometries[win] = that.robotWindows[win].geometry();
    that.robotWindows[win].destroy();
  }
  that.infoWindow = null;
  that.robotWindows = {}; // delete robot windows
  that.robotWindowNames = {};
};
</t>
<t tx="leo.20210414181059.60">function unselect() {
  if (that.selection) {
    var selectors = that.selection.getElementsByClassName('selector');
    for (var i = 0; i &lt; selectors.length; i++) {
      var selector = selectors[i];
      selector.setAttribute('whichChoice', '-1');
    }
    that.selection = null;
  }
}

</t>
<t tx="leo.20210414181059.61">function select(el) {
  var selectors = el.getElementsByClassName('selector');
  for (var i = 0; i &lt; selectors.length; i++) {
    var selector = selectors[i];
    selector.setAttribute('whichChoice', '0');
  }
  that.selection = el;
}

</t>
<t tx="leo.20210414181059.62">function videoFinalize() {
  console.log('video finalize');
  addVideoMouseNavigation();
  if (that.onready)
    that.onready();
}

</t>
<t tx="leo.20210414181059.63">function sendVideoMouseEvent(type, event, wheel) {
  var socket = that.stream.socket;
  if (!socket || socket.readyState !== 1)
    return;
  var modifier = (event.shiftKey ? 1 : 0) + (event.ctrlKey ? 2 : 0) + (event.altKey ? 4 : 0);
  socket.send('mouse ' + type + ' ' + event.button + ' ' + that.mouseState.mouseDown + ' ' +
              event.offsetX + ' ' + event.offsetY + ' ' + modifier + ' ' + wheel);
}

</t>
<t tx="leo.20210414181059.64">function onVideoMouseDown(event) {
  event.target.addEventListener('mousemove', onVideoMouseMove, false);
  sendVideoMouseEvent(-1, event, 0);
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414181059.65">function onVideoMouseMove(event) {
  if (that.mouseState.mouseDown === 0) {
    event.target.removeEventListener('mousemove', onVideoMouseMove, false);
    return false;
  }
  sendVideoMouseEvent(0, event, 0);
  return false;
}

</t>
<t tx="leo.20210414181059.66">function onVideoMouseUp(event) {
  event.target.removeEventListener('mousemove', onVideoMouseMove, false);
  sendVideoMouseEvent(1, event, 0);
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414181059.67">function onVideoWheel(event) {
  sendVideoMouseEvent(2, event, Math.sign(event.deltaY));
  return false;
}

</t>
<t tx="leo.20210414181059.68">function onVideoContextMenu(event) {
  event.preventDefault();
  return false;
}

</t>
<t tx="leo.20210414181059.69">function addVideoMouseNavigation() {
  that.video.addEventListener('mousedown', onVideoMouseDown, false);
  that.video.addEventListener('mouseup', onVideoMouseUp, false);
  that.video.addEventListener('wheel', onVideoWheel, false);
  that.video.addEventListener('contextmenu', onVideoContextMenu, false);
}
</t>
<t tx="leo.20210414181059.7">this.onquit = function() {
  // If the simulation page URL is this https://mydomain.com/mydir/mysimulation.html, the quit action redirects to the
  // folder level, e.g., https://mydomain.com/mydir/
  // If the simulation page is https://mydomain.com/mydir/mysimulation/, the quit action redirects to the upper level:
  // https://mydomain.com/mydir/
  // You can change this behavior by overriding this onquit() method
  var currentLocation = window.location.href;
  // remove filename or last directory name from url and keep the final slash
  var quitDestination = currentLocation.substring(0, currentLocation.lastIndexOf('/', currentLocation.length - 2) + 1);
  window.location = quitDestination;
};
</t>
<t tx="leo.20210414181059.70">webots.View.prototype.toggleInfo = function() {
  $('#contextMenu').css('display', 'none');
  if (!this.infoWindow)
    return;
  if (this.infoWindow.isOpen()) {
    this.infoWindow.close();
    this.infoButton.classList.remove('toolBarButtonActive');
  } else {
    this.infoWindow.open();
    this.infoButton.classList.add('toolBarButtonActive');
  }
};

</t>
<t tx="leo.20210414181059.71">webots.View.prototype.follow = function(id) {
  this.followedObject = id;
  this.viewpointForce = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
  this.viewpointVelocity = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
};

</t>
<t tx="leo.20210414181059.72">webots.View.prototype.setViewpointMass = function(mass) {
  this.viewpointMass = mass;
  if (this.viewpointMass &lt;= 0.05)
    this.viewpointMass = 0.0;
  else {
    if (this.viewpointMass &gt; 1.0)
      this.viewpointMass = 1.0;
    this.friction = 0.05 / this.viewpointMass;
  }
};

</t>
<t tx="leo.20210414181059.73">webots.View.prototype.updateViewpointPosition = function(forcePosition) {
  if (this.time === undefined)
    return;
  if (this.viewpointLastUpdate === undefined)
    this.viewpointLastUpdate = this.time;

  var timeInterval = Math.abs(this.time - this.viewpointLastUpdate) / 1000;
  var viewpoints = this.x3dScene.getElementsByTagName('Viewpoint');

  if (timeInterval &gt; 0 &amp;&amp; viewpoints[0]) {
    this.viewpointLastUpdate = this.time;
    var viewpointPosition = x3dom.fields.SFVec3f.parse(viewpoints[0].getAttribute('position'));
    var viewpointDeltaPosition;
    if (this.followedObjectDeltaPosition != null)
      this.viewpointForce = this.viewpointForce.add(this.followedObjectDeltaPosition);

    // Special case: if the mass is 0 we simply move the viewpoint to its equilibrium position.
    // If timeInterval is too large (longer than 1/10 of a second), the progression won't be smooth either way,
    // so in this case we simply move the viewpoint to the equilibrium position as well.
    if (forcePosition || this.viewpointMass === 0 || (timeInterval &gt; 0.1 &amp;&amp; this.animation == null)) {
      viewpointDeltaPosition = this.viewpointForce;
      this.viewpointVelocity = new x3dom.fields.SFVec3f(0.0, 0.0, 0.0);
    } else {
      var acceleration = this.viewpointForce.divide(this.viewpointMass);
      this.viewpointVelocity = this.viewpointVelocity.add(acceleration.multiply(timeInterval));
      var scalarVelocity = this.viewpointVelocity.length();

      // Velocity of the object projected onto the velocity of the viewpoint.
      var scalarObjectVelocityProjection;
      if (this.followedObjectDeltaPosition != null) {
        var objectVelocity = this.followedObjectDeltaPosition.divide(timeInterval);
        scalarObjectVelocityProjection = objectVelocity.dot(this.viewpointVelocity) / scalarVelocity;
      } else
        scalarObjectVelocityProjection = 0;

      // The viewpoint is going "faster" than the object, to prevent oscillations we apply a slowing force.
      if (this.viewpointFriction &gt; 0 &amp;&amp; scalarVelocity &gt; scalarObjectVelocityProjection) {
        // We apply a friction based on the extra velocity.
        var velocityFactor = (scalarVelocity - (scalarVelocity - scalarObjectVelocityProjection) * this.viewpointFriction) / scalarVelocity;
        this.viewpointVelocity = this.viewpointVelocity.multiply(velocityFactor);
      }
      viewpointDeltaPosition = this.viewpointVelocity.multiply(timeInterval);
    }
    var viewpointNewPosition = viewpointPosition.add(viewpointDeltaPosition);
    this.viewpointForce = this.viewpointForce.subtract(viewpointDeltaPosition);
    viewpoints[0].setAttribute('position', viewpointNewPosition.toString());
    this.followedObjectDeltaPosition = null;
  }
};

</t>
<t tx="leo.20210414181059.74">webots.View.prototype.close = function() {
  if (this.server)
    this.server.socket.close();
  if (this.stream)
    this.stream.close();
};

</t>
<t tx="leo.20210414181059.75">webots.View.prototype.sendRobotMessage = function(robot, message) {
  this.stream.socket.send('robot:' + robot + ':' + message);
};

</t>
<t tx="leo.20210414181059.76">webots.View.prototype.resize = function(width, height) {
  if (this.mode !== 'video')
    return;
  this.video.width = width;
  this.video.height = height;
  this.stream.socket.send('resize: ' + width + 'x' + height);
};

</t>
<t tx="leo.20210414181059.77">webots.View.prototype.getControllerUrl = function(name) {
  if (!this.server)
    return;
  var port = 0;
  for (var i = 0; i &lt; this.server.controllers.length; i++) {
    if (this.server.controllers[i].name === name) {
      port = this.server.controllers[i].port;
      break;
    }
  }
  if (port === 0)
    return;
  return this.url.substring(0, this.url.indexOf(':', 6) + 1) + port;
};

</t>
<t tx="leo.20210414181059.78">webots.View.prototype.setAnimation = function(url, gui, loop) {
  if (gui === undefined)
    gui = 'play';
  if (loop === undefined)
    loop = true;
  this.animation = new webots.Animation(url, this, gui, loop);
};

</t>
<t tx="leo.20210414181059.79">webots.View.prototype.applyPose = function(pose) {
  var id = pose.id;
  var el = document.getElementById('n' + id);
  if (el &amp;&amp; !el.getAttribute('blockWebotsUpdate')) {
    for (var key in pose) {
      if (key !== 'id') {
        var value = pose[key];
        if (key === 'translation' &amp;&amp; this.followedObject &amp;&amp;
            (id === this.followedObject || // animation case
             el.id === this.followedObject || // streaming case
             el.getAttribute('DEF') === this.followedObject)) {
          var objectPosition = x3dom.fields.SFVec3f.parse(el.getAttribute('translation'));
          el.setAttribute(key, value);
          // If this is the followed object, we save a vector with the translation applied
          // to the object to compute the new position of the viewpoint.
          var objectNewPosition = x3dom.fields.SFVec3f.parse(value);
          this.followedObjectDeltaPosition = objectNewPosition.subtract(objectPosition);
        } else
          el.setAttribute(key, value);
      }
    }
  }
};

</t>
<t tx="leo.20210414181059.8">this.onresize = function() {
  var viewpoint = that.x3dScene.getElementsByTagName('Viewpoint')[0];
  var viewHeight = parseFloat($(that.x3dNode).css('height').slice(0, -2));
  var viewWidth = parseFloat($(that.x3dNode).css('width').slice(0, -2));
  if (that.viewpointFieldOfView == null) {
    var fieldOfView = viewpoint.getAttribute('fieldOfView');
    // Sometimes the page is not fully loaded by that point and the field of view is not yet available.
    // In that case we add a callback at the end of the queue to try again when all other callbacks are finished.
    if (fieldOfView == null) {
      setTimeout(that.onresize, 0);
      return;
    }
    that.viewpointFieldOfView = fieldOfView;
  }

  var fieldOfViewY = that.viewpointFieldOfView;
  if (viewWidth &gt; viewHeight) {
    var tanHalfFieldOfViewY = Math.tan(0.5 * that.viewpointFieldOfView) * viewHeight / viewWidth;
    fieldOfViewY = 2.0 * Math.atan(tanHalfFieldOfViewY);
  }

  viewpoint.setAttribute('fieldOfView', fieldOfViewY);
};
</t>
<t tx="leo.20210414181059.80">webots.Animation = function(url, view, gui, loop) { // gui may be either "play" or "pause"
  this.url = url;
  this.view = view;
  this.gui = gui;
  this.loop = loop;
  this.sliding = false;
  this.onready = null;
};

</t>
<t tx="leo.20210414181059.81">webots.Animation.prototype.init = function(onready) {
  var that = this;
  this.onready = onready;
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.open('GET', this.url, true);
  xmlhttp.overrideMimeType('application/json');
  @others
};

</t>
<t tx="leo.20210414181059.82">xmlhttp.onreadystatechange = function() {
  if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200)
    setup(JSON.parse(xmlhttp.responseText));
};
xmlhttp.send();
</t>
<t tx="leo.20210414181059.83">function setup(data) {
  that.data = data;
  var div = document.createElement('div');
  div.id = 'playBar';
  that.view.view3D.appendChild(div);
  that.button = document.createElement('button');
  that.button.id = 'playPauseButton';
  var action = (that.gui === 'play') ? 'pause' : 'play';
  that.button.style.backgroundImage = 'url(' + webots.WwiUrl + action + '.png)';
  that.button.style.padding = '0';
  that.button.onclick = triggerPlayPauseButton;
  div.appendChild(that.button);
  var slider = document.createElement('div');
  slider.id = 'playSlider';
  div.appendChild(slider);
  that.playSlider = $('#playSlider').slider({
    change: function(e, ui) { updateSlider(ui.value); },
    slide: function(e, ui) { updateSlider(ui.value); },
    start: function(e, ui) { that.sliding = true; },
    stop: function(e, ui) { that.sliding = false; }
  });
  that.start = new Date().getTime();
  that.step = 0;
  that.previousStep = 0;
  updateAnimation();
  if (that.onready)
    that.onready();
}

</t>
<t tx="leo.20210414181059.84">function elapsedTime() {
  var end = new Date().getTime();
  return end - that.start;
}

</t>
<t tx="leo.20210414181059.85">function triggerPlayPauseButton() {
  that.button.style.backgroundImage = 'url(' + webots.WwiUrl + that.gui + '.png)';
  if (that.gui === 'play') {
    that.gui = 'pause';
    if (that.step &lt; 0 || that.step &gt;= that.data.frames.length) {
      that.start = new Date().getTime();
      updateAnimationState(true);
    } else
      that.start = new Date().getTime() - that.data.basicTimeStep * that.step;
  } else {
    that.gui = 'play';
    that.start = new Date().getTime() - that.data.basicTimeStep * that.step;
    requestAnimationFrame(updateAnimation);
  }
}

</t>
<t tx="leo.20210414181059.86">function connectSliderEvents() {
  that.playSlider = that.playSlider.slider({
    change: function(e, ui) { updateSlider(ui.value); },
    slide: function(e, ui) { updateSlider(ui.value); },
    start: function(e, ui) { that.sliding = true; },
    stop: function(e, ui) { that.sliding = false; }
  });
}

</t>
<t tx="leo.20210414181059.87">function disconnectSliderEvents() {
  that.playSlider.slider({change: null, slide: null});
}

</t>
<t tx="leo.20210414181059.88">function updateSlider(value) {
  that.step = Math.floor(that.data.frames.length * value / 100);
  that.start = (new Date().getTime()) - Math.floor(that.data.basicTimeStep * that.step);
  updateAnimationState(false);
}

</t>
<t tx="leo.20210414181059.89">function updateAnimationState(moveSlider) {
  if (moveSlider) {
    that.step = Math.floor(elapsedTime() / that.data.basicTimeStep);
    if (that.step &lt; 0 || that.step &gt;= that.data.frames.length) {
      if (that.loop) {
        if (that.step &gt; that.data.frames.length) {
          that.step = 0;
          that.previousStep = 0;
          that.start = new Date().getTime();
        } else
          return;
      } else if (that.gui === 'play') {
        triggerPlayPauseButton();
        return;
      } else
        return;
    }
  }
  var p;
  var appliedIds = [];
  if (that.data.frames[that.step].hasOwnProperty('poses')) {
    var poses = that.data.frames[that.step].poses;
    for (p = 0; p &lt; poses.length; p++) {
      that.view.applyPose(poses[p]);
      appliedIds[appliedIds.length] = poses[p].id;
    }
  }
  // lookback mechanism: search in history
  if (that.step !== that.previousStep + 1) {
    var previousPoseStep;
    if (that.step &gt; that.previousStep)
      // in forward animation check only the changes since last pose
      previousPoseStep = that.previousStep;
    else
      previousPoseStep = 0;
    var allIds = that.data.ids.split(';');
    for (var i = 0; i &lt; allIds.length; i++) {
      var id = parseInt(allIds[i]);
      if (appliedIds.indexOf(id) === -1) {
        outer:
        for (var f = that.step - 1; f &gt;= previousPoseStep; f--) {
          if (that.data.frames[f].poses) {
            for (p = 0; p &lt; that.data.frames[f].poses.length; p++) {
              if (that.data.frames[f].poses[p].id === id) {
                that.view.applyPose(that.data.frames[f].poses[p]);
                break outer;
              }
            }
          }
        }
      }
    }
  }
  if (moveSlider) {
    disconnectSliderEvents();
    that.playSlider.slider('option', 'value', 100 * that.step / that.data.frames.length);
    connectSliderEvents();
  }
  that.previousStep = that.step;
  that.view.time = that.data.frames[that.step].time;
  if (that.view.followedObject != null &amp;&amp; that.view.followedObject !== 'none')
    that.view.updateViewpointPosition(!moveSlider | that.step === 0);
}

</t>
<t tx="leo.20210414181059.9">this.ondialogwindow = function(opening) {
  // Pause the simulation if needed when a pop-up dialog window is open
  // and restart running the simulation when it is closed
  if (opening &amp;&amp; that.isAutomaticallyPaused === undefined) {
    that.isAutomaticallyPaused = webots.currentView.pauseButton.style.display === 'inline';
    that.pauseButton.click();
  } else if (!opening &amp;&amp; that.isAutomaticallyPaused) {
    that.real_timeButton.click();
    that.isAutomaticallyPaused = undefined;
  }
};
window.onresize = this.onresize;
this.robotWindowNames = {}; // map robot name to robot window name used as key in robotWindows lists
this.robotWindows = {};
this.followedObject = null; // after initialization contains the id of the followed node or -1 if no object is followed
// If the followed object has moved since the last time we updated the viewpoint position, this field will contain a
// vector with the translation applied to the object.
this.followedObjectDeltaPosition = null;
this.viewpointMass = 1.0; // Mass of the viewpoint used during the object following algorithm.
this.viewpointFriction = 0.05; // Friction applied to the viewpoint whenever it is going faster than the followed object.
this.viewpointForce = null; // Vector with the force that will be applied to the viewpoint for the next delta T.
this.viewpointVelocity = null; // Current velocity of the viewpoint.
this.viewpointLastUpdate = undefined; // Last time we updated the position of the viewpoint.
this.onmousedown = null;
this.onworldloaded = null;
this.view3D = view3D;
this.viewpointFieldOfView = null;
if (mobile === undefined)
  this.mobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
else
  this.mobileDevice = mobile;
this.fullscreenEnabled = !/iPhone|iPad|iPop/i.test(navigator.userAgent);
if (!this.fullscreenEnabled)
  // add tag needed to run standalone web page in fullscreen on iOS
  $('head').append('&lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;');

// prevent the backspace key to quit the simulation page
var rx = /INPUT|SELECT|TEXTAREA/i;
</t>
<t tx="leo.20210414181059.90">function updateAnimation() {
  if (that.gui === 'play') {
    updateAnimationState(true);
    requestAnimationFrame(updateAnimation);
  }
}
</t>
<t tx="leo.20210414181059.91">webots.Server = function(url, view, onready) {
  var that = this;
  this.view = view;
  this.onready = onready;
  // url has the following form: "ws(s)://cyberbotics2.cyberbotics.com:80/simple/worlds/simple.wbt"
  var n = url.indexOf('/', 6);
  var m = url.lastIndexOf('/');
  this.url = 'http' + url.substring(2, n); // e.g., "http(s)://cyberbotics2.cyberbotics.com:80"
  this.project = url.substring(n + 1, m - 7); // e.g., "simple"
  this.worldFile = url.substring(m + 1); // e.g., "simple.wbt"
  this.controllers = [];
  var xhr = new XMLHttpRequest();
  xhr.open('GET', this.url + '/session', true);
  $('#webotsProgressMessage').html('Connecting to session server...');
  xhr.onreadystatechange = function(e) {
    if (xhr.readyState !== 4)
      return;
    if (xhr.status !== 200)
      return;
    var data = xhr.responseText;
    if (data.startsWith('Error:')) {
      $('#webotsProgress').hide();
      var errorMessage = data.substring(6).trim();
      errorMessage = errorMessage.charAt(0).toUpperCase() + errorMessage.substring(1);
      webots.alert('Session server error', errorMessage);
      return;
    }
    that.socket = new WebSocket(data + '/client');
    @others
  };
  xhr.send();
};

</t>
<t tx="leo.20210414181059.92"></t>
<t tx="leo.20210414181059.93">that.socket.onopen = function(event) {
  var host = location.protocol + '//' + location.host.replace(/^www./, ''); // remove 'www' prefix
  if (typeof webots.User1Id === 'undefined')
    webots.User1Id = '';
  if (typeof webots.User1Name === 'undefined')
    webots.User1Name = '';
  if (typeof webots.User1Authentication === 'undefined')
    webots.User1Authentication = '';
  if (typeof webots.User2Id === 'undefined')
    webots.User2Id = '';
  if (typeof webots.User2Name === 'undefined')
    webots.User2Name = '';
  if (typeof webots.CustomData === 'undefined')
    webots.CustomData = '';
  this.send('{ "init" : [ "' + host + '", "' + that.project + '", "' + that.worldFile + '", "' +
            webots.User1Id + '", "' + webots.User1Name + '", "' + webots.User1Authentication + '", "' +
            webots.User2Id + '", "' + webots.User2Name + '", "' + webots.CustomData + '" ] }');
  $('#webotsProgressMessage').html('Starting simulation...');
};
</t>
<t tx="leo.20210414181059.94">that.socket.onclose = function(event) {
  view.console.info('Disconnected to the Webots server.');
};
</t>
<t tx="leo.20210414181059.95">that.socket.onmessage = function(event) {
  var message = event.data;
  if (message.indexOf('webots:ws://') === 0 || message.indexOf('webots:wss://') === 0)
    view.stream = new webots.Stream(message.substring(7), view, that.onready);
  else if (message.indexOf('controller:') === 0) {
    var n = message.indexOf(':', 11);
    var controller = {};
    controller.name = message.substring(11, n);
    controller.port = message.substring(n + 1);
    view.console.info('Using controller ' + controller.name + ' on port ' + controller.port);
    that.controllers.push(controller);
  } else if (message.indexOf('queue:') === 0)
    view.console.error('The server is saturated. Queue to wait: ' + message.substring(6) + ' client(s).');
  else if (message === '.') { // received every 5 seconds when Webots is running
    // nothing to do
  } else if (message.indexOf('reset controller:') === 0)
    view.stream.socket.send('sync controller:' + message.substring(18).trim());
  else
    console.log('Received an unknown message from the Webots server socket: "' + message + '"');
};
</t>
<t tx="leo.20210414181059.96">that.socket.onerror = function(event) {
  view.console.error('Cannot connect to the simulation server');
};
</t>
<t tx="leo.20210414181059.97">webots.Server.prototype.resetController = function(filename) {
  this.socket.send('{ "reset controller" : "' + filename + '" }');
};

</t>
<t tx="leo.20210414181059.98">webots.Stream = function(url, view, onready) {
  var that = this;
  this.view = view;
  this.onready = onready;

  this.socket = new WebSocket(url);
  $('#webotsProgressMessage').html('Connecting to Webots instance...');
  @others
};

</t>
<t tx="leo.20210414181059.99">this.socket.onopen = function() {
  var mode = that.view.mode;
  if (mode === 'video')
    mode += ': ' + that.view.video.width + 'x' + that.view.video.height;
  else if (that.view.broadcast)
    mode += ';broadcast';
  that.socket.send(mode);
};
</t>
<t tx="leo.20210414181506.1">https://cyberbotics.com/doc/discord/technical-questions</t>
<t tx="leo.20210414181645.1">https://www.cyberbotics.com/doc/guide/web-streaming</t>
<t tx="leo.20210414212857.1">http://showdownjs.com/

https://github.com/showdownjs/showdown/wiki</t>
</tnodes>
</leo_file>
